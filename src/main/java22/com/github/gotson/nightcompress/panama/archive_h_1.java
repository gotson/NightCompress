// Generated by jextract

package com.github.gotson.nightcompress.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class archive_h_1 extends archive_h_2 {

    archive_h_1() {
        // Should not be called directly
    }

    private static class getgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static FunctionDescriptor getgid$descriptor() {
        return getgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static MethodHandle getgid$handle() {
        return getgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static MemorySegment getgid$address() {
        return getgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * gid_t getgid()
     * }
     */
    public static int getgid() {
        var mh$ = getgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static FunctionDescriptor getgroups$descriptor() {
        return getgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static MethodHandle getgroups$handle() {
        return getgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static MemorySegment getgroups$address() {
        return getgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getgroups(int, gid_t [])
     * }
     */
    public static int getgroups(int x0, MemorySegment x1) {
        var mh$ = getgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static FunctionDescriptor getlogin$descriptor() {
        return getlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MethodHandle getlogin$handle() {
        return getlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MemorySegment getlogin$address() {
        return getlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getlogin()
     * }
     */
    public static MemorySegment getlogin() {
        var mh$ = getlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static FunctionDescriptor getpgrp$descriptor() {
        return getpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static MethodHandle getpgrp$handle() {
        return getpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static MemorySegment getpgrp$address() {
        return getpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpgrp()
     * }
     */
    public static int getpgrp() {
        var mh$ = getpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static FunctionDescriptor getpid$descriptor() {
        return getpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static MethodHandle getpid$handle() {
        return getpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static MemorySegment getpid$address() {
        return getpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpid()
     * }
     */
    public static int getpid() {
        var mh$ = getpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getppid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getppid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static FunctionDescriptor getppid$descriptor() {
        return getppid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static MethodHandle getppid$handle() {
        return getppid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static MemorySegment getppid$address() {
        return getppid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getppid()
     * }
     */
    public static int getppid() {
        var mh$ = getppid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getppid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static FunctionDescriptor getuid$descriptor() {
        return getuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static MethodHandle getuid$handle() {
        return getuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static MemorySegment getuid$address() {
        return getuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uid_t getuid()
     * }
     */
    public static int getuid() {
        var mh$ = getuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getuid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class isatty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("isatty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static FunctionDescriptor isatty$descriptor() {
        return isatty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static MethodHandle isatty$handle() {
        return isatty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static MemorySegment isatty$address() {
        return isatty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int isatty(int)
     * }
     */
    public static int isatty(int x0) {
        var mh$ = isatty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("isatty", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static FunctionDescriptor link$descriptor() {
        return link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static MethodHandle link$handle() {
        return link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static MemorySegment link$address() {
        return link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int link(const char *, const char *)
     * }
     */
    public static int link(MemorySegment x0, MemorySegment x1) {
        var mh$ = link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("link", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_INT,
            archive_h.C_LONG_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("lseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static FunctionDescriptor lseek$descriptor() {
        return lseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static MethodHandle lseek$handle() {
        return lseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static MemorySegment lseek$address() {
        return lseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * off_t lseek(int, off_t, int)
     * }
     */
    public static long lseek(int x0, long x1, int x2) {
        var mh$ = lseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lseek", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("pathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static FunctionDescriptor pathconf$descriptor() {
        return pathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static MethodHandle pathconf$handle() {
        return pathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static MemorySegment pathconf$address() {
        return pathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long pathconf(const char *, int)
     * }
     */
    public static long pathconf(MemorySegment x0, int x1) {
        var mh$ = pathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pathconf", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static FunctionDescriptor pause$descriptor() {
        return pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static MethodHandle pause$handle() {
        return pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static MemorySegment pause$address() {
        return pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pause()
     * }
     */
    public static int pause() {
        var mh$ = pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pause");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("pipe");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static FunctionDescriptor pipe$descriptor() {
        return pipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static MethodHandle pipe$handle() {
        return pipe.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static MemorySegment pipe$address() {
        return pipe.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pipe(int [2])
     * }
     */
    public static int pipe(MemorySegment x0) {
        var mh$ = pipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pipe", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static FunctionDescriptor read$descriptor() {
        return read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static MethodHandle read$handle() {
        return read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static MemorySegment read$address() {
        return read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t read(int, void *, size_t)
     * }
     */
    public static long read(int x0, MemorySegment x1, long x2) {
        var mh$ = read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("read", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rmdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("rmdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static FunctionDescriptor rmdir$descriptor() {
        return rmdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static MethodHandle rmdir$handle() {
        return rmdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static MemorySegment rmdir$address() {
        return rmdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rmdir(const char *)
     * }
     */
    public static int rmdir(MemorySegment x0) {
        var mh$ = rmdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rmdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static FunctionDescriptor setgid$descriptor() {
        return setgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static MethodHandle setgid$handle() {
        return setgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static MemorySegment setgid$address() {
        return setgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setgid(gid_t)
     * }
     */
    public static int setgid(int x0) {
        var mh$ = setgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static FunctionDescriptor setpgid$descriptor() {
        return setpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static MethodHandle setpgid$handle() {
        return setpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static MemorySegment setpgid$address() {
        return setpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpgid(pid_t, pid_t)
     * }
     */
    public static int setpgid(int x0, int x1) {
        var mh$ = setpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static FunctionDescriptor setsid$descriptor() {
        return setsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static MethodHandle setsid$handle() {
        return setsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static MemorySegment setsid$address() {
        return setsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t setsid()
     * }
     */
    public static int setsid() {
        var mh$ = setsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static FunctionDescriptor setuid$descriptor() {
        return setuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static MethodHandle setuid$handle() {
        return setuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static MemorySegment setuid$address() {
        return setuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setuid(uid_t)
     * }
     */
    public static int setuid(int x0) {
        var mh$ = setuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setuid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("sleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static FunctionDescriptor sleep$descriptor() {
        return sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static MethodHandle sleep$handle() {
        return sleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static MemorySegment sleep$address() {
        return sleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int sleep(unsigned int)
     * }
     */
    public static int sleep(int x0) {
        var mh$ = sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sleep", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sysconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("sysconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static FunctionDescriptor sysconf$descriptor() {
        return sysconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static MethodHandle sysconf$handle() {
        return sysconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static MemorySegment sysconf$address() {
        return sysconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long sysconf(int)
     * }
     */
    public static long sysconf(int x0) {
        var mh$ = sysconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sysconf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcgetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("tcgetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static FunctionDescriptor tcgetpgrp$descriptor() {
        return tcgetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static MethodHandle tcgetpgrp$handle() {
        return tcgetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static MemorySegment tcgetpgrp$address() {
        return tcgetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t tcgetpgrp(int)
     * }
     */
    public static int tcgetpgrp(int x0) {
        var mh$ = tcgetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcgetpgrp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tcsetpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("tcsetpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static FunctionDescriptor tcsetpgrp$descriptor() {
        return tcsetpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static MethodHandle tcsetpgrp$handle() {
        return tcsetpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static MemorySegment tcsetpgrp$address() {
        return tcsetpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int tcsetpgrp(int, pid_t)
     * }
     */
    public static int tcsetpgrp(int x0, int x1) {
        var mh$ = tcsetpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tcsetpgrp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ttyname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static FunctionDescriptor ttyname$descriptor() {
        return ttyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MethodHandle ttyname$handle() {
        return ttyname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MemorySegment ttyname$address() {
        return ttyname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ttyname(int)
     * }
     */
    public static MemorySegment ttyname(int x0) {
        var mh$ = ttyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ttyname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static FunctionDescriptor ttyname_r$descriptor() {
        return ttyname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static MethodHandle ttyname_r$handle() {
        return ttyname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static MemorySegment ttyname_r$address() {
        return ttyname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ttyname_r(int, char *, size_t)
     * }
     */
    public static int ttyname_r(int x0, MemorySegment x1, long x2) {
        var mh$ = ttyname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyname_r", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("unlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static FunctionDescriptor unlink$descriptor() {
        return unlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static MethodHandle unlink$handle() {
        return unlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static MemorySegment unlink$address() {
        return unlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlink(const char *)
     * }
     */
    public static int unlink(MemorySegment x0) {
        var mh$ = unlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlink", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static FunctionDescriptor write$descriptor() {
        return write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static MethodHandle write$handle() {
        return write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static MemorySegment write$address() {
        return write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t write(int __fd, const void *__buf, size_t __nbyte)
     * }
     */
    public static long write(int __fd, MemorySegment __buf, long __nbyte) {
        var mh$ = write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("write", __fd, __buf, __nbyte);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class confstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("confstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static FunctionDescriptor confstr$descriptor() {
        return confstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static MethodHandle confstr$handle() {
        return confstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static MemorySegment confstr$address() {
        return confstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t confstr(int, char *, size_t)
     * }
     */
    public static long confstr(int x0, MemorySegment x1, long x2) {
        var mh$ = confstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("confstr", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static FunctionDescriptor getopt$descriptor() {
        return getopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static MethodHandle getopt$handle() {
        return getopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static MemorySegment getopt$address() {
        return getopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getopt(int, char *const [], const char *)
     * }
     */
    public static int getopt(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optarg$constants {
        public static final AddressLayout LAYOUT = archive_h.C_POINTER;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("optarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static AddressLayout optarg$layout() {
        return optarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg$segment() {
        return optarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static MemorySegment optarg() {
        return optarg$constants.SEGMENT.get(optarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *optarg
     * }
     */
    public static void optarg(MemorySegment varValue) {
        optarg$constants.SEGMENT.set(optarg$constants.LAYOUT, 0L, varValue);
    }

    private static class optind$constants {
        public static final OfInt LAYOUT = archive_h.C_INT;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("optind").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static OfInt optind$layout() {
        return optind$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static MemorySegment optind$segment() {
        return optind$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static int optind() {
        return optind$constants.SEGMENT.get(optind$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optind
     * }
     */
    public static void optind(int varValue) {
        optind$constants.SEGMENT.set(optind$constants.LAYOUT, 0L, varValue);
    }

    private static class opterr$constants {
        public static final OfInt LAYOUT = archive_h.C_INT;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("opterr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static OfInt opterr$layout() {
        return opterr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static MemorySegment opterr$segment() {
        return opterr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static int opterr() {
        return opterr$constants.SEGMENT.get(opterr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int opterr
     * }
     */
    public static void opterr(int varValue) {
        opterr$constants.SEGMENT.set(opterr$constants.LAYOUT, 0L, varValue);
    }

    private static class optopt$constants {
        public static final OfInt LAYOUT = archive_h.C_INT;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("optopt").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static OfInt optopt$layout() {
        return optopt$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static MemorySegment optopt$segment() {
        return optopt$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static int optopt() {
        return optopt$constants.SEGMENT.get(optopt$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optopt
     * }
     */
    public static void optopt(int varValue) {
        optopt$constants.SEGMENT.set(optopt$constants.LAYOUT, 0L, varValue);
    }

    private static class brk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("brk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static FunctionDescriptor brk$descriptor() {
        return brk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MethodHandle brk$handle() {
        return brk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MemorySegment brk$address() {
        return brk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *brk(const void *)
     * }
     */
    public static MemorySegment brk(MemorySegment x0) {
        var mh$ = brk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("brk", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chroot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("chroot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static FunctionDescriptor chroot$descriptor() {
        return chroot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static MethodHandle chroot$handle() {
        return chroot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static MemorySegment chroot$address() {
        return chroot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chroot(const char *)
     * }
     */
    public static int chroot(MemorySegment x0) {
        var mh$ = chroot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chroot", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class crypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("crypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static FunctionDescriptor crypt$descriptor() {
        return crypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MethodHandle crypt$handle() {
        return crypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MemorySegment crypt$address() {
        return crypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *crypt(const char *, const char *)
     * }
     */
    public static MemorySegment crypt(MemorySegment x0, MemorySegment x1) {
        var mh$ = crypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("crypt", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class encrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("encrypt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static FunctionDescriptor encrypt$descriptor() {
        return encrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static MethodHandle encrypt$handle() {
        return encrypt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static MemorySegment encrypt$address() {
        return encrypt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void encrypt(char *, int)
     * }
     */
    public static void encrypt(MemorySegment x0, int x1) {
        var mh$ = encrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("encrypt", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fchdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static FunctionDescriptor fchdir$descriptor() {
        return fchdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static MethodHandle fchdir$handle() {
        return fchdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static MemorySegment fchdir$address() {
        return fchdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchdir(int)
     * }
     */
    public static int fchdir(int x0) {
        var mh$ = fchdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("gethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static FunctionDescriptor gethostid$descriptor() {
        return gethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static MethodHandle gethostid$handle() {
        return gethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static MemorySegment gethostid$address() {
        return gethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long gethostid()
     * }
     */
    public static long gethostid() {
        var mh$ = gethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostid");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getpgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static FunctionDescriptor getpgid$descriptor() {
        return getpgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static MethodHandle getpgid$handle() {
        return getpgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static MemorySegment getpgid$address() {
        return getpgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getpgid(pid_t)
     * }
     */
    public static int getpgid(int x0) {
        var mh$ = getpgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getsid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static FunctionDescriptor getsid$descriptor() {
        return getsid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static MethodHandle getsid$handle() {
        return getsid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static MemorySegment getsid$address() {
        return getsid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t getsid(pid_t)
     * }
     */
    public static int getsid(int x0) {
        var mh$ = getsid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdtablesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getdtablesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static FunctionDescriptor getdtablesize$descriptor() {
        return getdtablesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static MethodHandle getdtablesize$handle() {
        return getdtablesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static MemorySegment getdtablesize$address() {
        return getdtablesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdtablesize()
     * }
     */
    public static int getdtablesize() {
        var mh$ = getdtablesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdtablesize");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpagesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getpagesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static FunctionDescriptor getpagesize$descriptor() {
        return getpagesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static MethodHandle getpagesize$handle() {
        return getpagesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static MemorySegment getpagesize$address() {
        return getpagesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpagesize()
     * }
     */
    public static int getpagesize() {
        var mh$ = getpagesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpagesize");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getpass");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static FunctionDescriptor getpass$descriptor() {
        return getpass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MethodHandle getpass$handle() {
        return getpass.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MemorySegment getpass$address() {
        return getpass.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getpass(const char *)
     * }
     */
    public static MemorySegment getpass(MemorySegment x0) {
        var mh$ = getpass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpass", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static FunctionDescriptor getwd$descriptor() {
        return getwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MethodHandle getwd$handle() {
        return getwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MemorySegment getwd$address() {
        return getwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getwd(char *)
     * }
     */
    public static MemorySegment getwd(MemorySegment x0) {
        var mh$ = getwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwd", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("lchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor lchown$descriptor() {
        return lchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static MethodHandle lchown$handle() {
        return lchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static MemorySegment lchown$address() {
        return lchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchown(const char *, uid_t, gid_t)
     * }
     */
    public static int lchown(MemorySegment x0, int x1, int x2) {
        var mh$ = lchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lockf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("lockf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static FunctionDescriptor lockf$descriptor() {
        return lockf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static MethodHandle lockf$handle() {
        return lockf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static MemorySegment lockf$address() {
        return lockf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lockf(int, int, off_t)
     * }
     */
    public static int lockf(int x0, int x1, long x2) {
        var mh$ = lockf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lockf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("nice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static FunctionDescriptor nice$descriptor() {
        return nice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static MethodHandle nice$handle() {
        return nice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static MemorySegment nice$address() {
        return nice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nice(int)
     * }
     */
    public static int nice(int x0) {
        var mh$ = nice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nice", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("pread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static FunctionDescriptor pread$descriptor() {
        return pread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MethodHandle pread$handle() {
        return pread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MemorySegment pread$address() {
        return pread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static long pread(int __fd, MemorySegment __buf, long __nbyte, long __offset) {
        var mh$ = pread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pread", __fd, __buf, __nbyte, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("pwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static FunctionDescriptor pwrite$descriptor() {
        return pwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MethodHandle pwrite$handle() {
        return pwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static MemorySegment pwrite$address() {
        return pwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t __offset)
     * }
     */
    public static long pwrite(int __fd, MemorySegment __buf, long __nbyte, long __offset) {
        var mh$ = pwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pwrite", __fd, __buf, __nbyte, __offset);
            }
            return (long)mh$.invokeExact(__fd, __buf, __nbyte, __offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("sbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static FunctionDescriptor sbrk$descriptor() {
        return sbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MethodHandle sbrk$handle() {
        return sbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MemorySegment sbrk$address() {
        return sbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *sbrk(int)
     * }
     */
    public static MemorySegment sbrk(int x0) {
        var mh$ = sbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sbrk", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpgrp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setpgrp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static FunctionDescriptor setpgrp$descriptor() {
        return setpgrp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static MethodHandle setpgrp$handle() {
        return setpgrp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static MemorySegment setpgrp$address() {
        return setpgrp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t setpgrp()
     * }
     */
    public static int setpgrp() {
        var mh$ = setpgrp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpgrp");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setregid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setregid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static FunctionDescriptor setregid$descriptor() {
        return setregid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static MethodHandle setregid$handle() {
        return setregid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static MemorySegment setregid$address() {
        return setregid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setregid(gid_t, gid_t)
     * }
     */
    public static int setregid(int x0, int x1) {
        var mh$ = setregid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setregid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setreuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setreuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static FunctionDescriptor setreuid$descriptor() {
        return setreuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static MethodHandle setreuid$handle() {
        return setreuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static MemorySegment setreuid$address() {
        return setreuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setreuid(uid_t, uid_t)
     * }
     */
    public static int setreuid(int x0, int x1) {
        var mh$ = setreuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setreuid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t)
     * }
     */
    public static void swab(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("sync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static FunctionDescriptor sync$descriptor() {
        return sync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static MethodHandle sync$handle() {
        return sync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static MemorySegment sync$address() {
        return sync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sync()
     * }
     */
    public static void sync() {
        var mh$ = sync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("truncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static FunctionDescriptor truncate$descriptor() {
        return truncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static MethodHandle truncate$handle() {
        return truncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static MemorySegment truncate$address() {
        return truncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int truncate(const char *, off_t)
     * }
     */
    public static int truncate(MemorySegment x0, long x1) {
        var mh$ = truncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ualarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ualarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static FunctionDescriptor ualarm$descriptor() {
        return ualarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static MethodHandle ualarm$handle() {
        return ualarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static MemorySegment ualarm$address() {
        return ualarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * useconds_t ualarm(useconds_t, useconds_t)
     * }
     */
    public static int ualarm(int x0, int x1) {
        var mh$ = ualarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ualarm", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class usleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("usleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static FunctionDescriptor usleep$descriptor() {
        return usleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static MethodHandle usleep$handle() {
        return usleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static MemorySegment usleep$address() {
        return usleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int usleep(useconds_t)
     * }
     */
    public static int usleep(int x0) {
        var mh$ = usleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("usleep", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("vfork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static FunctionDescriptor vfork$descriptor() {
        return vfork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static MethodHandle vfork$handle() {
        return vfork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static MemorySegment vfork$address() {
        return vfork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfork()
     * }
     */
    public static int vfork() {
        var mh$ = vfork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfork");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fsync");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static FunctionDescriptor fsync$descriptor() {
        return fsync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static MethodHandle fsync$handle() {
        return fsync.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static MemorySegment fsync$address() {
        return fsync.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsync(int)
     * }
     */
    public static int fsync(int x0) {
        var mh$ = fsync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftruncate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ftruncate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static FunctionDescriptor ftruncate$descriptor() {
        return ftruncate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static MethodHandle ftruncate$handle() {
        return ftruncate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static MemorySegment ftruncate$address() {
        return ftruncate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ftruncate(int, off_t)
     * }
     */
    public static int ftruncate(int x0, long x1) {
        var mh$ = ftruncate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftruncate", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getlogin_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getlogin_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static FunctionDescriptor getlogin_r$descriptor() {
        return getlogin_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static MethodHandle getlogin_r$handle() {
        return getlogin_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static MemorySegment getlogin_r$address() {
        return getlogin_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getlogin_r(char *, size_t)
     * }
     */
    public static int getlogin_r(MemorySegment x0, long x1) {
        var mh$ = getlogin_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getlogin_r", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fchown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor fchown$descriptor() {
        return fchown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static MethodHandle fchown$handle() {
        return fchown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static MemorySegment fchown$address() {
        return fchown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchown(int, uid_t, gid_t)
     * }
     */
    public static int fchown(int x0, int x1, int x2) {
        var mh$ = fchown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("gethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static FunctionDescriptor gethostname$descriptor() {
        return gethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static MethodHandle gethostname$handle() {
        return gethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static MemorySegment gethostname$address() {
        return gethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gethostname(char *, size_t)
     * }
     */
    public static int gethostname(MemorySegment x0, long x1) {
        var mh$ = gethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("readlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor readlink$descriptor() {
        return readlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static MethodHandle readlink$handle() {
        return readlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static MemorySegment readlink$address() {
        return readlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t readlink(const char *restrict, char *restrict, size_t)
     * }
     */
    public static long readlink(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = readlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlink", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static FunctionDescriptor setegid$descriptor() {
        return setegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static MethodHandle setegid$handle() {
        return setegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static MemorySegment setegid$address() {
        return setegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setegid(gid_t)
     * }
     */
    public static int setegid(int x0) {
        var mh$ = setegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setegid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("seteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static FunctionDescriptor seteuid$descriptor() {
        return seteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static MethodHandle seteuid$handle() {
        return seteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static MemorySegment seteuid$address() {
        return seteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int seteuid(uid_t)
     * }
     */
    public static int seteuid(int x0) {
        var mh$ = seteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seteuid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("symlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static FunctionDescriptor symlink$descriptor() {
        return symlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static MethodHandle symlink$handle() {
        return symlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static MemorySegment symlink$address() {
        return symlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int symlink(const char *, const char *)
     * }
     */
    public static int symlink(MemorySegment x0, MemorySegment x1) {
        var mh$ = symlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlink", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __darwin_check_fd_set_overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("__darwin_check_fd_set_overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static FunctionDescriptor __darwin_check_fd_set_overflow$descriptor() {
        return __darwin_check_fd_set_overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MethodHandle __darwin_check_fd_set_overflow$handle() {
        return __darwin_check_fd_set_overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static MemorySegment __darwin_check_fd_set_overflow$address() {
        return __darwin_check_fd_set_overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __darwin_check_fd_set_overflow(int, const void *, int)
     * }
     */
    public static int __darwin_check_fd_set_overflow(int x0, MemorySegment x1, int x2) {
        var mh$ = __darwin_check_fd_set_overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__darwin_check_fd_set_overflow", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_suseconds_t suseconds_t
     * }
     */
    public static final OfInt suseconds_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = archive_h.C_INT;

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pselect(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, const struct timespec *restrict, const sigset_t *restrict)
     * }
     */
    public static int pselect(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int select(int, fd_set *restrict, fd_set *restrict, fd_set *restrict, struct timeval *restrict)
     * }
     */
    public static int select(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class accessx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("accessx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static FunctionDescriptor accessx_np$descriptor() {
        return accessx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static MethodHandle accessx_np$handle() {
        return accessx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static MemorySegment accessx_np$address() {
        return accessx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t)
     * }
     */
    public static int accessx_np(MemorySegment x0, long x1, MemorySegment x2, int x3) {
        var mh$ = accessx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accessx_np", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acct {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("acct");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static FunctionDescriptor acct$descriptor() {
        return acct.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static MethodHandle acct$handle() {
        return acct.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static MemorySegment acct$address() {
        return acct.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int acct(const char *)
     * }
     */
    public static int acct(MemorySegment x0) {
        var mh$ = acct.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acct", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class add_profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("add_profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static FunctionDescriptor add_profil$descriptor() {
        return add_profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MethodHandle add_profil$handle() {
        return add_profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MemorySegment add_profil$address() {
        return add_profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int add_profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static int add_profil(MemorySegment x0, long x1, long x2, int x3) {
        var mh$ = add_profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("add_profil", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class endusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("endusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static FunctionDescriptor endusershell$descriptor() {
        return endusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static MethodHandle endusershell$handle() {
        return endusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static MemorySegment endusershell$address() {
        return endusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void endusershell()
     * }
     */
    public static void endusershell() {
        var mh$ = endusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("endusershell");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execvP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("execvP");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execvP$descriptor() {
        return execvP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static MethodHandle execvP$handle() {
        return execvP.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static MemorySegment execvP$address() {
        return execvP.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execvP(const char *__file, const char *__searchpath, char *const *__argv)
     * }
     */
    public static int execvP(MemorySegment __file, MemorySegment __searchpath, MemorySegment __argv) {
        var mh$ = execvP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execvP", __file, __searchpath, __argv);
            }
            return (int)mh$.invokeExact(__file, __searchpath, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflagstostr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fflagstostr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static FunctionDescriptor fflagstostr$descriptor() {
        return fflagstostr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MethodHandle fflagstostr$handle() {
        return fflagstostr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MemorySegment fflagstostr$address() {
        return fflagstostr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fflagstostr(unsigned long)
     * }
     */
    public static MemorySegment fflagstostr(long x0) {
        var mh$ = fflagstostr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflagstostr", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static FunctionDescriptor getdomainname$descriptor() {
        return getdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static MethodHandle getdomainname$handle() {
        return getdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static MemorySegment getdomainname$address() {
        return getdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdomainname(char *, int)
     * }
     */
    public static int getdomainname(MemorySegment x0, int x1) {
        var mh$ = getdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdomainname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getgrouplist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getgrouplist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static FunctionDescriptor getgrouplist$descriptor() {
        return getgrouplist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static MethodHandle getgrouplist$handle() {
        return getgrouplist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static MemorySegment getgrouplist$address() {
        return getgrouplist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getgrouplist(const char *, int, int *, int *)
     * }
     */
    public static int getgrouplist(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = getgrouplist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getgrouplist", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostuuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("gethostuuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static FunctionDescriptor gethostuuid$descriptor() {
        return gethostuuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static MethodHandle gethostuuid$handle() {
        return gethostuuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static MemorySegment gethostuuid$address() {
        return gethostuuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int gethostuuid(uuid_t, const struct timespec *)
     * }
     */
    public static int gethostuuid(MemorySegment x0, MemorySegment x1) {
        var mh$ = gethostuuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostuuid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_SHORT,
            archive_h.C_POINTER,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static FunctionDescriptor getmode$descriptor() {
        return getmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static MethodHandle getmode$handle() {
        return getmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static MemorySegment getmode$address() {
        return getmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t getmode(const void *, mode_t)
     * }
     */
    public static short getmode(MemorySegment x0, short x1) {
        var mh$ = getmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getmode", x0, x1);
            }
            return (short)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeereid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getpeereid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static FunctionDescriptor getpeereid$descriptor() {
        return getpeereid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static MethodHandle getpeereid$handle() {
        return getpeereid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static MemorySegment getpeereid$address() {
        return getpeereid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpeereid(int, uid_t *, gid_t *)
     * }
     */
    public static int getpeereid(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getpeereid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeereid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getsgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static FunctionDescriptor getsgroups_np$descriptor() {
        return getsgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static MethodHandle getsgroups_np$handle() {
        return getsgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static MemorySegment getsgroups_np$address() {
        return getsgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsgroups_np(int *, uuid_t)
     * }
     */
    public static int getsgroups_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = getsgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static FunctionDescriptor getusershell$descriptor() {
        return getusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MethodHandle getusershell$handle() {
        return getusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MemorySegment getusershell$address() {
        return getusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getusershell()
     * }
     */
    public static MemorySegment getusershell() {
        var mh$ = getusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getusershell");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getwgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getwgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static FunctionDescriptor getwgroups_np$descriptor() {
        return getwgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static MethodHandle getwgroups_np$handle() {
        return getwgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static MemorySegment getwgroups_np$address() {
        return getwgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getwgroups_np(int *, uuid_t)
     * }
     */
    public static int getwgroups_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = getwgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getwgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("initgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static FunctionDescriptor initgroups$descriptor() {
        return initgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static MethodHandle initgroups$handle() {
        return initgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static MemorySegment initgroups$address() {
        return initgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int initgroups(const char *, int)
     * }
     */
    public static int initgroups(MemorySegment x0, int x1) {
        var mh$ = initgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class issetugid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("issetugid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static FunctionDescriptor issetugid$descriptor() {
        return issetugid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static MethodHandle issetugid$handle() {
        return issetugid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static MemorySegment issetugid$address() {
        return issetugid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int issetugid()
     * }
     */
    public static int issetugid() {
        var mh$ = issetugid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("issetugid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mkdtemp(char *)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment x0) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkpath_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkpath_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static FunctionDescriptor mkpath_np$descriptor() {
        return mkpath_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static MethodHandle mkpath_np$handle() {
        return mkpath_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static MemorySegment mkpath_np$address() {
        return mkpath_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkpath_np(const char *path, mode_t omode)
     * }
     */
    public static int mkpath_np(MemorySegment path, short omode) {
        var mh$ = mkpath_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkpath_np", path, omode);
            }
            return (int)mh$.invokeExact(path, omode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkpathat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkpathat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static FunctionDescriptor mkpathat_np$descriptor() {
        return mkpathat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static MethodHandle mkpathat_np$handle() {
        return mkpathat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static MemorySegment mkpathat_np$address() {
        return mkpathat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkpathat_np(int dfd, const char *path, mode_t omode)
     * }
     */
    public static int mkpathat_np(int dfd, MemorySegment path, short omode) {
        var mh$ = mkpathat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkpathat_np", dfd, path, omode);
            }
            return (int)mh$.invokeExact(dfd, path, omode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemps(char *, int)
     * }
     */
    public static int mkstemps(MemorySegment x0, int x1) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkostemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static FunctionDescriptor mkostemp$descriptor() {
        return mkostemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static MethodHandle mkostemp$handle() {
        return mkostemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static MemorySegment mkostemp$address() {
        return mkostemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostemp(char *path, int oflags)
     * }
     */
    public static int mkostemp(MemorySegment path, int oflags) {
        var mh$ = mkostemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostemp", path, oflags);
            }
            return (int)mh$.invokeExact(path, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkostemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static FunctionDescriptor mkostemps$descriptor() {
        return mkostemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static MethodHandle mkostemps$handle() {
        return mkostemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static MemorySegment mkostemps$address() {
        return mkostemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostemps(char *path, int slen, int oflags)
     * }
     */
    public static int mkostemps(MemorySegment path, int slen, int oflags) {
        var mh$ = mkostemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostemps", path, slen, oflags);
            }
            return (int)mh$.invokeExact(path, slen, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp_dprotected_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkstemp_dprotected_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static FunctionDescriptor mkstemp_dprotected_np$descriptor() {
        return mkstemp_dprotected_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static MethodHandle mkstemp_dprotected_np$handle() {
        return mkstemp_dprotected_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static MemorySegment mkstemp_dprotected_np$address() {
        return mkstemp_dprotected_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
     * }
     */
    public static int mkstemp_dprotected_np(MemorySegment path, int dpclass, int dpflags) {
        var mh$ = mkstemp_dprotected_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp_dprotected_np", path, dpclass, dpflags);
            }
            return (int)mh$.invokeExact(path, dpclass, dpflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtempat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkdtempat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static FunctionDescriptor mkdtempat_np$descriptor() {
        return mkdtempat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MethodHandle mkdtempat_np$handle() {
        return mkdtempat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MemorySegment mkdtempat_np$address() {
        return mkdtempat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mkdtempat_np(int dfd, char *path)
     * }
     */
    public static MemorySegment mkdtempat_np(int dfd, MemorySegment path) {
        var mh$ = mkdtempat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtempat_np", dfd, path);
            }
            return (MemorySegment)mh$.invokeExact(dfd, path);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstempsat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkstempsat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static FunctionDescriptor mkstempsat_np$descriptor() {
        return mkstempsat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static MethodHandle mkstempsat_np$handle() {
        return mkstempsat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static MemorySegment mkstempsat_np$address() {
        return mkstempsat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstempsat_np(int dfd, char *path, int slen)
     * }
     */
    public static int mkstempsat_np(int dfd, MemorySegment path, int slen) {
        var mh$ = mkstempsat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstempsat_np", dfd, path, slen);
            }
            return (int)mh$.invokeExact(dfd, path, slen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkostempsat_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkostempsat_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static FunctionDescriptor mkostempsat_np$descriptor() {
        return mkostempsat_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static MethodHandle mkostempsat_np$handle() {
        return mkostempsat_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static MemorySegment mkostempsat_np$address() {
        return mkostempsat_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkostempsat_np(int dfd, char *path, int slen, int oflags)
     * }
     */
    public static int mkostempsat_np(int dfd, MemorySegment path, int slen, int oflags) {
        var mh$ = mkostempsat_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkostempsat_np", dfd, path, slen, oflags);
            }
            return (int)mh$.invokeExact(dfd, path, slen, oflags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nfssvc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("nfssvc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static FunctionDescriptor nfssvc$descriptor() {
        return nfssvc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static MethodHandle nfssvc$handle() {
        return nfssvc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static MemorySegment nfssvc$address() {
        return nfssvc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nfssvc(int, void *)
     * }
     */
    public static int nfssvc(int x0, MemorySegment x1) {
        var mh$ = nfssvc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nfssvc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class profil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("profil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static FunctionDescriptor profil$descriptor() {
        return profil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MethodHandle profil$handle() {
        return profil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static MemorySegment profil$address() {
        return profil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int profil(char *, size_t, unsigned long, unsigned int)
     * }
     */
    public static int profil(MemorySegment x0, long x1, long x2, int x3) {
        var mh$ = profil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("profil", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_setugid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("pthread_setugid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor pthread_setugid_np$descriptor() {
        return pthread_setugid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static MethodHandle pthread_setugid_np$handle() {
        return pthread_setugid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static MemorySegment pthread_setugid_np$address() {
        return pthread_setugid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_setugid_np(uid_t, gid_t)
     * }
     */
    public static int pthread_setugid_np(int x0, int x1) {
        var mh$ = pthread_setugid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_setugid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pthread_getugid_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("pthread_getugid_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static FunctionDescriptor pthread_getugid_np$descriptor() {
        return pthread_getugid_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static MethodHandle pthread_getugid_np$handle() {
        return pthread_getugid_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static MemorySegment pthread_getugid_np$address() {
        return pthread_getugid_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pthread_getugid_np(uid_t *, gid_t *)
     * }
     */
    public static int pthread_getugid_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = pthread_getugid_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pthread_getugid_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reboot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("reboot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static FunctionDescriptor reboot$descriptor() {
        return reboot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static MethodHandle reboot$handle() {
        return reboot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static MemorySegment reboot$address() {
        return reboot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int reboot(int)
     * }
     */
    public static int reboot(int x0) {
        var mh$ = reboot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reboot", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class revoke {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("revoke");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static FunctionDescriptor revoke$descriptor() {
        return revoke.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static MethodHandle revoke$handle() {
        return revoke.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static MemorySegment revoke$address() {
        return revoke.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int revoke(const char *)
     * }
     */
    public static int revoke(MemorySegment x0) {
        var mh$ = revoke.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("revoke", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("rcmd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static FunctionDescriptor rcmd$descriptor() {
        return rcmd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static MethodHandle rcmd$handle() {
        return rcmd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static MemorySegment rcmd$address() {
        return rcmd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rcmd(char **, int, const char *, const char *, const char *, int *)
     * }
     */
    public static int rcmd(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = rcmd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rcmd_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("rcmd_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static FunctionDescriptor rcmd_af$descriptor() {
        return rcmd_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static MethodHandle rcmd_af$handle() {
        return rcmd_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static MemorySegment rcmd_af$address() {
        return rcmd_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rcmd_af(char **, int, const char *, const char *, const char *, int *, int)
     * }
     */
    public static int rcmd_af(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, int x6) {
        var mh$ = rcmd_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rcmd_af", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("rresvport");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static FunctionDescriptor rresvport$descriptor() {
        return rresvport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static MethodHandle rresvport$handle() {
        return rresvport.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static MemorySegment rresvport$address() {
        return rresvport.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rresvport(int *)
     * }
     */
    public static int rresvport(MemorySegment x0) {
        var mh$ = rresvport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rresvport_af {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("rresvport_af");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static FunctionDescriptor rresvport_af$descriptor() {
        return rresvport_af.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static MethodHandle rresvport_af$handle() {
        return rresvport_af.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static MemorySegment rresvport_af$address() {
        return rresvport_af.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rresvport_af(int *, int)
     * }
     */
    public static int rresvport_af(MemorySegment x0, int x1) {
        var mh$ = rresvport_af.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rresvport_af", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_LONG,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("iruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor iruserok$descriptor() {
        return iruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static MethodHandle iruserok$handle() {
        return iruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static MemorySegment iruserok$address() {
        return iruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iruserok(unsigned long, int, const char *, const char *)
     * }
     */
    public static int iruserok(long x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = iruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class iruserok_sa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("iruserok_sa");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor iruserok_sa$descriptor() {
        return iruserok_sa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static MethodHandle iruserok_sa$handle() {
        return iruserok_sa.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static MemorySegment iruserok_sa$address() {
        return iruserok_sa.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int iruserok_sa(const void *, int, int, const char *, const char *)
     * }
     */
    public static int iruserok_sa(MemorySegment x0, int x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = iruserok_sa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("iruserok_sa", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ruserok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ruserok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static FunctionDescriptor ruserok$descriptor() {
        return ruserok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static MethodHandle ruserok$handle() {
        return ruserok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static MemorySegment ruserok$address() {
        return ruserok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ruserok(const char *, int, const char *, const char *)
     * }
     */
    public static int ruserok(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ruserok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ruserok", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setdomainname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setdomainname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static FunctionDescriptor setdomainname$descriptor() {
        return setdomainname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static MethodHandle setdomainname$handle() {
        return setdomainname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static MemorySegment setdomainname$address() {
        return setdomainname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setdomainname(const char *, int)
     * }
     */
    public static int setdomainname(MemorySegment x0, int x1) {
        var mh$ = setdomainname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setdomainname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setgroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setgroups");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static FunctionDescriptor setgroups$descriptor() {
        return setgroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static MethodHandle setgroups$handle() {
        return setgroups.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static MemorySegment setgroups$address() {
        return setgroups.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setgroups(int, const gid_t *)
     * }
     */
    public static int setgroups(int x0, MemorySegment x1) {
        var mh$ = setgroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setgroups", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("sethostid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static FunctionDescriptor sethostid$descriptor() {
        return sethostid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static MethodHandle sethostid$handle() {
        return sethostid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static MemorySegment sethostid$address() {
        return sethostid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sethostid(long)
     * }
     */
    public static void sethostid(long x0) {
        var mh$ = sethostid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostid", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("sethostname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static FunctionDescriptor sethostname$descriptor() {
        return sethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static MethodHandle sethostname$handle() {
        return sethostname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static MemorySegment sethostname$address() {
        return sethostname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sethostname(const char *, int)
     * }
     */
    public static int sethostname(MemorySegment x0, int x1) {
        var mh$ = sethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sethostname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlogin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setlogin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static FunctionDescriptor setlogin$descriptor() {
        return setlogin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static MethodHandle setlogin$handle() {
        return setlogin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static MemorySegment setlogin$address() {
        return setlogin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlogin(const char *)
     * }
     */
    public static int setlogin(MemorySegment x0) {
        var mh$ = setlogin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlogin", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static FunctionDescriptor setmode$descriptor() {
        return setmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MethodHandle setmode$handle() {
        return setmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MemorySegment setmode$address() {
        return setmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *setmode(const char *)
     * }
     */
    public static MemorySegment setmode(MemorySegment x0) {
        var mh$ = setmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setmode", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrgid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setrgid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static FunctionDescriptor setrgid$descriptor() {
        return setrgid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static MethodHandle setrgid$handle() {
        return setrgid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static MemorySegment setrgid$address() {
        return setrgid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrgid(gid_t)
     * }
     */
    public static int setrgid(int x0) {
        var mh$ = setrgid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrgid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setruid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setruid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static FunctionDescriptor setruid$descriptor() {
        return setruid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static MethodHandle setruid$handle() {
        return setruid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static MemorySegment setruid$address() {
        return setruid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setruid(uid_t)
     * }
     */
    public static int setruid(int x0) {
        var mh$ = setruid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setruid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setsgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static FunctionDescriptor setsgroups_np$descriptor() {
        return setsgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static MethodHandle setsgroups_np$handle() {
        return setsgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static MemorySegment setsgroups_np$address() {
        return setsgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setsgroups_np(int, const uuid_t)
     * }
     */
    public static int setsgroups_np(int x0, MemorySegment x1) {
        var mh$ = setsgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setusershell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setusershell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static FunctionDescriptor setusershell$descriptor() {
        return setusershell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static MethodHandle setusershell$handle() {
        return setusershell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static MemorySegment setusershell$address() {
        return setusershell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setusershell()
     * }
     */
    public static void setusershell() {
        var mh$ = setusershell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setusershell");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setwgroups_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setwgroups_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static FunctionDescriptor setwgroups_np$descriptor() {
        return setwgroups_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static MethodHandle setwgroups_np$handle() {
        return setwgroups_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static MemorySegment setwgroups_np$address() {
        return setwgroups_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setwgroups_np(int, const uuid_t)
     * }
     */
    public static int setwgroups_np(int x0, MemorySegment x1) {
        var mh$ = setwgroups_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setwgroups_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtofflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("strtofflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static FunctionDescriptor strtofflags$descriptor() {
        return strtofflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static MethodHandle strtofflags$handle() {
        return strtofflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static MemorySegment strtofflags$address() {
        return strtofflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strtofflags(char **, unsigned long *, unsigned long *)
     * }
     */
    public static int strtofflags(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = strtofflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtofflags", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swapon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("swapon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static FunctionDescriptor swapon$descriptor() {
        return swapon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static MethodHandle swapon$handle() {
        return swapon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static MemorySegment swapon$address() {
        return swapon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int swapon(const char *)
     * }
     */
    public static int swapon(MemorySegment x0) {
        var mh$ = swapon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swapon", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ttyslot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ttyslot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static FunctionDescriptor ttyslot$descriptor() {
        return ttyslot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static MethodHandle ttyslot$handle() {
        return ttyslot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static MemorySegment ttyslot$address() {
        return ttyslot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ttyslot()
     * }
     */
    public static int ttyslot() {
        var mh$ = ttyslot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ttyslot");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class undelete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("undelete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static FunctionDescriptor undelete$descriptor() {
        return undelete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static MethodHandle undelete$handle() {
        return undelete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static MemorySegment undelete$address() {
        return undelete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int undelete(const char *)
     * }
     */
    public static int undelete(MemorySegment x0) {
        var mh$ = undelete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("undelete", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unwhiteout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("unwhiteout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static FunctionDescriptor unwhiteout$descriptor() {
        return unwhiteout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static MethodHandle unwhiteout$handle() {
        return unwhiteout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static MemorySegment unwhiteout$address() {
        return unwhiteout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unwhiteout(const char *)
     * }
     */
    public static int unwhiteout(MemorySegment x0) {
        var mh$ = unwhiteout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unwhiteout", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t)
     * }
     */
    public static MemorySegment valloc(long x0) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int syscall(int, ...)
     * }
     */
    public static class syscall {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_INT
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("syscall");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private syscall(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int syscall(int, ...)
         * }
         */
        public static syscall makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new syscall(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("syscall", x0, x1);
                }
                return (int)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = archive_h.C_POINTER;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fgetattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor fgetattrlist$descriptor() {
        return fgetattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle fgetattrlist$handle() {
        return fgetattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment fgetattrlist$address() {
        return fgetattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static int fgetattrlist(int x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = fgetattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fsetattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor fsetattrlist$descriptor() {
        return fsetattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle fsetattrlist$handle() {
        return fsetattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment fsetattrlist$address() {
        return fsetattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetattrlist(int, void *, void *, size_t, unsigned int)
     * }
     */
    public static int fsetattrlist(int x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = fsetattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor getattrlist$descriptor() {
        return getattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle getattrlist$handle() {
        return getattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment getattrlist$address() {
        return getattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static int getattrlist(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = getattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setattrlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setattrlist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor setattrlist$descriptor() {
        return setattrlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MethodHandle setattrlist$handle() {
        return setattrlist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static MemorySegment setattrlist$address() {
        return setattrlist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setattrlist(const char *, void *, void *, size_t, unsigned int)
     * }
     */
    public static int setattrlist(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, int x4) {
        var mh$ = setattrlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setattrlist", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exchangedata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("exchangedata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor exchangedata$descriptor() {
        return exchangedata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static MethodHandle exchangedata$handle() {
        return exchangedata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment exchangedata$address() {
        return exchangedata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int exchangedata(const char *, const char *, unsigned int)
     * }
     */
    public static int exchangedata(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = exchangedata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exchangedata", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdirentriesattr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getdirentriesattr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static FunctionDescriptor getdirentriesattr$descriptor() {
        return getdirentriesattr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static MethodHandle getdirentriesattr$handle() {
        return getdirentriesattr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static MemorySegment getdirentriesattr$address() {
        return getdirentriesattr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getdirentriesattr(int, void *, void *, size_t, unsigned int *, unsigned int *, unsigned int *, unsigned int)
     * }
     */
    public static int getdirentriesattr(int x0, MemorySegment x1, MemorySegment x2, long x3, MemorySegment x4, MemorySegment x5, MemorySegment x6, int x7) {
        var mh$ = getdirentriesattr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdirentriesattr", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class searchfs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("searchfs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static FunctionDescriptor searchfs$descriptor() {
        return searchfs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static MethodHandle searchfs$handle() {
        return searchfs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static MemorySegment searchfs$address() {
        return searchfs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *)
     * }
     */
    public static int searchfs(MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5) {
        var mh$ = searchfs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("searchfs", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fsctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor fsctl$descriptor() {
        return fsctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static MethodHandle fsctl$handle() {
        return fsctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static MemorySegment fsctl$address() {
        return fsctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsctl(const char *, unsigned long, void *, unsigned int)
     * }
     */
    public static int fsctl(MemorySegment x0, long x1, MemorySegment x2, int x3) {
        var mh$ = fsctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsctl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ffsctl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor ffsctl$descriptor() {
        return ffsctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static MethodHandle ffsctl$handle() {
        return ffsctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static MemorySegment ffsctl$address() {
        return ffsctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsctl(int, unsigned long, void *, unsigned int)
     * }
     */
    public static int ffsctl(int x0, long x1, MemorySegment x2, int x3) {
        var mh$ = ffsctl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsctl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsync_volume_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fsync_volume_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static FunctionDescriptor fsync_volume_np$descriptor() {
        return fsync_volume_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static MethodHandle fsync_volume_np$handle() {
        return fsync_volume_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static MemorySegment fsync_volume_np$address() {
        return fsync_volume_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsync_volume_np(int, int)
     * }
     */
    public static int fsync_volume_np(int x0, int x1) {
        var mh$ = fsync_volume_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsync_volume_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sync_volume_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("sync_volume_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static FunctionDescriptor sync_volume_np$descriptor() {
        return sync_volume_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static MethodHandle sync_volume_np$handle() {
        return sync_volume_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static MemorySegment sync_volume_np$address() {
        return sync_volume_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sync_volume_np(const char *, int)
     * }
     */
    public static int sync_volume_np(MemorySegment x0, int x1) {
        var mh$ = sync_volume_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sync_volume_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class optreset$constants {
        public static final OfInt LAYOUT = archive_h.C_INT;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("optreset").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static OfInt optreset$layout() {
        return optreset$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static MemorySegment optreset$segment() {
        return optreset$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static int optreset() {
        return optreset$constants.SEGMENT.get(optreset$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int optreset
     * }
     */
    public static void optreset(int varValue) {
        optreset$constants.SEGMENT.set(optreset$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef int64_t la_int64_t
     * }
     */
    public static final OfLong la_int64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ssize_t la_ssize_t
     * }
     */
    public static final OfLong la_ssize_t = archive_h.C_LONG;

    private static class archive_version_number {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_version_number");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_version_number()
     * }
     */
    public static FunctionDescriptor archive_version_number$descriptor() {
        return archive_version_number.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_version_number()
     * }
     */
    public static MethodHandle archive_version_number$handle() {
        return archive_version_number.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_version_number()
     * }
     */
    public static MemorySegment archive_version_number$address() {
        return archive_version_number.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_version_number()
     * }
     */
    public static int archive_version_number() {
        var mh$ = archive_version_number.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_version_number");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_version_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_version_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_version_string()
     * }
     */
    public static FunctionDescriptor archive_version_string$descriptor() {
        return archive_version_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_version_string()
     * }
     */
    public static MethodHandle archive_version_string$handle() {
        return archive_version_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_version_string()
     * }
     */
    public static MemorySegment archive_version_string$address() {
        return archive_version_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_version_string()
     * }
     */
    public static MemorySegment archive_version_string() {
        var mh$ = archive_version_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_version_string");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_version_details {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_version_details");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_version_details()
     * }
     */
    public static FunctionDescriptor archive_version_details$descriptor() {
        return archive_version_details.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_version_details()
     * }
     */
    public static MethodHandle archive_version_details$handle() {
        return archive_version_details.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_version_details()
     * }
     */
    public static MemorySegment archive_version_details$address() {
        return archive_version_details.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_version_details()
     * }
     */
    public static MemorySegment archive_version_details() {
        var mh$ = archive_version_details.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_version_details");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_zlib_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_zlib_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_zlib_version()
     * }
     */
    public static FunctionDescriptor archive_zlib_version$descriptor() {
        return archive_zlib_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_zlib_version()
     * }
     */
    public static MethodHandle archive_zlib_version$handle() {
        return archive_zlib_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_zlib_version()
     * }
     */
    public static MemorySegment archive_zlib_version$address() {
        return archive_zlib_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_zlib_version()
     * }
     */
    public static MemorySegment archive_zlib_version() {
        var mh$ = archive_zlib_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_zlib_version");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_liblzma_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_liblzma_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_liblzma_version()
     * }
     */
    public static FunctionDescriptor archive_liblzma_version$descriptor() {
        return archive_liblzma_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_liblzma_version()
     * }
     */
    public static MethodHandle archive_liblzma_version$handle() {
        return archive_liblzma_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_liblzma_version()
     * }
     */
    public static MemorySegment archive_liblzma_version$address() {
        return archive_liblzma_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_liblzma_version()
     * }
     */
    public static MemorySegment archive_liblzma_version() {
        var mh$ = archive_liblzma_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_liblzma_version");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_bzlib_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_bzlib_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_bzlib_version()
     * }
     */
    public static FunctionDescriptor archive_bzlib_version$descriptor() {
        return archive_bzlib_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_bzlib_version()
     * }
     */
    public static MethodHandle archive_bzlib_version$handle() {
        return archive_bzlib_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_bzlib_version()
     * }
     */
    public static MemorySegment archive_bzlib_version$address() {
        return archive_bzlib_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_bzlib_version()
     * }
     */
    public static MemorySegment archive_bzlib_version() {
        var mh$ = archive_bzlib_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_bzlib_version");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_liblz4_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_liblz4_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_liblz4_version()
     * }
     */
    public static FunctionDescriptor archive_liblz4_version$descriptor() {
        return archive_liblz4_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_liblz4_version()
     * }
     */
    public static MethodHandle archive_liblz4_version$handle() {
        return archive_liblz4_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_liblz4_version()
     * }
     */
    public static MemorySegment archive_liblz4_version$address() {
        return archive_liblz4_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_liblz4_version()
     * }
     */
    public static MemorySegment archive_liblz4_version() {
        var mh$ = archive_liblz4_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_liblz4_version");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_libzstd_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_libzstd_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_libzstd_version()
     * }
     */
    public static FunctionDescriptor archive_libzstd_version$descriptor() {
        return archive_libzstd_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_libzstd_version()
     * }
     */
    public static MethodHandle archive_libzstd_version$handle() {
        return archive_libzstd_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_libzstd_version()
     * }
     */
    public static MemorySegment archive_libzstd_version$address() {
        return archive_libzstd_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_libzstd_version()
     * }
     */
    public static MemorySegment archive_libzstd_version() {
        var mh$ = archive_libzstd_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_libzstd_version");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive *archive_read_new()
     * }
     */
    public static FunctionDescriptor archive_read_new$descriptor() {
        return archive_read_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive *archive_read_new()
     * }
     */
    public static MethodHandle archive_read_new$handle() {
        return archive_read_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive *archive_read_new()
     * }
     */
    public static MemorySegment archive_read_new$address() {
        return archive_read_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive *archive_read_new()
     * }
     */
    public static MemorySegment archive_read_new() {
        var mh$ = archive_read_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_all(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_all$descriptor() {
        return archive_read_support_compression_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_all(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_compression_all$handle() {
        return archive_read_support_compression_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_all(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_compression_all$address() {
        return archive_read_support_compression_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_all(struct archive *)
     * }
     */
    public static int archive_read_support_compression_all(MemorySegment x0) {
        var mh$ = archive_read_support_compression_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_all", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_bzip2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_bzip2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_bzip2(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_bzip2$descriptor() {
        return archive_read_support_compression_bzip2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_bzip2(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_compression_bzip2$handle() {
        return archive_read_support_compression_bzip2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_bzip2(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_compression_bzip2$address() {
        return archive_read_support_compression_bzip2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_bzip2(struct archive *)
     * }
     */
    public static int archive_read_support_compression_bzip2(MemorySegment x0) {
        var mh$ = archive_read_support_compression_bzip2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_bzip2", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_compress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_compress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_compress(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_compress$descriptor() {
        return archive_read_support_compression_compress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_compress(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_compression_compress$handle() {
        return archive_read_support_compression_compress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_compress(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_compression_compress$address() {
        return archive_read_support_compression_compress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_compress(struct archive *)
     * }
     */
    public static int archive_read_support_compression_compress(MemorySegment x0) {
        var mh$ = archive_read_support_compression_compress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_compress", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_gzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_gzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_gzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_gzip$descriptor() {
        return archive_read_support_compression_gzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_gzip(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_compression_gzip$handle() {
        return archive_read_support_compression_gzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_gzip(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_compression_gzip$address() {
        return archive_read_support_compression_gzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_gzip(struct archive *)
     * }
     */
    public static int archive_read_support_compression_gzip(MemorySegment x0) {
        var mh$ = archive_read_support_compression_gzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_gzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_lzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_lzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_lzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_lzip$descriptor() {
        return archive_read_support_compression_lzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_lzip(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_compression_lzip$handle() {
        return archive_read_support_compression_lzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_lzip(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_compression_lzip$address() {
        return archive_read_support_compression_lzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_lzip(struct archive *)
     * }
     */
    public static int archive_read_support_compression_lzip(MemorySegment x0) {
        var mh$ = archive_read_support_compression_lzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_lzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_lzma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_lzma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_lzma(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_lzma$descriptor() {
        return archive_read_support_compression_lzma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_lzma(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_compression_lzma$handle() {
        return archive_read_support_compression_lzma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_lzma(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_compression_lzma$address() {
        return archive_read_support_compression_lzma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_lzma(struct archive *)
     * }
     */
    public static int archive_read_support_compression_lzma(MemorySegment x0) {
        var mh$ = archive_read_support_compression_lzma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_lzma", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_none {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_none");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_none(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_none$descriptor() {
        return archive_read_support_compression_none.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_none(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_compression_none$handle() {
        return archive_read_support_compression_none.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_none(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_compression_none$address() {
        return archive_read_support_compression_none.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_none(struct archive *)
     * }
     */
    public static int archive_read_support_compression_none(MemorySegment x0) {
        var mh$ = archive_read_support_compression_none.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_none", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_program {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_program");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_program(struct archive *, const char *command)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_program$descriptor() {
        return archive_read_support_compression_program.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_program(struct archive *, const char *command)
     * }
     */
    public static MethodHandle archive_read_support_compression_program$handle() {
        return archive_read_support_compression_program.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_program(struct archive *, const char *command)
     * }
     */
    public static MemorySegment archive_read_support_compression_program$address() {
        return archive_read_support_compression_program.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_program(struct archive *, const char *command)
     * }
     */
    public static int archive_read_support_compression_program(MemorySegment x0, MemorySegment command) {
        var mh$ = archive_read_support_compression_program.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_program", x0, command);
            }
            return (int)mh$.invokeExact(x0, command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_program_signature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_program_signature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_program_signature$descriptor() {
        return archive_read_support_compression_program_signature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle archive_read_support_compression_program_signature$handle() {
        return archive_read_support_compression_program_signature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment archive_read_support_compression_program_signature$address() {
        return archive_read_support_compression_program_signature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static int archive_read_support_compression_program_signature(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = archive_read_support_compression_program_signature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_program_signature", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_rpm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_rpm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_rpm(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_rpm$descriptor() {
        return archive_read_support_compression_rpm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_rpm(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_compression_rpm$handle() {
        return archive_read_support_compression_rpm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_rpm(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_compression_rpm$address() {
        return archive_read_support_compression_rpm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_rpm(struct archive *)
     * }
     */
    public static int archive_read_support_compression_rpm(MemorySegment x0) {
        var mh$ = archive_read_support_compression_rpm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_rpm", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_uu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_uu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_uu(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_uu$descriptor() {
        return archive_read_support_compression_uu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_uu(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_compression_uu$handle() {
        return archive_read_support_compression_uu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_uu(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_compression_uu$address() {
        return archive_read_support_compression_uu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_uu(struct archive *)
     * }
     */
    public static int archive_read_support_compression_uu(MemorySegment x0) {
        var mh$ = archive_read_support_compression_uu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_uu", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_compression_xz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_compression_xz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_compression_xz(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_compression_xz$descriptor() {
        return archive_read_support_compression_xz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_compression_xz(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_compression_xz$handle() {
        return archive_read_support_compression_xz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_compression_xz(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_compression_xz$address() {
        return archive_read_support_compression_xz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_compression_xz(struct archive *)
     * }
     */
    public static int archive_read_support_compression_xz(MemorySegment x0) {
        var mh$ = archive_read_support_compression_xz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_compression_xz", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_all(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_all$descriptor() {
        return archive_read_support_filter_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_all(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_all$handle() {
        return archive_read_support_filter_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_all(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_all$address() {
        return archive_read_support_filter_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_all(struct archive *)
     * }
     */
    public static int archive_read_support_filter_all(MemorySegment x0) {
        var mh$ = archive_read_support_filter_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_all", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_by_code {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_by_code");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_by_code(struct archive *, int)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_by_code$descriptor() {
        return archive_read_support_filter_by_code.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_by_code(struct archive *, int)
     * }
     */
    public static MethodHandle archive_read_support_filter_by_code$handle() {
        return archive_read_support_filter_by_code.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_by_code(struct archive *, int)
     * }
     */
    public static MemorySegment archive_read_support_filter_by_code$address() {
        return archive_read_support_filter_by_code.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_by_code(struct archive *, int)
     * }
     */
    public static int archive_read_support_filter_by_code(MemorySegment x0, int x1) {
        var mh$ = archive_read_support_filter_by_code.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_by_code", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_bzip2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_bzip2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_bzip2(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_bzip2$descriptor() {
        return archive_read_support_filter_bzip2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_bzip2(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_bzip2$handle() {
        return archive_read_support_filter_bzip2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_bzip2(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_bzip2$address() {
        return archive_read_support_filter_bzip2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_bzip2(struct archive *)
     * }
     */
    public static int archive_read_support_filter_bzip2(MemorySegment x0) {
        var mh$ = archive_read_support_filter_bzip2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_bzip2", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_compress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_compress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_compress(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_compress$descriptor() {
        return archive_read_support_filter_compress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_compress(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_compress$handle() {
        return archive_read_support_filter_compress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_compress(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_compress$address() {
        return archive_read_support_filter_compress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_compress(struct archive *)
     * }
     */
    public static int archive_read_support_filter_compress(MemorySegment x0) {
        var mh$ = archive_read_support_filter_compress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_compress", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_gzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_gzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_gzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_gzip$descriptor() {
        return archive_read_support_filter_gzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_gzip(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_gzip$handle() {
        return archive_read_support_filter_gzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_gzip(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_gzip$address() {
        return archive_read_support_filter_gzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_gzip(struct archive *)
     * }
     */
    public static int archive_read_support_filter_gzip(MemorySegment x0) {
        var mh$ = archive_read_support_filter_gzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_gzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_grzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_grzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_grzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_grzip$descriptor() {
        return archive_read_support_filter_grzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_grzip(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_grzip$handle() {
        return archive_read_support_filter_grzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_grzip(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_grzip$address() {
        return archive_read_support_filter_grzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_grzip(struct archive *)
     * }
     */
    public static int archive_read_support_filter_grzip(MemorySegment x0) {
        var mh$ = archive_read_support_filter_grzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_grzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_lrzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_lrzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lrzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_lrzip$descriptor() {
        return archive_read_support_filter_lrzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lrzip(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_lrzip$handle() {
        return archive_read_support_filter_lrzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lrzip(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_lrzip$address() {
        return archive_read_support_filter_lrzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_lrzip(struct archive *)
     * }
     */
    public static int archive_read_support_filter_lrzip(MemorySegment x0) {
        var mh$ = archive_read_support_filter_lrzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_lrzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_lz4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_lz4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lz4(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_lz4$descriptor() {
        return archive_read_support_filter_lz4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lz4(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_lz4$handle() {
        return archive_read_support_filter_lz4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lz4(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_lz4$address() {
        return archive_read_support_filter_lz4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_lz4(struct archive *)
     * }
     */
    public static int archive_read_support_filter_lz4(MemorySegment x0) {
        var mh$ = archive_read_support_filter_lz4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_lz4", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_lzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_lzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_lzip$descriptor() {
        return archive_read_support_filter_lzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lzip(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_lzip$handle() {
        return archive_read_support_filter_lzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lzip(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_lzip$address() {
        return archive_read_support_filter_lzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_lzip(struct archive *)
     * }
     */
    public static int archive_read_support_filter_lzip(MemorySegment x0) {
        var mh$ = archive_read_support_filter_lzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_lzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_lzma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_lzma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lzma(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_lzma$descriptor() {
        return archive_read_support_filter_lzma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lzma(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_lzma$handle() {
        return archive_read_support_filter_lzma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lzma(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_lzma$address() {
        return archive_read_support_filter_lzma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_lzma(struct archive *)
     * }
     */
    public static int archive_read_support_filter_lzma(MemorySegment x0) {
        var mh$ = archive_read_support_filter_lzma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_lzma", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_lzop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_lzop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lzop(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_lzop$descriptor() {
        return archive_read_support_filter_lzop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lzop(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_lzop$handle() {
        return archive_read_support_filter_lzop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_lzop(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_lzop$address() {
        return archive_read_support_filter_lzop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_lzop(struct archive *)
     * }
     */
    public static int archive_read_support_filter_lzop(MemorySegment x0) {
        var mh$ = archive_read_support_filter_lzop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_lzop", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_none {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_none");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_none(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_none$descriptor() {
        return archive_read_support_filter_none.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_none(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_none$handle() {
        return archive_read_support_filter_none.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_none(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_none$address() {
        return archive_read_support_filter_none.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_none(struct archive *)
     * }
     */
    public static int archive_read_support_filter_none(MemorySegment x0) {
        var mh$ = archive_read_support_filter_none.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_none", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_program {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_program");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_program(struct archive *, const char *command)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_program$descriptor() {
        return archive_read_support_filter_program.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_program(struct archive *, const char *command)
     * }
     */
    public static MethodHandle archive_read_support_filter_program$handle() {
        return archive_read_support_filter_program.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_program(struct archive *, const char *command)
     * }
     */
    public static MemorySegment archive_read_support_filter_program$address() {
        return archive_read_support_filter_program.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_program(struct archive *, const char *command)
     * }
     */
    public static int archive_read_support_filter_program(MemorySegment x0, MemorySegment command) {
        var mh$ = archive_read_support_filter_program.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_program", x0, command);
            }
            return (int)mh$.invokeExact(x0, command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_program_signature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_program_signature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_program_signature$descriptor() {
        return archive_read_support_filter_program_signature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle archive_read_support_filter_program_signature$handle() {
        return archive_read_support_filter_program_signature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment archive_read_support_filter_program_signature$address() {
        return archive_read_support_filter_program_signature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static int archive_read_support_filter_program_signature(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = archive_read_support_filter_program_signature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_program_signature", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_rpm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_rpm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_rpm(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_rpm$descriptor() {
        return archive_read_support_filter_rpm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_rpm(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_rpm$handle() {
        return archive_read_support_filter_rpm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_rpm(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_rpm$address() {
        return archive_read_support_filter_rpm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_rpm(struct archive *)
     * }
     */
    public static int archive_read_support_filter_rpm(MemorySegment x0) {
        var mh$ = archive_read_support_filter_rpm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_rpm", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_uu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_uu");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_uu(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_uu$descriptor() {
        return archive_read_support_filter_uu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_uu(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_uu$handle() {
        return archive_read_support_filter_uu.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_uu(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_uu$address() {
        return archive_read_support_filter_uu.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_uu(struct archive *)
     * }
     */
    public static int archive_read_support_filter_uu(MemorySegment x0) {
        var mh$ = archive_read_support_filter_uu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_uu", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_xz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_xz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_xz(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_xz$descriptor() {
        return archive_read_support_filter_xz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_xz(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_xz$handle() {
        return archive_read_support_filter_xz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_xz(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_xz$address() {
        return archive_read_support_filter_xz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_xz(struct archive *)
     * }
     */
    public static int archive_read_support_filter_xz(MemorySegment x0) {
        var mh$ = archive_read_support_filter_xz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_xz", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_filter_zstd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_filter_zstd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_filter_zstd(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_filter_zstd$descriptor() {
        return archive_read_support_filter_zstd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_filter_zstd(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_filter_zstd$handle() {
        return archive_read_support_filter_zstd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_filter_zstd(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_filter_zstd$address() {
        return archive_read_support_filter_zstd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_filter_zstd(struct archive *)
     * }
     */
    public static int archive_read_support_filter_zstd(MemorySegment x0) {
        var mh$ = archive_read_support_filter_zstd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_filter_zstd", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_7zip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_7zip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_7zip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_7zip$descriptor() {
        return archive_read_support_format_7zip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_7zip(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_7zip$handle() {
        return archive_read_support_format_7zip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_7zip(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_7zip$address() {
        return archive_read_support_format_7zip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_7zip(struct archive *)
     * }
     */
    public static int archive_read_support_format_7zip(MemorySegment x0) {
        var mh$ = archive_read_support_format_7zip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_7zip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_all {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_all");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_all(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_all$descriptor() {
        return archive_read_support_format_all.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_all(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_all$handle() {
        return archive_read_support_format_all.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_all(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_all$address() {
        return archive_read_support_format_all.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_all(struct archive *)
     * }
     */
    public static int archive_read_support_format_all(MemorySegment x0) {
        var mh$ = archive_read_support_format_all.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_all", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_ar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_ar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_ar(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_ar$descriptor() {
        return archive_read_support_format_ar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_ar(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_ar$handle() {
        return archive_read_support_format_ar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_ar(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_ar$address() {
        return archive_read_support_format_ar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_ar(struct archive *)
     * }
     */
    public static int archive_read_support_format_ar(MemorySegment x0) {
        var mh$ = archive_read_support_format_ar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_ar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_by_code {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_by_code");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_by_code(struct archive *, int)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_by_code$descriptor() {
        return archive_read_support_format_by_code.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_by_code(struct archive *, int)
     * }
     */
    public static MethodHandle archive_read_support_format_by_code$handle() {
        return archive_read_support_format_by_code.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_by_code(struct archive *, int)
     * }
     */
    public static MemorySegment archive_read_support_format_by_code$address() {
        return archive_read_support_format_by_code.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_by_code(struct archive *, int)
     * }
     */
    public static int archive_read_support_format_by_code(MemorySegment x0, int x1) {
        var mh$ = archive_read_support_format_by_code.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_by_code", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_cab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_cab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_cab(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_cab$descriptor() {
        return archive_read_support_format_cab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_cab(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_cab$handle() {
        return archive_read_support_format_cab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_cab(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_cab$address() {
        return archive_read_support_format_cab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_cab(struct archive *)
     * }
     */
    public static int archive_read_support_format_cab(MemorySegment x0) {
        var mh$ = archive_read_support_format_cab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_cab", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_cpio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_cpio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_cpio(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_cpio$descriptor() {
        return archive_read_support_format_cpio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_cpio(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_cpio$handle() {
        return archive_read_support_format_cpio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_cpio(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_cpio$address() {
        return archive_read_support_format_cpio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_cpio(struct archive *)
     * }
     */
    public static int archive_read_support_format_cpio(MemorySegment x0) {
        var mh$ = archive_read_support_format_cpio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_cpio", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_empty(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_empty$descriptor() {
        return archive_read_support_format_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_empty(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_empty$handle() {
        return archive_read_support_format_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_empty(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_empty$address() {
        return archive_read_support_format_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_empty(struct archive *)
     * }
     */
    public static int archive_read_support_format_empty(MemorySegment x0) {
        var mh$ = archive_read_support_format_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_empty", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_gnutar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_gnutar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_gnutar(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_gnutar$descriptor() {
        return archive_read_support_format_gnutar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_gnutar(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_gnutar$handle() {
        return archive_read_support_format_gnutar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_gnutar(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_gnutar$address() {
        return archive_read_support_format_gnutar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_gnutar(struct archive *)
     * }
     */
    public static int archive_read_support_format_gnutar(MemorySegment x0) {
        var mh$ = archive_read_support_format_gnutar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_gnutar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_iso9660 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_iso9660");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_iso9660(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_iso9660$descriptor() {
        return archive_read_support_format_iso9660.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_iso9660(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_iso9660$handle() {
        return archive_read_support_format_iso9660.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_iso9660(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_iso9660$address() {
        return archive_read_support_format_iso9660.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_iso9660(struct archive *)
     * }
     */
    public static int archive_read_support_format_iso9660(MemorySegment x0) {
        var mh$ = archive_read_support_format_iso9660.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_iso9660", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_lha {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_lha");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_lha(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_lha$descriptor() {
        return archive_read_support_format_lha.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_lha(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_lha$handle() {
        return archive_read_support_format_lha.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_lha(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_lha$address() {
        return archive_read_support_format_lha.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_lha(struct archive *)
     * }
     */
    public static int archive_read_support_format_lha(MemorySegment x0) {
        var mh$ = archive_read_support_format_lha.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_lha", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_mtree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_mtree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_mtree(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_mtree$descriptor() {
        return archive_read_support_format_mtree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_mtree(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_mtree$handle() {
        return archive_read_support_format_mtree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_mtree(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_mtree$address() {
        return archive_read_support_format_mtree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_mtree(struct archive *)
     * }
     */
    public static int archive_read_support_format_mtree(MemorySegment x0) {
        var mh$ = archive_read_support_format_mtree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_mtree", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_rar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_rar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_rar(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_rar$descriptor() {
        return archive_read_support_format_rar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_rar(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_rar$handle() {
        return archive_read_support_format_rar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_rar(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_rar$address() {
        return archive_read_support_format_rar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_rar(struct archive *)
     * }
     */
    public static int archive_read_support_format_rar(MemorySegment x0) {
        var mh$ = archive_read_support_format_rar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_rar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_rar5 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_rar5");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_rar5(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_rar5$descriptor() {
        return archive_read_support_format_rar5.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_rar5(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_rar5$handle() {
        return archive_read_support_format_rar5.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_rar5(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_rar5$address() {
        return archive_read_support_format_rar5.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_rar5(struct archive *)
     * }
     */
    public static int archive_read_support_format_rar5(MemorySegment x0) {
        var mh$ = archive_read_support_format_rar5.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_rar5", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_raw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_raw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_raw(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_raw$descriptor() {
        return archive_read_support_format_raw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_raw(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_raw$handle() {
        return archive_read_support_format_raw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_raw(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_raw$address() {
        return archive_read_support_format_raw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_raw(struct archive *)
     * }
     */
    public static int archive_read_support_format_raw(MemorySegment x0) {
        var mh$ = archive_read_support_format_raw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_raw", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_tar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_tar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_tar(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_tar$descriptor() {
        return archive_read_support_format_tar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_tar(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_tar$handle() {
        return archive_read_support_format_tar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_tar(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_tar$address() {
        return archive_read_support_format_tar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_tar(struct archive *)
     * }
     */
    public static int archive_read_support_format_tar(MemorySegment x0) {
        var mh$ = archive_read_support_format_tar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_tar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_warc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_warc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_warc(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_warc$descriptor() {
        return archive_read_support_format_warc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_warc(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_warc$handle() {
        return archive_read_support_format_warc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_warc(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_warc$address() {
        return archive_read_support_format_warc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_warc(struct archive *)
     * }
     */
    public static int archive_read_support_format_warc(MemorySegment x0) {
        var mh$ = archive_read_support_format_warc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_warc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_xar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_xar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_xar(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_xar$descriptor() {
        return archive_read_support_format_xar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_xar(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_xar$handle() {
        return archive_read_support_format_xar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_xar(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_xar$address() {
        return archive_read_support_format_xar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_xar(struct archive *)
     * }
     */
    public static int archive_read_support_format_xar(MemorySegment x0) {
        var mh$ = archive_read_support_format_xar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_xar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_zip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_zip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_zip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_zip$descriptor() {
        return archive_read_support_format_zip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_zip(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_zip$handle() {
        return archive_read_support_format_zip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_zip(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_zip$address() {
        return archive_read_support_format_zip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_zip(struct archive *)
     * }
     */
    public static int archive_read_support_format_zip(MemorySegment x0) {
        var mh$ = archive_read_support_format_zip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_zip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_zip_streamable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_zip_streamable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_zip_streamable(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_zip_streamable$descriptor() {
        return archive_read_support_format_zip_streamable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_zip_streamable(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_zip_streamable$handle() {
        return archive_read_support_format_zip_streamable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_zip_streamable(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_zip_streamable$address() {
        return archive_read_support_format_zip_streamable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_zip_streamable(struct archive *)
     * }
     */
    public static int archive_read_support_format_zip_streamable(MemorySegment x0) {
        var mh$ = archive_read_support_format_zip_streamable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_zip_streamable", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_support_format_zip_seekable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_support_format_zip_seekable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_support_format_zip_seekable(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_support_format_zip_seekable$descriptor() {
        return archive_read_support_format_zip_seekable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_support_format_zip_seekable(struct archive *)
     * }
     */
    public static MethodHandle archive_read_support_format_zip_seekable$handle() {
        return archive_read_support_format_zip_seekable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_support_format_zip_seekable(struct archive *)
     * }
     */
    public static MemorySegment archive_read_support_format_zip_seekable$address() {
        return archive_read_support_format_zip_seekable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_support_format_zip_seekable(struct archive *)
     * }
     */
    public static int archive_read_support_format_zip_seekable(MemorySegment x0) {
        var mh$ = archive_read_support_format_zip_seekable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_support_format_zip_seekable", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_format(struct archive *, int)
     * }
     */
    public static FunctionDescriptor archive_read_set_format$descriptor() {
        return archive_read_set_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_format(struct archive *, int)
     * }
     */
    public static MethodHandle archive_read_set_format$handle() {
        return archive_read_set_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_format(struct archive *, int)
     * }
     */
    public static MemorySegment archive_read_set_format$address() {
        return archive_read_set_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_format(struct archive *, int)
     * }
     */
    public static int archive_read_set_format(MemorySegment x0, int x1) {
        var mh$ = archive_read_set_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_format", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_append_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_append_filter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_append_filter(struct archive *, int)
     * }
     */
    public static FunctionDescriptor archive_read_append_filter$descriptor() {
        return archive_read_append_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_append_filter(struct archive *, int)
     * }
     */
    public static MethodHandle archive_read_append_filter$handle() {
        return archive_read_append_filter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_append_filter(struct archive *, int)
     * }
     */
    public static MemorySegment archive_read_append_filter$address() {
        return archive_read_append_filter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_append_filter(struct archive *, int)
     * }
     */
    public static int archive_read_append_filter(MemorySegment x0, int x1) {
        var mh$ = archive_read_append_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_append_filter", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_append_filter_program {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_append_filter_program");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_append_filter_program(struct archive *, const char *)
     * }
     */
    public static FunctionDescriptor archive_read_append_filter_program$descriptor() {
        return archive_read_append_filter_program.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_append_filter_program(struct archive *, const char *)
     * }
     */
    public static MethodHandle archive_read_append_filter_program$handle() {
        return archive_read_append_filter_program.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_append_filter_program(struct archive *, const char *)
     * }
     */
    public static MemorySegment archive_read_append_filter_program$address() {
        return archive_read_append_filter_program.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_append_filter_program(struct archive *, const char *)
     * }
     */
    public static int archive_read_append_filter_program(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_append_filter_program.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_append_filter_program", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_append_filter_program_signature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_append_filter_program_signature");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_append_filter_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor archive_read_append_filter_program_signature$descriptor() {
        return archive_read_append_filter_program_signature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_append_filter_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle archive_read_append_filter_program_signature$handle() {
        return archive_read_append_filter_program_signature.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_append_filter_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment archive_read_append_filter_program_signature$address() {
        return archive_read_append_filter_program_signature.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_append_filter_program_signature(struct archive *, const char *, const void *, size_t)
     * }
     */
    public static int archive_read_append_filter_program_signature(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = archive_read_append_filter_program_signature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_append_filter_program_signature", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_open_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_open_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_open_callback(struct archive *, archive_open_callback *)
     * }
     */
    public static FunctionDescriptor archive_read_set_open_callback$descriptor() {
        return archive_read_set_open_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_open_callback(struct archive *, archive_open_callback *)
     * }
     */
    public static MethodHandle archive_read_set_open_callback$handle() {
        return archive_read_set_open_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_open_callback(struct archive *, archive_open_callback *)
     * }
     */
    public static MemorySegment archive_read_set_open_callback$address() {
        return archive_read_set_open_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_open_callback(struct archive *, archive_open_callback *)
     * }
     */
    public static int archive_read_set_open_callback(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_set_open_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_open_callback", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_read_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_read_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_read_callback(struct archive *, archive_read_callback *)
     * }
     */
    public static FunctionDescriptor archive_read_set_read_callback$descriptor() {
        return archive_read_set_read_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_read_callback(struct archive *, archive_read_callback *)
     * }
     */
    public static MethodHandle archive_read_set_read_callback$handle() {
        return archive_read_set_read_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_read_callback(struct archive *, archive_read_callback *)
     * }
     */
    public static MemorySegment archive_read_set_read_callback$address() {
        return archive_read_set_read_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_read_callback(struct archive *, archive_read_callback *)
     * }
     */
    public static int archive_read_set_read_callback(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_set_read_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_read_callback", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_seek_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_seek_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_seek_callback(struct archive *, archive_seek_callback *)
     * }
     */
    public static FunctionDescriptor archive_read_set_seek_callback$descriptor() {
        return archive_read_set_seek_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_seek_callback(struct archive *, archive_seek_callback *)
     * }
     */
    public static MethodHandle archive_read_set_seek_callback$handle() {
        return archive_read_set_seek_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_seek_callback(struct archive *, archive_seek_callback *)
     * }
     */
    public static MemorySegment archive_read_set_seek_callback$address() {
        return archive_read_set_seek_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_seek_callback(struct archive *, archive_seek_callback *)
     * }
     */
    public static int archive_read_set_seek_callback(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_set_seek_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_seek_callback", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_skip_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_skip_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_skip_callback(struct archive *, archive_skip_callback *)
     * }
     */
    public static FunctionDescriptor archive_read_set_skip_callback$descriptor() {
        return archive_read_set_skip_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_skip_callback(struct archive *, archive_skip_callback *)
     * }
     */
    public static MethodHandle archive_read_set_skip_callback$handle() {
        return archive_read_set_skip_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_skip_callback(struct archive *, archive_skip_callback *)
     * }
     */
    public static MemorySegment archive_read_set_skip_callback$address() {
        return archive_read_set_skip_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_skip_callback(struct archive *, archive_skip_callback *)
     * }
     */
    public static int archive_read_set_skip_callback(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_set_skip_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_skip_callback", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_close_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_close_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_close_callback(struct archive *, archive_close_callback *)
     * }
     */
    public static FunctionDescriptor archive_read_set_close_callback$descriptor() {
        return archive_read_set_close_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_close_callback(struct archive *, archive_close_callback *)
     * }
     */
    public static MethodHandle archive_read_set_close_callback$handle() {
        return archive_read_set_close_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_close_callback(struct archive *, archive_close_callback *)
     * }
     */
    public static MemorySegment archive_read_set_close_callback$address() {
        return archive_read_set_close_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_close_callback(struct archive *, archive_close_callback *)
     * }
     */
    public static int archive_read_set_close_callback(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_set_close_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_close_callback", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_switch_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_switch_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_switch_callback(struct archive *, archive_switch_callback *)
     * }
     */
    public static FunctionDescriptor archive_read_set_switch_callback$descriptor() {
        return archive_read_set_switch_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_switch_callback(struct archive *, archive_switch_callback *)
     * }
     */
    public static MethodHandle archive_read_set_switch_callback$handle() {
        return archive_read_set_switch_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_switch_callback(struct archive *, archive_switch_callback *)
     * }
     */
    public static MemorySegment archive_read_set_switch_callback$address() {
        return archive_read_set_switch_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_switch_callback(struct archive *, archive_switch_callback *)
     * }
     */
    public static int archive_read_set_switch_callback(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_set_switch_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_switch_callback", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_callback_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_callback_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_callback_data(struct archive *, void *)
     * }
     */
    public static FunctionDescriptor archive_read_set_callback_data$descriptor() {
        return archive_read_set_callback_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_callback_data(struct archive *, void *)
     * }
     */
    public static MethodHandle archive_read_set_callback_data$handle() {
        return archive_read_set_callback_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_callback_data(struct archive *, void *)
     * }
     */
    public static MemorySegment archive_read_set_callback_data$address() {
        return archive_read_set_callback_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_callback_data(struct archive *, void *)
     * }
     */
    public static int archive_read_set_callback_data(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_set_callback_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_callback_data", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_callback_data2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_callback_data2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_callback_data2(struct archive *, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor archive_read_set_callback_data2$descriptor() {
        return archive_read_set_callback_data2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_callback_data2(struct archive *, void *, unsigned int)
     * }
     */
    public static MethodHandle archive_read_set_callback_data2$handle() {
        return archive_read_set_callback_data2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_callback_data2(struct archive *, void *, unsigned int)
     * }
     */
    public static MemorySegment archive_read_set_callback_data2$address() {
        return archive_read_set_callback_data2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_callback_data2(struct archive *, void *, unsigned int)
     * }
     */
    public static int archive_read_set_callback_data2(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = archive_read_set_callback_data2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_callback_data2", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_add_callback_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_add_callback_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_add_callback_data(struct archive *, void *, unsigned int)
     * }
     */
    public static FunctionDescriptor archive_read_add_callback_data$descriptor() {
        return archive_read_add_callback_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_add_callback_data(struct archive *, void *, unsigned int)
     * }
     */
    public static MethodHandle archive_read_add_callback_data$handle() {
        return archive_read_add_callback_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_add_callback_data(struct archive *, void *, unsigned int)
     * }
     */
    public static MemorySegment archive_read_add_callback_data$address() {
        return archive_read_add_callback_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_add_callback_data(struct archive *, void *, unsigned int)
     * }
     */
    public static int archive_read_add_callback_data(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = archive_read_add_callback_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_add_callback_data", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_append_callback_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_append_callback_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_append_callback_data(struct archive *, void *)
     * }
     */
    public static FunctionDescriptor archive_read_append_callback_data$descriptor() {
        return archive_read_append_callback_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_append_callback_data(struct archive *, void *)
     * }
     */
    public static MethodHandle archive_read_append_callback_data$handle() {
        return archive_read_append_callback_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_append_callback_data(struct archive *, void *)
     * }
     */
    public static MemorySegment archive_read_append_callback_data$address() {
        return archive_read_append_callback_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_append_callback_data(struct archive *, void *)
     * }
     */
    public static int archive_read_append_callback_data(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_append_callback_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_append_callback_data", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_prepend_callback_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_prepend_callback_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_prepend_callback_data(struct archive *, void *)
     * }
     */
    public static FunctionDescriptor archive_read_prepend_callback_data$descriptor() {
        return archive_read_prepend_callback_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_prepend_callback_data(struct archive *, void *)
     * }
     */
    public static MethodHandle archive_read_prepend_callback_data$handle() {
        return archive_read_prepend_callback_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_prepend_callback_data(struct archive *, void *)
     * }
     */
    public static MemorySegment archive_read_prepend_callback_data$address() {
        return archive_read_prepend_callback_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_prepend_callback_data(struct archive *, void *)
     * }
     */
    public static int archive_read_prepend_callback_data(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_prepend_callback_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_prepend_callback_data", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_open1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_open1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_open1(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_open1$descriptor() {
        return archive_read_open1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_open1(struct archive *)
     * }
     */
    public static MethodHandle archive_read_open1$handle() {
        return archive_read_open1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_open1(struct archive *)
     * }
     */
    public static MemorySegment archive_read_open1$address() {
        return archive_read_open1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_open1(struct archive *)
     * }
     */
    public static int archive_read_open1(MemorySegment x0) {
        var mh$ = archive_read_open1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_open1", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_open(struct archive *, void *_client_data, archive_open_callback *, archive_read_callback *, archive_close_callback *)
     * }
     */
    public static FunctionDescriptor archive_read_open$descriptor() {
        return archive_read_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_open(struct archive *, void *_client_data, archive_open_callback *, archive_read_callback *, archive_close_callback *)
     * }
     */
    public static MethodHandle archive_read_open$handle() {
        return archive_read_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_open(struct archive *, void *_client_data, archive_open_callback *, archive_read_callback *, archive_close_callback *)
     * }
     */
    public static MemorySegment archive_read_open$address() {
        return archive_read_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_open(struct archive *, void *_client_data, archive_open_callback *, archive_read_callback *, archive_close_callback *)
     * }
     */
    public static int archive_read_open(MemorySegment x0, MemorySegment _client_data, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = archive_read_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_open", x0, _client_data, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, _client_data, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_open2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_open2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_open2(struct archive *, void *_client_data, archive_open_callback *, archive_read_callback *, archive_skip_callback *, archive_close_callback *)
     * }
     */
    public static FunctionDescriptor archive_read_open2$descriptor() {
        return archive_read_open2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_open2(struct archive *, void *_client_data, archive_open_callback *, archive_read_callback *, archive_skip_callback *, archive_close_callback *)
     * }
     */
    public static MethodHandle archive_read_open2$handle() {
        return archive_read_open2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_open2(struct archive *, void *_client_data, archive_open_callback *, archive_read_callback *, archive_skip_callback *, archive_close_callback *)
     * }
     */
    public static MemorySegment archive_read_open2$address() {
        return archive_read_open2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_open2(struct archive *, void *_client_data, archive_open_callback *, archive_read_callback *, archive_skip_callback *, archive_close_callback *)
     * }
     */
    public static int archive_read_open2(MemorySegment x0, MemorySegment _client_data, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = archive_read_open2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_open2", x0, _client_data, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, _client_data, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_open_filename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_open_filename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_open_filename(struct archive *, const char *_filename, size_t _block_size)
     * }
     */
    public static FunctionDescriptor archive_read_open_filename$descriptor() {
        return archive_read_open_filename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_open_filename(struct archive *, const char *_filename, size_t _block_size)
     * }
     */
    public static MethodHandle archive_read_open_filename$handle() {
        return archive_read_open_filename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_open_filename(struct archive *, const char *_filename, size_t _block_size)
     * }
     */
    public static MemorySegment archive_read_open_filename$address() {
        return archive_read_open_filename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_open_filename(struct archive *, const char *_filename, size_t _block_size)
     * }
     */
    public static int archive_read_open_filename(MemorySegment x0, MemorySegment _filename, long _block_size) {
        var mh$ = archive_read_open_filename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_open_filename", x0, _filename, _block_size);
            }
            return (int)mh$.invokeExact(x0, _filename, _block_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_open_filenames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_open_filenames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_open_filenames(struct archive *, const char **_filenames, size_t _block_size)
     * }
     */
    public static FunctionDescriptor archive_read_open_filenames$descriptor() {
        return archive_read_open_filenames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_open_filenames(struct archive *, const char **_filenames, size_t _block_size)
     * }
     */
    public static MethodHandle archive_read_open_filenames$handle() {
        return archive_read_open_filenames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_open_filenames(struct archive *, const char **_filenames, size_t _block_size)
     * }
     */
    public static MemorySegment archive_read_open_filenames$address() {
        return archive_read_open_filenames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_open_filenames(struct archive *, const char **_filenames, size_t _block_size)
     * }
     */
    public static int archive_read_open_filenames(MemorySegment x0, MemorySegment _filenames, long _block_size) {
        var mh$ = archive_read_open_filenames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_open_filenames", x0, _filenames, _block_size);
            }
            return (int)mh$.invokeExact(x0, _filenames, _block_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_open_filename_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_open_filename_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_open_filename_w(struct archive *, const wchar_t *_filename, size_t _block_size)
     * }
     */
    public static FunctionDescriptor archive_read_open_filename_w$descriptor() {
        return archive_read_open_filename_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_open_filename_w(struct archive *, const wchar_t *_filename, size_t _block_size)
     * }
     */
    public static MethodHandle archive_read_open_filename_w$handle() {
        return archive_read_open_filename_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_open_filename_w(struct archive *, const wchar_t *_filename, size_t _block_size)
     * }
     */
    public static MemorySegment archive_read_open_filename_w$address() {
        return archive_read_open_filename_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_open_filename_w(struct archive *, const wchar_t *_filename, size_t _block_size)
     * }
     */
    public static int archive_read_open_filename_w(MemorySegment x0, MemorySegment _filename, long _block_size) {
        var mh$ = archive_read_open_filename_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_open_filename_w", x0, _filename, _block_size);
            }
            return (int)mh$.invokeExact(x0, _filename, _block_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_open_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_open_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_open_file(struct archive *, const char *_filename, size_t _block_size)
     * }
     */
    public static FunctionDescriptor archive_read_open_file$descriptor() {
        return archive_read_open_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_open_file(struct archive *, const char *_filename, size_t _block_size)
     * }
     */
    public static MethodHandle archive_read_open_file$handle() {
        return archive_read_open_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_open_file(struct archive *, const char *_filename, size_t _block_size)
     * }
     */
    public static MemorySegment archive_read_open_file$address() {
        return archive_read_open_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_open_file(struct archive *, const char *_filename, size_t _block_size)
     * }
     */
    public static int archive_read_open_file(MemorySegment x0, MemorySegment _filename, long _block_size) {
        var mh$ = archive_read_open_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_open_file", x0, _filename, _block_size);
            }
            return (int)mh$.invokeExact(x0, _filename, _block_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_open_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_open_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_open_memory(struct archive *, const void *buff, size_t size)
     * }
     */
    public static FunctionDescriptor archive_read_open_memory$descriptor() {
        return archive_read_open_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_open_memory(struct archive *, const void *buff, size_t size)
     * }
     */
    public static MethodHandle archive_read_open_memory$handle() {
        return archive_read_open_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_open_memory(struct archive *, const void *buff, size_t size)
     * }
     */
    public static MemorySegment archive_read_open_memory$address() {
        return archive_read_open_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_open_memory(struct archive *, const void *buff, size_t size)
     * }
     */
    public static int archive_read_open_memory(MemorySegment x0, MemorySegment buff, long size) {
        var mh$ = archive_read_open_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_open_memory", x0, buff, size);
            }
            return (int)mh$.invokeExact(x0, buff, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_open_memory2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_open_memory2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_open_memory2(struct archive *a, const void *buff, size_t size, size_t read_size)
     * }
     */
    public static FunctionDescriptor archive_read_open_memory2$descriptor() {
        return archive_read_open_memory2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_open_memory2(struct archive *a, const void *buff, size_t size, size_t read_size)
     * }
     */
    public static MethodHandle archive_read_open_memory2$handle() {
        return archive_read_open_memory2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_open_memory2(struct archive *a, const void *buff, size_t size, size_t read_size)
     * }
     */
    public static MemorySegment archive_read_open_memory2$address() {
        return archive_read_open_memory2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_open_memory2(struct archive *a, const void *buff, size_t size, size_t read_size)
     * }
     */
    public static int archive_read_open_memory2(MemorySegment a, MemorySegment buff, long size, long read_size) {
        var mh$ = archive_read_open_memory2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_open_memory2", a, buff, size, read_size);
            }
            return (int)mh$.invokeExact(a, buff, size, read_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_open_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_open_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_open_fd(struct archive *, int _fd, size_t _block_size)
     * }
     */
    public static FunctionDescriptor archive_read_open_fd$descriptor() {
        return archive_read_open_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_open_fd(struct archive *, int _fd, size_t _block_size)
     * }
     */
    public static MethodHandle archive_read_open_fd$handle() {
        return archive_read_open_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_open_fd(struct archive *, int _fd, size_t _block_size)
     * }
     */
    public static MemorySegment archive_read_open_fd$address() {
        return archive_read_open_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_open_fd(struct archive *, int _fd, size_t _block_size)
     * }
     */
    public static int archive_read_open_fd(MemorySegment x0, int _fd, long _block_size) {
        var mh$ = archive_read_open_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_open_fd", x0, _fd, _block_size);
            }
            return (int)mh$.invokeExact(x0, _fd, _block_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_open_FILE$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_open_FILE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_open_FILE(struct archive *, FILE *_file)
     * }
     */
    public static FunctionDescriptor archive_read_open_FILE$descriptor() {
        return archive_read_open_FILE$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_open_FILE(struct archive *, FILE *_file)
     * }
     */
    public static MethodHandle archive_read_open_FILE$handle() {
        return archive_read_open_FILE$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_open_FILE(struct archive *, FILE *_file)
     * }
     */
    public static MemorySegment archive_read_open_FILE$address() {
        return archive_read_open_FILE$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_open_FILE(struct archive *, FILE *_file)
     * }
     */
    public static int archive_read_open_FILE(MemorySegment x0, MemorySegment _file) {
        var mh$ = archive_read_open_FILE$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_open_FILE", x0, _file);
            }
            return (int)mh$.invokeExact(x0, _file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_next_header {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_next_header");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_next_header(struct archive *, struct archive_entry **)
     * }
     */
    public static FunctionDescriptor archive_read_next_header$descriptor() {
        return archive_read_next_header.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_next_header(struct archive *, struct archive_entry **)
     * }
     */
    public static MethodHandle archive_read_next_header$handle() {
        return archive_read_next_header.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_next_header(struct archive *, struct archive_entry **)
     * }
     */
    public static MemorySegment archive_read_next_header$address() {
        return archive_read_next_header.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_next_header(struct archive *, struct archive_entry **)
     * }
     */
    public static int archive_read_next_header(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_next_header.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_next_header", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_next_header2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_next_header2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_next_header2(struct archive *, struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_read_next_header2$descriptor() {
        return archive_read_next_header2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_next_header2(struct archive *, struct archive_entry *)
     * }
     */
    public static MethodHandle archive_read_next_header2$handle() {
        return archive_read_next_header2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_next_header2(struct archive *, struct archive_entry *)
     * }
     */
    public static MemorySegment archive_read_next_header2$address() {
        return archive_read_next_header2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_next_header2(struct archive *, struct archive_entry *)
     * }
     */
    public static int archive_read_next_header2(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_next_header2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_next_header2", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_header_position {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_header_position");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_read_header_position(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_header_position$descriptor() {
        return archive_read_header_position.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_read_header_position(struct archive *)
     * }
     */
    public static MethodHandle archive_read_header_position$handle() {
        return archive_read_header_position.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_read_header_position(struct archive *)
     * }
     */
    public static MemorySegment archive_read_header_position$address() {
        return archive_read_header_position.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_read_header_position(struct archive *)
     * }
     */
    public static long archive_read_header_position(MemorySegment x0) {
        var mh$ = archive_read_header_position.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_header_position", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_has_encrypted_entries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_has_encrypted_entries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_has_encrypted_entries(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_has_encrypted_entries$descriptor() {
        return archive_read_has_encrypted_entries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_has_encrypted_entries(struct archive *)
     * }
     */
    public static MethodHandle archive_read_has_encrypted_entries$handle() {
        return archive_read_has_encrypted_entries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_has_encrypted_entries(struct archive *)
     * }
     */
    public static MemorySegment archive_read_has_encrypted_entries$address() {
        return archive_read_has_encrypted_entries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_has_encrypted_entries(struct archive *)
     * }
     */
    public static int archive_read_has_encrypted_entries(MemorySegment x0) {
        var mh$ = archive_read_has_encrypted_entries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_has_encrypted_entries", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_format_capabilities {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_format_capabilities");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_format_capabilities(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_format_capabilities$descriptor() {
        return archive_read_format_capabilities.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_format_capabilities(struct archive *)
     * }
     */
    public static MethodHandle archive_read_format_capabilities$handle() {
        return archive_read_format_capabilities.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_format_capabilities(struct archive *)
     * }
     */
    public static MemorySegment archive_read_format_capabilities$address() {
        return archive_read_format_capabilities.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_format_capabilities(struct archive *)
     * }
     */
    public static int archive_read_format_capabilities(MemorySegment x0) {
        var mh$ = archive_read_format_capabilities.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_format_capabilities", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_ssize_t archive_read_data(struct archive *, void *, size_t)
     * }
     */
    public static FunctionDescriptor archive_read_data$descriptor() {
        return archive_read_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_ssize_t archive_read_data(struct archive *, void *, size_t)
     * }
     */
    public static MethodHandle archive_read_data$handle() {
        return archive_read_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_ssize_t archive_read_data(struct archive *, void *, size_t)
     * }
     */
    public static MemorySegment archive_read_data$address() {
        return archive_read_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_ssize_t archive_read_data(struct archive *, void *, size_t)
     * }
     */
    public static long archive_read_data(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = archive_read_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_data", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_seek_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_seek_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_seek_data(struct archive *, la_int64_t, int)
     * }
     */
    public static FunctionDescriptor archive_seek_data$descriptor() {
        return archive_seek_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_seek_data(struct archive *, la_int64_t, int)
     * }
     */
    public static MethodHandle archive_seek_data$handle() {
        return archive_seek_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_seek_data(struct archive *, la_int64_t, int)
     * }
     */
    public static MemorySegment archive_seek_data$address() {
        return archive_seek_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_seek_data(struct archive *, la_int64_t, int)
     * }
     */
    public static long archive_seek_data(MemorySegment x0, long x1, int x2) {
        var mh$ = archive_seek_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_seek_data", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_data_block {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_data_block");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_data_block(struct archive *a, const void **buff, size_t *size, la_int64_t *offset)
     * }
     */
    public static FunctionDescriptor archive_read_data_block$descriptor() {
        return archive_read_data_block.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_data_block(struct archive *a, const void **buff, size_t *size, la_int64_t *offset)
     * }
     */
    public static MethodHandle archive_read_data_block$handle() {
        return archive_read_data_block.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_data_block(struct archive *a, const void **buff, size_t *size, la_int64_t *offset)
     * }
     */
    public static MemorySegment archive_read_data_block$address() {
        return archive_read_data_block.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_data_block(struct archive *a, const void **buff, size_t *size, la_int64_t *offset)
     * }
     */
    public static int archive_read_data_block(MemorySegment a, MemorySegment buff, MemorySegment size, MemorySegment offset) {
        var mh$ = archive_read_data_block.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_data_block", a, buff, size, offset);
            }
            return (int)mh$.invokeExact(a, buff, size, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_data_skip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_data_skip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_data_skip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_data_skip$descriptor() {
        return archive_read_data_skip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_data_skip(struct archive *)
     * }
     */
    public static MethodHandle archive_read_data_skip$handle() {
        return archive_read_data_skip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_data_skip(struct archive *)
     * }
     */
    public static MemorySegment archive_read_data_skip$address() {
        return archive_read_data_skip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_data_skip(struct archive *)
     * }
     */
    public static int archive_read_data_skip(MemorySegment x0) {
        var mh$ = archive_read_data_skip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_data_skip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_data_into_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_data_into_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_data_into_fd(struct archive *, int fd)
     * }
     */
    public static FunctionDescriptor archive_read_data_into_fd$descriptor() {
        return archive_read_data_into_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_data_into_fd(struct archive *, int fd)
     * }
     */
    public static MethodHandle archive_read_data_into_fd$handle() {
        return archive_read_data_into_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_data_into_fd(struct archive *, int fd)
     * }
     */
    public static MemorySegment archive_read_data_into_fd$address() {
        return archive_read_data_into_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_data_into_fd(struct archive *, int fd)
     * }
     */
    public static int archive_read_data_into_fd(MemorySegment x0, int fd) {
        var mh$ = archive_read_data_into_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_data_into_fd", x0, fd);
            }
            return (int)mh$.invokeExact(x0, fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_format_option {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_format_option");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_format_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static FunctionDescriptor archive_read_set_format_option$descriptor() {
        return archive_read_set_format_option.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_format_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MethodHandle archive_read_set_format_option$handle() {
        return archive_read_set_format_option.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_format_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MemorySegment archive_read_set_format_option$address() {
        return archive_read_set_format_option.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_format_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static int archive_read_set_format_option(MemorySegment _a, MemorySegment m, MemorySegment o, MemorySegment v) {
        var mh$ = archive_read_set_format_option.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_format_option", _a, m, o, v);
            }
            return (int)mh$.invokeExact(_a, m, o, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_filter_option {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_filter_option");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_filter_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static FunctionDescriptor archive_read_set_filter_option$descriptor() {
        return archive_read_set_filter_option.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_filter_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MethodHandle archive_read_set_filter_option$handle() {
        return archive_read_set_filter_option.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_filter_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MemorySegment archive_read_set_filter_option$address() {
        return archive_read_set_filter_option.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_filter_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static int archive_read_set_filter_option(MemorySegment _a, MemorySegment m, MemorySegment o, MemorySegment v) {
        var mh$ = archive_read_set_filter_option.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_filter_option", _a, m, o, v);
            }
            return (int)mh$.invokeExact(_a, m, o, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_option {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_option");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static FunctionDescriptor archive_read_set_option$descriptor() {
        return archive_read_set_option.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MethodHandle archive_read_set_option$handle() {
        return archive_read_set_option.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MemorySegment archive_read_set_option$address() {
        return archive_read_set_option.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static int archive_read_set_option(MemorySegment _a, MemorySegment m, MemorySegment o, MemorySegment v) {
        var mh$ = archive_read_set_option.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_option", _a, m, o, v);
            }
            return (int)mh$.invokeExact(_a, m, o, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_options(struct archive *_a, const char *opts)
     * }
     */
    public static FunctionDescriptor archive_read_set_options$descriptor() {
        return archive_read_set_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_options(struct archive *_a, const char *opts)
     * }
     */
    public static MethodHandle archive_read_set_options$handle() {
        return archive_read_set_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_options(struct archive *_a, const char *opts)
     * }
     */
    public static MemorySegment archive_read_set_options$address() {
        return archive_read_set_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_options(struct archive *_a, const char *opts)
     * }
     */
    public static int archive_read_set_options(MemorySegment _a, MemorySegment opts) {
        var mh$ = archive_read_set_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_options", _a, opts);
            }
            return (int)mh$.invokeExact(_a, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_add_passphrase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_add_passphrase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_add_passphrase(struct archive *, const char *)
     * }
     */
    public static FunctionDescriptor archive_read_add_passphrase$descriptor() {
        return archive_read_add_passphrase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_add_passphrase(struct archive *, const char *)
     * }
     */
    public static MethodHandle archive_read_add_passphrase$handle() {
        return archive_read_add_passphrase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_add_passphrase(struct archive *, const char *)
     * }
     */
    public static MemorySegment archive_read_add_passphrase$address() {
        return archive_read_add_passphrase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_add_passphrase(struct archive *, const char *)
     * }
     */
    public static int archive_read_add_passphrase(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_add_passphrase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_add_passphrase", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_set_passphrase_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_set_passphrase_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_set_passphrase_callback(struct archive *, void *client_data, archive_passphrase_callback *)
     * }
     */
    public static FunctionDescriptor archive_read_set_passphrase_callback$descriptor() {
        return archive_read_set_passphrase_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_set_passphrase_callback(struct archive *, void *client_data, archive_passphrase_callback *)
     * }
     */
    public static MethodHandle archive_read_set_passphrase_callback$handle() {
        return archive_read_set_passphrase_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_set_passphrase_callback(struct archive *, void *client_data, archive_passphrase_callback *)
     * }
     */
    public static MemorySegment archive_read_set_passphrase_callback$address() {
        return archive_read_set_passphrase_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_set_passphrase_callback(struct archive *, void *client_data, archive_passphrase_callback *)
     * }
     */
    public static int archive_read_set_passphrase_callback(MemorySegment x0, MemorySegment client_data, MemorySegment x2) {
        var mh$ = archive_read_set_passphrase_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_set_passphrase_callback", x0, client_data, x2);
            }
            return (int)mh$.invokeExact(x0, client_data, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_extract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_extract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_extract(struct archive *, struct archive_entry *, int flags)
     * }
     */
    public static FunctionDescriptor archive_read_extract$descriptor() {
        return archive_read_extract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_extract(struct archive *, struct archive_entry *, int flags)
     * }
     */
    public static MethodHandle archive_read_extract$handle() {
        return archive_read_extract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_extract(struct archive *, struct archive_entry *, int flags)
     * }
     */
    public static MemorySegment archive_read_extract$address() {
        return archive_read_extract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_extract(struct archive *, struct archive_entry *, int flags)
     * }
     */
    public static int archive_read_extract(MemorySegment x0, MemorySegment x1, int flags) {
        var mh$ = archive_read_extract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_extract", x0, x1, flags);
            }
            return (int)mh$.invokeExact(x0, x1, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_extract2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_extract2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_extract2(struct archive *, struct archive_entry *, struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_extract2$descriptor() {
        return archive_read_extract2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_extract2(struct archive *, struct archive_entry *, struct archive *)
     * }
     */
    public static MethodHandle archive_read_extract2$handle() {
        return archive_read_extract2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_extract2(struct archive *, struct archive_entry *, struct archive *)
     * }
     */
    public static MemorySegment archive_read_extract2$address() {
        return archive_read_extract2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_extract2(struct archive *, struct archive_entry *, struct archive *)
     * }
     */
    public static int archive_read_extract2(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = archive_read_extract2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_extract2", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_extract_set_progress_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_extract_set_progress_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_read_extract_set_progress_callback(struct archive *, void (*_progress_func)(void *), void *_user_data)
     * }
     */
    public static FunctionDescriptor archive_read_extract_set_progress_callback$descriptor() {
        return archive_read_extract_set_progress_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_read_extract_set_progress_callback(struct archive *, void (*_progress_func)(void *), void *_user_data)
     * }
     */
    public static MethodHandle archive_read_extract_set_progress_callback$handle() {
        return archive_read_extract_set_progress_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_read_extract_set_progress_callback(struct archive *, void (*_progress_func)(void *), void *_user_data)
     * }
     */
    public static MemorySegment archive_read_extract_set_progress_callback$address() {
        return archive_read_extract_set_progress_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_read_extract_set_progress_callback(struct archive *, void (*_progress_func)(void *), void *_user_data)
     * }
     */
    public static void archive_read_extract_set_progress_callback(MemorySegment x0, MemorySegment _progress_func, MemorySegment _user_data) {
        var mh$ = archive_read_extract_set_progress_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_extract_set_progress_callback", x0, _progress_func, _user_data);
            }
            mh$.invokeExact(x0, _progress_func, _user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_extract_set_skip_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_extract_set_skip_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_read_extract_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_read_extract_set_skip_file$descriptor() {
        return archive_read_extract_set_skip_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_read_extract_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static MethodHandle archive_read_extract_set_skip_file$handle() {
        return archive_read_extract_set_skip_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_read_extract_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static MemorySegment archive_read_extract_set_skip_file$address() {
        return archive_read_extract_set_skip_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_read_extract_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static void archive_read_extract_set_skip_file(MemorySegment x0, long x1, long x2) {
        var mh$ = archive_read_extract_set_skip_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_extract_set_skip_file", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_close(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_close$descriptor() {
        return archive_read_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_close(struct archive *)
     * }
     */
    public static MethodHandle archive_read_close$handle() {
        return archive_read_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_close(struct archive *)
     * }
     */
    public static MemorySegment archive_read_close$address() {
        return archive_read_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_close(struct archive *)
     * }
     */
    public static int archive_read_close(MemorySegment x0) {
        var mh$ = archive_read_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_close", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_free(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_free$descriptor() {
        return archive_read_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_free(struct archive *)
     * }
     */
    public static MethodHandle archive_read_free$handle() {
        return archive_read_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_free(struct archive *)
     * }
     */
    public static MemorySegment archive_read_free$address() {
        return archive_read_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_free(struct archive *)
     * }
     */
    public static int archive_read_free(MemorySegment x0) {
        var mh$ = archive_read_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_free", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_finish(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_finish$descriptor() {
        return archive_read_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_finish(struct archive *)
     * }
     */
    public static MethodHandle archive_read_finish$handle() {
        return archive_read_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_finish(struct archive *)
     * }
     */
    public static MemorySegment archive_read_finish$address() {
        return archive_read_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_finish(struct archive *)
     * }
     */
    public static int archive_read_finish(MemorySegment x0) {
        var mh$ = archive_read_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_finish", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive *archive_write_new()
     * }
     */
    public static FunctionDescriptor archive_write_new$descriptor() {
        return archive_write_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive *archive_write_new()
     * }
     */
    public static MethodHandle archive_write_new$handle() {
        return archive_write_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive *archive_write_new()
     * }
     */
    public static MemorySegment archive_write_new$address() {
        return archive_write_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive *archive_write_new()
     * }
     */
    public static MemorySegment archive_write_new() {
        var mh$ = archive_write_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_bytes_per_block {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_bytes_per_block");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_bytes_per_block(struct archive *, int bytes_per_block)
     * }
     */
    public static FunctionDescriptor archive_write_set_bytes_per_block$descriptor() {
        return archive_write_set_bytes_per_block.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_bytes_per_block(struct archive *, int bytes_per_block)
     * }
     */
    public static MethodHandle archive_write_set_bytes_per_block$handle() {
        return archive_write_set_bytes_per_block.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_bytes_per_block(struct archive *, int bytes_per_block)
     * }
     */
    public static MemorySegment archive_write_set_bytes_per_block$address() {
        return archive_write_set_bytes_per_block.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_bytes_per_block(struct archive *, int bytes_per_block)
     * }
     */
    public static int archive_write_set_bytes_per_block(MemorySegment x0, int bytes_per_block) {
        var mh$ = archive_write_set_bytes_per_block.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_bytes_per_block", x0, bytes_per_block);
            }
            return (int)mh$.invokeExact(x0, bytes_per_block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_get_bytes_per_block {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_get_bytes_per_block");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_get_bytes_per_block(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_get_bytes_per_block$descriptor() {
        return archive_write_get_bytes_per_block.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_get_bytes_per_block(struct archive *)
     * }
     */
    public static MethodHandle archive_write_get_bytes_per_block$handle() {
        return archive_write_get_bytes_per_block.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_get_bytes_per_block(struct archive *)
     * }
     */
    public static MemorySegment archive_write_get_bytes_per_block$address() {
        return archive_write_get_bytes_per_block.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_get_bytes_per_block(struct archive *)
     * }
     */
    public static int archive_write_get_bytes_per_block(MemorySegment x0) {
        var mh$ = archive_write_get_bytes_per_block.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_get_bytes_per_block", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_bytes_in_last_block {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_bytes_in_last_block");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_bytes_in_last_block(struct archive *, int bytes_in_last_block)
     * }
     */
    public static FunctionDescriptor archive_write_set_bytes_in_last_block$descriptor() {
        return archive_write_set_bytes_in_last_block.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_bytes_in_last_block(struct archive *, int bytes_in_last_block)
     * }
     */
    public static MethodHandle archive_write_set_bytes_in_last_block$handle() {
        return archive_write_set_bytes_in_last_block.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_bytes_in_last_block(struct archive *, int bytes_in_last_block)
     * }
     */
    public static MemorySegment archive_write_set_bytes_in_last_block$address() {
        return archive_write_set_bytes_in_last_block.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_bytes_in_last_block(struct archive *, int bytes_in_last_block)
     * }
     */
    public static int archive_write_set_bytes_in_last_block(MemorySegment x0, int bytes_in_last_block) {
        var mh$ = archive_write_set_bytes_in_last_block.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_bytes_in_last_block", x0, bytes_in_last_block);
            }
            return (int)mh$.invokeExact(x0, bytes_in_last_block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_get_bytes_in_last_block {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_get_bytes_in_last_block");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_get_bytes_in_last_block(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_get_bytes_in_last_block$descriptor() {
        return archive_write_get_bytes_in_last_block.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_get_bytes_in_last_block(struct archive *)
     * }
     */
    public static MethodHandle archive_write_get_bytes_in_last_block$handle() {
        return archive_write_get_bytes_in_last_block.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_get_bytes_in_last_block(struct archive *)
     * }
     */
    public static MemorySegment archive_write_get_bytes_in_last_block$address() {
        return archive_write_get_bytes_in_last_block.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_get_bytes_in_last_block(struct archive *)
     * }
     */
    public static int archive_write_get_bytes_in_last_block(MemorySegment x0) {
        var mh$ = archive_write_get_bytes_in_last_block.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_get_bytes_in_last_block", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_skip_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_skip_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_write_set_skip_file$descriptor() {
        return archive_write_set_skip_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static MethodHandle archive_write_set_skip_file$handle() {
        return archive_write_set_skip_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static MemorySegment archive_write_set_skip_file$address() {
        return archive_write_set_skip_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static int archive_write_set_skip_file(MemorySegment x0, long x1, long x2) {
        var mh$ = archive_write_set_skip_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_skip_file", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_compression_bzip2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_compression_bzip2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_compression_bzip2(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_compression_bzip2$descriptor() {
        return archive_write_set_compression_bzip2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_compression_bzip2(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_compression_bzip2$handle() {
        return archive_write_set_compression_bzip2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_compression_bzip2(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_compression_bzip2$address() {
        return archive_write_set_compression_bzip2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_compression_bzip2(struct archive *)
     * }
     */
    public static int archive_write_set_compression_bzip2(MemorySegment x0) {
        var mh$ = archive_write_set_compression_bzip2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_compression_bzip2", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_compression_compress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_compression_compress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_compression_compress(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_compression_compress$descriptor() {
        return archive_write_set_compression_compress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_compression_compress(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_compression_compress$handle() {
        return archive_write_set_compression_compress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_compression_compress(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_compression_compress$address() {
        return archive_write_set_compression_compress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_compression_compress(struct archive *)
     * }
     */
    public static int archive_write_set_compression_compress(MemorySegment x0) {
        var mh$ = archive_write_set_compression_compress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_compression_compress", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_compression_gzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_compression_gzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_compression_gzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_compression_gzip$descriptor() {
        return archive_write_set_compression_gzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_compression_gzip(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_compression_gzip$handle() {
        return archive_write_set_compression_gzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_compression_gzip(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_compression_gzip$address() {
        return archive_write_set_compression_gzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_compression_gzip(struct archive *)
     * }
     */
    public static int archive_write_set_compression_gzip(MemorySegment x0) {
        var mh$ = archive_write_set_compression_gzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_compression_gzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_compression_lzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_compression_lzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_compression_lzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_compression_lzip$descriptor() {
        return archive_write_set_compression_lzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_compression_lzip(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_compression_lzip$handle() {
        return archive_write_set_compression_lzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_compression_lzip(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_compression_lzip$address() {
        return archive_write_set_compression_lzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_compression_lzip(struct archive *)
     * }
     */
    public static int archive_write_set_compression_lzip(MemorySegment x0) {
        var mh$ = archive_write_set_compression_lzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_compression_lzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_compression_lzma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_compression_lzma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_compression_lzma(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_compression_lzma$descriptor() {
        return archive_write_set_compression_lzma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_compression_lzma(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_compression_lzma$handle() {
        return archive_write_set_compression_lzma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_compression_lzma(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_compression_lzma$address() {
        return archive_write_set_compression_lzma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_compression_lzma(struct archive *)
     * }
     */
    public static int archive_write_set_compression_lzma(MemorySegment x0) {
        var mh$ = archive_write_set_compression_lzma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_compression_lzma", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_compression_none {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_compression_none");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_compression_none(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_compression_none$descriptor() {
        return archive_write_set_compression_none.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_compression_none(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_compression_none$handle() {
        return archive_write_set_compression_none.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_compression_none(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_compression_none$address() {
        return archive_write_set_compression_none.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_compression_none(struct archive *)
     * }
     */
    public static int archive_write_set_compression_none(MemorySegment x0) {
        var mh$ = archive_write_set_compression_none.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_compression_none", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_compression_program {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_compression_program");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_compression_program(struct archive *, const char *cmd)
     * }
     */
    public static FunctionDescriptor archive_write_set_compression_program$descriptor() {
        return archive_write_set_compression_program.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_compression_program(struct archive *, const char *cmd)
     * }
     */
    public static MethodHandle archive_write_set_compression_program$handle() {
        return archive_write_set_compression_program.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_compression_program(struct archive *, const char *cmd)
     * }
     */
    public static MemorySegment archive_write_set_compression_program$address() {
        return archive_write_set_compression_program.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_compression_program(struct archive *, const char *cmd)
     * }
     */
    public static int archive_write_set_compression_program(MemorySegment x0, MemorySegment cmd) {
        var mh$ = archive_write_set_compression_program.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_compression_program", x0, cmd);
            }
            return (int)mh$.invokeExact(x0, cmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_compression_xz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_compression_xz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_compression_xz(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_compression_xz$descriptor() {
        return archive_write_set_compression_xz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_compression_xz(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_compression_xz$handle() {
        return archive_write_set_compression_xz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_compression_xz(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_compression_xz$address() {
        return archive_write_set_compression_xz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_compression_xz(struct archive *)
     * }
     */
    public static int archive_write_set_compression_xz(MemorySegment x0) {
        var mh$ = archive_write_set_compression_xz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_compression_xz", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter(struct archive *, int filter_code)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter$descriptor() {
        return archive_write_add_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter(struct archive *, int filter_code)
     * }
     */
    public static MethodHandle archive_write_add_filter$handle() {
        return archive_write_add_filter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter(struct archive *, int filter_code)
     * }
     */
    public static MemorySegment archive_write_add_filter$address() {
        return archive_write_add_filter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter(struct archive *, int filter_code)
     * }
     */
    public static int archive_write_add_filter(MemorySegment x0, int filter_code) {
        var mh$ = archive_write_add_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter", x0, filter_code);
            }
            return (int)mh$.invokeExact(x0, filter_code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_by_name(struct archive *, const char *name)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_by_name$descriptor() {
        return archive_write_add_filter_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_by_name(struct archive *, const char *name)
     * }
     */
    public static MethodHandle archive_write_add_filter_by_name$handle() {
        return archive_write_add_filter_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_by_name(struct archive *, const char *name)
     * }
     */
    public static MemorySegment archive_write_add_filter_by_name$address() {
        return archive_write_add_filter_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_by_name(struct archive *, const char *name)
     * }
     */
    public static int archive_write_add_filter_by_name(MemorySegment x0, MemorySegment name) {
        var mh$ = archive_write_add_filter_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_by_name", x0, name);
            }
            return (int)mh$.invokeExact(x0, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_b64encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_b64encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_b64encode(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_b64encode$descriptor() {
        return archive_write_add_filter_b64encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_b64encode(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_b64encode$handle() {
        return archive_write_add_filter_b64encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_b64encode(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_b64encode$address() {
        return archive_write_add_filter_b64encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_b64encode(struct archive *)
     * }
     */
    public static int archive_write_add_filter_b64encode(MemorySegment x0) {
        var mh$ = archive_write_add_filter_b64encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_b64encode", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_bzip2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_bzip2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_bzip2(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_bzip2$descriptor() {
        return archive_write_add_filter_bzip2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_bzip2(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_bzip2$handle() {
        return archive_write_add_filter_bzip2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_bzip2(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_bzip2$address() {
        return archive_write_add_filter_bzip2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_bzip2(struct archive *)
     * }
     */
    public static int archive_write_add_filter_bzip2(MemorySegment x0) {
        var mh$ = archive_write_add_filter_bzip2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_bzip2", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_compress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_compress");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_compress(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_compress$descriptor() {
        return archive_write_add_filter_compress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_compress(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_compress$handle() {
        return archive_write_add_filter_compress.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_compress(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_compress$address() {
        return archive_write_add_filter_compress.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_compress(struct archive *)
     * }
     */
    public static int archive_write_add_filter_compress(MemorySegment x0) {
        var mh$ = archive_write_add_filter_compress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_compress", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_grzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_grzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_grzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_grzip$descriptor() {
        return archive_write_add_filter_grzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_grzip(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_grzip$handle() {
        return archive_write_add_filter_grzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_grzip(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_grzip$address() {
        return archive_write_add_filter_grzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_grzip(struct archive *)
     * }
     */
    public static int archive_write_add_filter_grzip(MemorySegment x0) {
        var mh$ = archive_write_add_filter_grzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_grzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_gzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_gzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_gzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_gzip$descriptor() {
        return archive_write_add_filter_gzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_gzip(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_gzip$handle() {
        return archive_write_add_filter_gzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_gzip(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_gzip$address() {
        return archive_write_add_filter_gzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_gzip(struct archive *)
     * }
     */
    public static int archive_write_add_filter_gzip(MemorySegment x0) {
        var mh$ = archive_write_add_filter_gzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_gzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_lrzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_lrzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lrzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_lrzip$descriptor() {
        return archive_write_add_filter_lrzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lrzip(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_lrzip$handle() {
        return archive_write_add_filter_lrzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lrzip(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_lrzip$address() {
        return archive_write_add_filter_lrzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_lrzip(struct archive *)
     * }
     */
    public static int archive_write_add_filter_lrzip(MemorySegment x0) {
        var mh$ = archive_write_add_filter_lrzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_lrzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_lz4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_lz4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lz4(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_lz4$descriptor() {
        return archive_write_add_filter_lz4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lz4(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_lz4$handle() {
        return archive_write_add_filter_lz4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lz4(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_lz4$address() {
        return archive_write_add_filter_lz4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_lz4(struct archive *)
     * }
     */
    public static int archive_write_add_filter_lz4(MemorySegment x0) {
        var mh$ = archive_write_add_filter_lz4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_lz4", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_lzip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_lzip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lzip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_lzip$descriptor() {
        return archive_write_add_filter_lzip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lzip(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_lzip$handle() {
        return archive_write_add_filter_lzip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lzip(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_lzip$address() {
        return archive_write_add_filter_lzip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_lzip(struct archive *)
     * }
     */
    public static int archive_write_add_filter_lzip(MemorySegment x0) {
        var mh$ = archive_write_add_filter_lzip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_lzip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_lzma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_lzma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lzma(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_lzma$descriptor() {
        return archive_write_add_filter_lzma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lzma(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_lzma$handle() {
        return archive_write_add_filter_lzma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lzma(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_lzma$address() {
        return archive_write_add_filter_lzma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_lzma(struct archive *)
     * }
     */
    public static int archive_write_add_filter_lzma(MemorySegment x0) {
        var mh$ = archive_write_add_filter_lzma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_lzma", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_lzop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_lzop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lzop(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_lzop$descriptor() {
        return archive_write_add_filter_lzop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lzop(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_lzop$handle() {
        return archive_write_add_filter_lzop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_lzop(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_lzop$address() {
        return archive_write_add_filter_lzop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_lzop(struct archive *)
     * }
     */
    public static int archive_write_add_filter_lzop(MemorySegment x0) {
        var mh$ = archive_write_add_filter_lzop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_lzop", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_none {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_none");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_none(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_none$descriptor() {
        return archive_write_add_filter_none.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_none(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_none$handle() {
        return archive_write_add_filter_none.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_none(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_none$address() {
        return archive_write_add_filter_none.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_none(struct archive *)
     * }
     */
    public static int archive_write_add_filter_none(MemorySegment x0) {
        var mh$ = archive_write_add_filter_none.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_none", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_program {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_program");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_program(struct archive *, const char *cmd)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_program$descriptor() {
        return archive_write_add_filter_program.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_program(struct archive *, const char *cmd)
     * }
     */
    public static MethodHandle archive_write_add_filter_program$handle() {
        return archive_write_add_filter_program.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_program(struct archive *, const char *cmd)
     * }
     */
    public static MemorySegment archive_write_add_filter_program$address() {
        return archive_write_add_filter_program.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_program(struct archive *, const char *cmd)
     * }
     */
    public static int archive_write_add_filter_program(MemorySegment x0, MemorySegment cmd) {
        var mh$ = archive_write_add_filter_program.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_program", x0, cmd);
            }
            return (int)mh$.invokeExact(x0, cmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_uuencode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_uuencode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_uuencode(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_uuencode$descriptor() {
        return archive_write_add_filter_uuencode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_uuencode(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_uuencode$handle() {
        return archive_write_add_filter_uuencode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_uuencode(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_uuencode$address() {
        return archive_write_add_filter_uuencode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_uuencode(struct archive *)
     * }
     */
    public static int archive_write_add_filter_uuencode(MemorySegment x0) {
        var mh$ = archive_write_add_filter_uuencode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_uuencode", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_xz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_xz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_xz(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_xz$descriptor() {
        return archive_write_add_filter_xz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_xz(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_xz$handle() {
        return archive_write_add_filter_xz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_xz(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_xz$address() {
        return archive_write_add_filter_xz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_xz(struct archive *)
     * }
     */
    public static int archive_write_add_filter_xz(MemorySegment x0) {
        var mh$ = archive_write_add_filter_xz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_xz", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_add_filter_zstd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_add_filter_zstd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_add_filter_zstd(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_add_filter_zstd$descriptor() {
        return archive_write_add_filter_zstd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_add_filter_zstd(struct archive *)
     * }
     */
    public static MethodHandle archive_write_add_filter_zstd$handle() {
        return archive_write_add_filter_zstd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_add_filter_zstd(struct archive *)
     * }
     */
    public static MemorySegment archive_write_add_filter_zstd$address() {
        return archive_write_add_filter_zstd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_add_filter_zstd(struct archive *)
     * }
     */
    public static int archive_write_add_filter_zstd(MemorySegment x0) {
        var mh$ = archive_write_add_filter_zstd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_add_filter_zstd", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format(struct archive *, int format_code)
     * }
     */
    public static FunctionDescriptor archive_write_set_format$descriptor() {
        return archive_write_set_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format(struct archive *, int format_code)
     * }
     */
    public static MethodHandle archive_write_set_format$handle() {
        return archive_write_set_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format(struct archive *, int format_code)
     * }
     */
    public static MemorySegment archive_write_set_format$address() {
        return archive_write_set_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format(struct archive *, int format_code)
     * }
     */
    public static int archive_write_set_format(MemorySegment x0, int format_code) {
        var mh$ = archive_write_set_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format", x0, format_code);
            }
            return (int)mh$.invokeExact(x0, format_code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_by_name(struct archive *, const char *name)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_by_name$descriptor() {
        return archive_write_set_format_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_by_name(struct archive *, const char *name)
     * }
     */
    public static MethodHandle archive_write_set_format_by_name$handle() {
        return archive_write_set_format_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_by_name(struct archive *, const char *name)
     * }
     */
    public static MemorySegment archive_write_set_format_by_name$address() {
        return archive_write_set_format_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_by_name(struct archive *, const char *name)
     * }
     */
    public static int archive_write_set_format_by_name(MemorySegment x0, MemorySegment name) {
        var mh$ = archive_write_set_format_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_by_name", x0, name);
            }
            return (int)mh$.invokeExact(x0, name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_7zip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_7zip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_7zip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_7zip$descriptor() {
        return archive_write_set_format_7zip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_7zip(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_7zip$handle() {
        return archive_write_set_format_7zip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_7zip(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_7zip$address() {
        return archive_write_set_format_7zip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_7zip(struct archive *)
     * }
     */
    public static int archive_write_set_format_7zip(MemorySegment x0) {
        var mh$ = archive_write_set_format_7zip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_7zip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_ar_bsd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_ar_bsd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_ar_bsd(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_ar_bsd$descriptor() {
        return archive_write_set_format_ar_bsd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_ar_bsd(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_ar_bsd$handle() {
        return archive_write_set_format_ar_bsd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_ar_bsd(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_ar_bsd$address() {
        return archive_write_set_format_ar_bsd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_ar_bsd(struct archive *)
     * }
     */
    public static int archive_write_set_format_ar_bsd(MemorySegment x0) {
        var mh$ = archive_write_set_format_ar_bsd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_ar_bsd", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_ar_svr4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_ar_svr4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_ar_svr4(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_ar_svr4$descriptor() {
        return archive_write_set_format_ar_svr4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_ar_svr4(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_ar_svr4$handle() {
        return archive_write_set_format_ar_svr4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_ar_svr4(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_ar_svr4$address() {
        return archive_write_set_format_ar_svr4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_ar_svr4(struct archive *)
     * }
     */
    public static int archive_write_set_format_ar_svr4(MemorySegment x0) {
        var mh$ = archive_write_set_format_ar_svr4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_ar_svr4", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_cpio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_cpio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_cpio(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_cpio$descriptor() {
        return archive_write_set_format_cpio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_cpio(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_cpio$handle() {
        return archive_write_set_format_cpio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_cpio(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_cpio$address() {
        return archive_write_set_format_cpio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_cpio(struct archive *)
     * }
     */
    public static int archive_write_set_format_cpio(MemorySegment x0) {
        var mh$ = archive_write_set_format_cpio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_cpio", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_cpio_newc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_cpio_newc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_cpio_newc(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_cpio_newc$descriptor() {
        return archive_write_set_format_cpio_newc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_cpio_newc(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_cpio_newc$handle() {
        return archive_write_set_format_cpio_newc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_cpio_newc(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_cpio_newc$address() {
        return archive_write_set_format_cpio_newc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_cpio_newc(struct archive *)
     * }
     */
    public static int archive_write_set_format_cpio_newc(MemorySegment x0) {
        var mh$ = archive_write_set_format_cpio_newc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_cpio_newc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_gnutar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_gnutar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_gnutar(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_gnutar$descriptor() {
        return archive_write_set_format_gnutar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_gnutar(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_gnutar$handle() {
        return archive_write_set_format_gnutar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_gnutar(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_gnutar$address() {
        return archive_write_set_format_gnutar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_gnutar(struct archive *)
     * }
     */
    public static int archive_write_set_format_gnutar(MemorySegment x0) {
        var mh$ = archive_write_set_format_gnutar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_gnutar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_iso9660 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_iso9660");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_iso9660(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_iso9660$descriptor() {
        return archive_write_set_format_iso9660.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_iso9660(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_iso9660$handle() {
        return archive_write_set_format_iso9660.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_iso9660(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_iso9660$address() {
        return archive_write_set_format_iso9660.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_iso9660(struct archive *)
     * }
     */
    public static int archive_write_set_format_iso9660(MemorySegment x0) {
        var mh$ = archive_write_set_format_iso9660.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_iso9660", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_mtree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_mtree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_mtree(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_mtree$descriptor() {
        return archive_write_set_format_mtree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_mtree(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_mtree$handle() {
        return archive_write_set_format_mtree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_mtree(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_mtree$address() {
        return archive_write_set_format_mtree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_mtree(struct archive *)
     * }
     */
    public static int archive_write_set_format_mtree(MemorySegment x0) {
        var mh$ = archive_write_set_format_mtree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_mtree", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_mtree_classic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_mtree_classic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_mtree_classic(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_mtree_classic$descriptor() {
        return archive_write_set_format_mtree_classic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_mtree_classic(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_mtree_classic$handle() {
        return archive_write_set_format_mtree_classic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_mtree_classic(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_mtree_classic$address() {
        return archive_write_set_format_mtree_classic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_mtree_classic(struct archive *)
     * }
     */
    public static int archive_write_set_format_mtree_classic(MemorySegment x0) {
        var mh$ = archive_write_set_format_mtree_classic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_mtree_classic", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_pax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_pax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_pax(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_pax$descriptor() {
        return archive_write_set_format_pax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_pax(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_pax$handle() {
        return archive_write_set_format_pax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_pax(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_pax$address() {
        return archive_write_set_format_pax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_pax(struct archive *)
     * }
     */
    public static int archive_write_set_format_pax(MemorySegment x0) {
        var mh$ = archive_write_set_format_pax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_pax", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_pax_restricted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_pax_restricted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_pax_restricted(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_pax_restricted$descriptor() {
        return archive_write_set_format_pax_restricted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_pax_restricted(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_pax_restricted$handle() {
        return archive_write_set_format_pax_restricted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_pax_restricted(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_pax_restricted$address() {
        return archive_write_set_format_pax_restricted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_pax_restricted(struct archive *)
     * }
     */
    public static int archive_write_set_format_pax_restricted(MemorySegment x0) {
        var mh$ = archive_write_set_format_pax_restricted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_pax_restricted", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_raw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_raw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_raw(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_raw$descriptor() {
        return archive_write_set_format_raw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_raw(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_raw$handle() {
        return archive_write_set_format_raw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_raw(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_raw$address() {
        return archive_write_set_format_raw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_raw(struct archive *)
     * }
     */
    public static int archive_write_set_format_raw(MemorySegment x0) {
        var mh$ = archive_write_set_format_raw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_raw", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_shar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_shar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_shar(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_shar$descriptor() {
        return archive_write_set_format_shar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_shar(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_shar$handle() {
        return archive_write_set_format_shar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_shar(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_shar$address() {
        return archive_write_set_format_shar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_shar(struct archive *)
     * }
     */
    public static int archive_write_set_format_shar(MemorySegment x0) {
        var mh$ = archive_write_set_format_shar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_shar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_shar_dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_shar_dump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_shar_dump(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_shar_dump$descriptor() {
        return archive_write_set_format_shar_dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_shar_dump(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_shar_dump$handle() {
        return archive_write_set_format_shar_dump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_shar_dump(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_shar_dump$address() {
        return archive_write_set_format_shar_dump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_shar_dump(struct archive *)
     * }
     */
    public static int archive_write_set_format_shar_dump(MemorySegment x0) {
        var mh$ = archive_write_set_format_shar_dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_shar_dump", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_ustar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_ustar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_ustar(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_ustar$descriptor() {
        return archive_write_set_format_ustar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_ustar(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_ustar$handle() {
        return archive_write_set_format_ustar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_ustar(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_ustar$address() {
        return archive_write_set_format_ustar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_ustar(struct archive *)
     * }
     */
    public static int archive_write_set_format_ustar(MemorySegment x0) {
        var mh$ = archive_write_set_format_ustar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_ustar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_v7tar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_v7tar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_v7tar(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_v7tar$descriptor() {
        return archive_write_set_format_v7tar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_v7tar(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_v7tar$handle() {
        return archive_write_set_format_v7tar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_v7tar(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_v7tar$address() {
        return archive_write_set_format_v7tar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_v7tar(struct archive *)
     * }
     */
    public static int archive_write_set_format_v7tar(MemorySegment x0) {
        var mh$ = archive_write_set_format_v7tar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_v7tar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_warc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_warc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_warc(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_warc$descriptor() {
        return archive_write_set_format_warc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_warc(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_warc$handle() {
        return archive_write_set_format_warc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_warc(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_warc$address() {
        return archive_write_set_format_warc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_warc(struct archive *)
     * }
     */
    public static int archive_write_set_format_warc(MemorySegment x0) {
        var mh$ = archive_write_set_format_warc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_warc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_xar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_xar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_xar(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_xar$descriptor() {
        return archive_write_set_format_xar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_xar(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_xar$handle() {
        return archive_write_set_format_xar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_xar(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_xar$address() {
        return archive_write_set_format_xar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_xar(struct archive *)
     * }
     */
    public static int archive_write_set_format_xar(MemorySegment x0) {
        var mh$ = archive_write_set_format_xar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_xar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_zip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_zip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_zip(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_zip$descriptor() {
        return archive_write_set_format_zip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_zip(struct archive *)
     * }
     */
    public static MethodHandle archive_write_set_format_zip$handle() {
        return archive_write_set_format_zip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_zip(struct archive *)
     * }
     */
    public static MemorySegment archive_write_set_format_zip$address() {
        return archive_write_set_format_zip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_zip(struct archive *)
     * }
     */
    public static int archive_write_set_format_zip(MemorySegment x0) {
        var mh$ = archive_write_set_format_zip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_zip", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_filter_by_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_filter_by_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_filter_by_ext(struct archive *a, const char *filename)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_filter_by_ext$descriptor() {
        return archive_write_set_format_filter_by_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_filter_by_ext(struct archive *a, const char *filename)
     * }
     */
    public static MethodHandle archive_write_set_format_filter_by_ext$handle() {
        return archive_write_set_format_filter_by_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_filter_by_ext(struct archive *a, const char *filename)
     * }
     */
    public static MemorySegment archive_write_set_format_filter_by_ext$address() {
        return archive_write_set_format_filter_by_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_filter_by_ext(struct archive *a, const char *filename)
     * }
     */
    public static int archive_write_set_format_filter_by_ext(MemorySegment a, MemorySegment filename) {
        var mh$ = archive_write_set_format_filter_by_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_filter_by_ext", a, filename);
            }
            return (int)mh$.invokeExact(a, filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_filter_by_ext_def {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_filter_by_ext_def");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_filter_by_ext_def(struct archive *a, const char *filename, const char *def_ext)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_filter_by_ext_def$descriptor() {
        return archive_write_set_format_filter_by_ext_def.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_filter_by_ext_def(struct archive *a, const char *filename, const char *def_ext)
     * }
     */
    public static MethodHandle archive_write_set_format_filter_by_ext_def$handle() {
        return archive_write_set_format_filter_by_ext_def.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_filter_by_ext_def(struct archive *a, const char *filename, const char *def_ext)
     * }
     */
    public static MemorySegment archive_write_set_format_filter_by_ext_def$address() {
        return archive_write_set_format_filter_by_ext_def.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_filter_by_ext_def(struct archive *a, const char *filename, const char *def_ext)
     * }
     */
    public static int archive_write_set_format_filter_by_ext_def(MemorySegment a, MemorySegment filename, MemorySegment def_ext) {
        var mh$ = archive_write_set_format_filter_by_ext_def.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_filter_by_ext_def", a, filename, def_ext);
            }
            return (int)mh$.invokeExact(a, filename, def_ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_zip_set_compression_deflate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_zip_set_compression_deflate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_zip_set_compression_deflate(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_zip_set_compression_deflate$descriptor() {
        return archive_write_zip_set_compression_deflate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_zip_set_compression_deflate(struct archive *)
     * }
     */
    public static MethodHandle archive_write_zip_set_compression_deflate$handle() {
        return archive_write_zip_set_compression_deflate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_zip_set_compression_deflate(struct archive *)
     * }
     */
    public static MemorySegment archive_write_zip_set_compression_deflate$address() {
        return archive_write_zip_set_compression_deflate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_zip_set_compression_deflate(struct archive *)
     * }
     */
    public static int archive_write_zip_set_compression_deflate(MemorySegment x0) {
        var mh$ = archive_write_zip_set_compression_deflate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_zip_set_compression_deflate", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_zip_set_compression_store {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_zip_set_compression_store");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_zip_set_compression_store(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_zip_set_compression_store$descriptor() {
        return archive_write_zip_set_compression_store.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_zip_set_compression_store(struct archive *)
     * }
     */
    public static MethodHandle archive_write_zip_set_compression_store$handle() {
        return archive_write_zip_set_compression_store.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_zip_set_compression_store(struct archive *)
     * }
     */
    public static MemorySegment archive_write_zip_set_compression_store$address() {
        return archive_write_zip_set_compression_store.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_zip_set_compression_store(struct archive *)
     * }
     */
    public static int archive_write_zip_set_compression_store(MemorySegment x0) {
        var mh$ = archive_write_zip_set_compression_store.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_zip_set_compression_store", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_open(struct archive *, void *, archive_open_callback *, archive_write_callback *, archive_close_callback *)
     * }
     */
    public static FunctionDescriptor archive_write_open$descriptor() {
        return archive_write_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_open(struct archive *, void *, archive_open_callback *, archive_write_callback *, archive_close_callback *)
     * }
     */
    public static MethodHandle archive_write_open$handle() {
        return archive_write_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_open(struct archive *, void *, archive_open_callback *, archive_write_callback *, archive_close_callback *)
     * }
     */
    public static MemorySegment archive_write_open$address() {
        return archive_write_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_open(struct archive *, void *, archive_open_callback *, archive_write_callback *, archive_close_callback *)
     * }
     */
    public static int archive_write_open(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = archive_write_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_open", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_open2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_open2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_open2(struct archive *, void *, archive_open_callback *, archive_write_callback *, archive_close_callback *, archive_free_callback *)
     * }
     */
    public static FunctionDescriptor archive_write_open2$descriptor() {
        return archive_write_open2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_open2(struct archive *, void *, archive_open_callback *, archive_write_callback *, archive_close_callback *, archive_free_callback *)
     * }
     */
    public static MethodHandle archive_write_open2$handle() {
        return archive_write_open2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_open2(struct archive *, void *, archive_open_callback *, archive_write_callback *, archive_close_callback *, archive_free_callback *)
     * }
     */
    public static MemorySegment archive_write_open2$address() {
        return archive_write_open2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_open2(struct archive *, void *, archive_open_callback *, archive_write_callback *, archive_close_callback *, archive_free_callback *)
     * }
     */
    public static int archive_write_open2(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = archive_write_open2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_open2", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_open_fd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_open_fd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_open_fd(struct archive *, int _fd)
     * }
     */
    public static FunctionDescriptor archive_write_open_fd$descriptor() {
        return archive_write_open_fd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_open_fd(struct archive *, int _fd)
     * }
     */
    public static MethodHandle archive_write_open_fd$handle() {
        return archive_write_open_fd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_open_fd(struct archive *, int _fd)
     * }
     */
    public static MemorySegment archive_write_open_fd$address() {
        return archive_write_open_fd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_open_fd(struct archive *, int _fd)
     * }
     */
    public static int archive_write_open_fd(MemorySegment x0, int _fd) {
        var mh$ = archive_write_open_fd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_open_fd", x0, _fd);
            }
            return (int)mh$.invokeExact(x0, _fd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_open_filename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_open_filename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_open_filename(struct archive *, const char *_file)
     * }
     */
    public static FunctionDescriptor archive_write_open_filename$descriptor() {
        return archive_write_open_filename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_open_filename(struct archive *, const char *_file)
     * }
     */
    public static MethodHandle archive_write_open_filename$handle() {
        return archive_write_open_filename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_open_filename(struct archive *, const char *_file)
     * }
     */
    public static MemorySegment archive_write_open_filename$address() {
        return archive_write_open_filename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_open_filename(struct archive *, const char *_file)
     * }
     */
    public static int archive_write_open_filename(MemorySegment x0, MemorySegment _file) {
        var mh$ = archive_write_open_filename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_open_filename", x0, _file);
            }
            return (int)mh$.invokeExact(x0, _file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_open_filename_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_open_filename_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_open_filename_w(struct archive *, const wchar_t *_file)
     * }
     */
    public static FunctionDescriptor archive_write_open_filename_w$descriptor() {
        return archive_write_open_filename_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_open_filename_w(struct archive *, const wchar_t *_file)
     * }
     */
    public static MethodHandle archive_write_open_filename_w$handle() {
        return archive_write_open_filename_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_open_filename_w(struct archive *, const wchar_t *_file)
     * }
     */
    public static MemorySegment archive_write_open_filename_w$address() {
        return archive_write_open_filename_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_open_filename_w(struct archive *, const wchar_t *_file)
     * }
     */
    public static int archive_write_open_filename_w(MemorySegment x0, MemorySegment _file) {
        var mh$ = archive_write_open_filename_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_open_filename_w", x0, _file);
            }
            return (int)mh$.invokeExact(x0, _file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_open_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_open_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_open_file(struct archive *, const char *_file)
     * }
     */
    public static FunctionDescriptor archive_write_open_file$descriptor() {
        return archive_write_open_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_open_file(struct archive *, const char *_file)
     * }
     */
    public static MethodHandle archive_write_open_file$handle() {
        return archive_write_open_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_open_file(struct archive *, const char *_file)
     * }
     */
    public static MemorySegment archive_write_open_file$address() {
        return archive_write_open_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_open_file(struct archive *, const char *_file)
     * }
     */
    public static int archive_write_open_file(MemorySegment x0, MemorySegment _file) {
        var mh$ = archive_write_open_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_open_file", x0, _file);
            }
            return (int)mh$.invokeExact(x0, _file);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_open_FILE$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_open_FILE");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_open_FILE(struct archive *, FILE *)
     * }
     */
    public static FunctionDescriptor archive_write_open_FILE$descriptor() {
        return archive_write_open_FILE$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_open_FILE(struct archive *, FILE *)
     * }
     */
    public static MethodHandle archive_write_open_FILE$handle() {
        return archive_write_open_FILE$.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_open_FILE(struct archive *, FILE *)
     * }
     */
    public static MemorySegment archive_write_open_FILE$address() {
        return archive_write_open_FILE$.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_open_FILE(struct archive *, FILE *)
     * }
     */
    public static int archive_write_open_FILE(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_write_open_FILE$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_open_FILE", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_open_memory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_open_memory");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_open_memory(struct archive *, void *_buffer, size_t _buffSize, size_t *_used)
     * }
     */
    public static FunctionDescriptor archive_write_open_memory$descriptor() {
        return archive_write_open_memory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_open_memory(struct archive *, void *_buffer, size_t _buffSize, size_t *_used)
     * }
     */
    public static MethodHandle archive_write_open_memory$handle() {
        return archive_write_open_memory.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_open_memory(struct archive *, void *_buffer, size_t _buffSize, size_t *_used)
     * }
     */
    public static MemorySegment archive_write_open_memory$address() {
        return archive_write_open_memory.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_open_memory(struct archive *, void *_buffer, size_t _buffSize, size_t *_used)
     * }
     */
    public static int archive_write_open_memory(MemorySegment x0, MemorySegment _buffer, long _buffSize, MemorySegment _used) {
        var mh$ = archive_write_open_memory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_open_memory", x0, _buffer, _buffSize, _used);
            }
            return (int)mh$.invokeExact(x0, _buffer, _buffSize, _used);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_header {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_header");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_header(struct archive *, struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_write_header$descriptor() {
        return archive_write_header.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_header(struct archive *, struct archive_entry *)
     * }
     */
    public static MethodHandle archive_write_header$handle() {
        return archive_write_header.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_header(struct archive *, struct archive_entry *)
     * }
     */
    public static MemorySegment archive_write_header$address() {
        return archive_write_header.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_header(struct archive *, struct archive_entry *)
     * }
     */
    public static int archive_write_header(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_write_header.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_header", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_ssize_t archive_write_data(struct archive *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor archive_write_data$descriptor() {
        return archive_write_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_ssize_t archive_write_data(struct archive *, const void *, size_t)
     * }
     */
    public static MethodHandle archive_write_data$handle() {
        return archive_write_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_ssize_t archive_write_data(struct archive *, const void *, size_t)
     * }
     */
    public static MemorySegment archive_write_data$address() {
        return archive_write_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_ssize_t archive_write_data(struct archive *, const void *, size_t)
     * }
     */
    public static long archive_write_data(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = archive_write_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_data", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_data_block {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_data_block");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_ssize_t archive_write_data_block(struct archive *, const void *, size_t, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_write_data_block$descriptor() {
        return archive_write_data_block.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_ssize_t archive_write_data_block(struct archive *, const void *, size_t, la_int64_t)
     * }
     */
    public static MethodHandle archive_write_data_block$handle() {
        return archive_write_data_block.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_ssize_t archive_write_data_block(struct archive *, const void *, size_t, la_int64_t)
     * }
     */
    public static MemorySegment archive_write_data_block$address() {
        return archive_write_data_block.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_ssize_t archive_write_data_block(struct archive *, const void *, size_t, la_int64_t)
     * }
     */
    public static long archive_write_data_block(MemorySegment x0, MemorySegment x1, long x2, long x3) {
        var mh$ = archive_write_data_block.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_data_block", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_finish_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_finish_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_finish_entry(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_finish_entry$descriptor() {
        return archive_write_finish_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_finish_entry(struct archive *)
     * }
     */
    public static MethodHandle archive_write_finish_entry$handle() {
        return archive_write_finish_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_finish_entry(struct archive *)
     * }
     */
    public static MemorySegment archive_write_finish_entry$address() {
        return archive_write_finish_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_finish_entry(struct archive *)
     * }
     */
    public static int archive_write_finish_entry(MemorySegment x0) {
        var mh$ = archive_write_finish_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_finish_entry", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_close(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_close$descriptor() {
        return archive_write_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_close(struct archive *)
     * }
     */
    public static MethodHandle archive_write_close$handle() {
        return archive_write_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_close(struct archive *)
     * }
     */
    public static MemorySegment archive_write_close$address() {
        return archive_write_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_close(struct archive *)
     * }
     */
    public static int archive_write_close(MemorySegment x0) {
        var mh$ = archive_write_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_close", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_fail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_fail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_fail(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_fail$descriptor() {
        return archive_write_fail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_fail(struct archive *)
     * }
     */
    public static MethodHandle archive_write_fail$handle() {
        return archive_write_fail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_fail(struct archive *)
     * }
     */
    public static MemorySegment archive_write_fail$address() {
        return archive_write_fail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_fail(struct archive *)
     * }
     */
    public static int archive_write_fail(MemorySegment x0) {
        var mh$ = archive_write_fail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_fail", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_free(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_free$descriptor() {
        return archive_write_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_free(struct archive *)
     * }
     */
    public static MethodHandle archive_write_free$handle() {
        return archive_write_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_free(struct archive *)
     * }
     */
    public static MemorySegment archive_write_free$address() {
        return archive_write_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_free(struct archive *)
     * }
     */
    public static int archive_write_free(MemorySegment x0) {
        var mh$ = archive_write_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_free", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_finish(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_finish$descriptor() {
        return archive_write_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_finish(struct archive *)
     * }
     */
    public static MethodHandle archive_write_finish$handle() {
        return archive_write_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_finish(struct archive *)
     * }
     */
    public static MemorySegment archive_write_finish$address() {
        return archive_write_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_finish(struct archive *)
     * }
     */
    public static int archive_write_finish(MemorySegment x0) {
        var mh$ = archive_write_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_finish", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_format_option {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_format_option");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_format_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static FunctionDescriptor archive_write_set_format_option$descriptor() {
        return archive_write_set_format_option.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_format_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MethodHandle archive_write_set_format_option$handle() {
        return archive_write_set_format_option.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_format_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MemorySegment archive_write_set_format_option$address() {
        return archive_write_set_format_option.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_format_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static int archive_write_set_format_option(MemorySegment _a, MemorySegment m, MemorySegment o, MemorySegment v) {
        var mh$ = archive_write_set_format_option.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_format_option", _a, m, o, v);
            }
            return (int)mh$.invokeExact(_a, m, o, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_filter_option {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_filter_option");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_filter_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static FunctionDescriptor archive_write_set_filter_option$descriptor() {
        return archive_write_set_filter_option.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_filter_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MethodHandle archive_write_set_filter_option$handle() {
        return archive_write_set_filter_option.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_filter_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MemorySegment archive_write_set_filter_option$address() {
        return archive_write_set_filter_option.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_filter_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static int archive_write_set_filter_option(MemorySegment _a, MemorySegment m, MemorySegment o, MemorySegment v) {
        var mh$ = archive_write_set_filter_option.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_filter_option", _a, m, o, v);
            }
            return (int)mh$.invokeExact(_a, m, o, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_option {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_option");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static FunctionDescriptor archive_write_set_option$descriptor() {
        return archive_write_set_option.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MethodHandle archive_write_set_option$handle() {
        return archive_write_set_option.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static MemorySegment archive_write_set_option$address() {
        return archive_write_set_option.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_option(struct archive *_a, const char *m, const char *o, const char *v)
     * }
     */
    public static int archive_write_set_option(MemorySegment _a, MemorySegment m, MemorySegment o, MemorySegment v) {
        var mh$ = archive_write_set_option.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_option", _a, m, o, v);
            }
            return (int)mh$.invokeExact(_a, m, o, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_options(struct archive *_a, const char *opts)
     * }
     */
    public static FunctionDescriptor archive_write_set_options$descriptor() {
        return archive_write_set_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_options(struct archive *_a, const char *opts)
     * }
     */
    public static MethodHandle archive_write_set_options$handle() {
        return archive_write_set_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_options(struct archive *_a, const char *opts)
     * }
     */
    public static MemorySegment archive_write_set_options$address() {
        return archive_write_set_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_options(struct archive *_a, const char *opts)
     * }
     */
    public static int archive_write_set_options(MemorySegment _a, MemorySegment opts) {
        var mh$ = archive_write_set_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_options", _a, opts);
            }
            return (int)mh$.invokeExact(_a, opts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_passphrase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_passphrase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_passphrase(struct archive *_a, const char *p)
     * }
     */
    public static FunctionDescriptor archive_write_set_passphrase$descriptor() {
        return archive_write_set_passphrase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_passphrase(struct archive *_a, const char *p)
     * }
     */
    public static MethodHandle archive_write_set_passphrase$handle() {
        return archive_write_set_passphrase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_passphrase(struct archive *_a, const char *p)
     * }
     */
    public static MemorySegment archive_write_set_passphrase$address() {
        return archive_write_set_passphrase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_passphrase(struct archive *_a, const char *p)
     * }
     */
    public static int archive_write_set_passphrase(MemorySegment _a, MemorySegment p) {
        var mh$ = archive_write_set_passphrase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_passphrase", _a, p);
            }
            return (int)mh$.invokeExact(_a, p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_set_passphrase_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_set_passphrase_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_set_passphrase_callback(struct archive *, void *client_data, archive_passphrase_callback *)
     * }
     */
    public static FunctionDescriptor archive_write_set_passphrase_callback$descriptor() {
        return archive_write_set_passphrase_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_set_passphrase_callback(struct archive *, void *client_data, archive_passphrase_callback *)
     * }
     */
    public static MethodHandle archive_write_set_passphrase_callback$handle() {
        return archive_write_set_passphrase_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_set_passphrase_callback(struct archive *, void *client_data, archive_passphrase_callback *)
     * }
     */
    public static MemorySegment archive_write_set_passphrase_callback$address() {
        return archive_write_set_passphrase_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_set_passphrase_callback(struct archive *, void *client_data, archive_passphrase_callback *)
     * }
     */
    public static int archive_write_set_passphrase_callback(MemorySegment x0, MemorySegment client_data, MemorySegment x2) {
        var mh$ = archive_write_set_passphrase_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_set_passphrase_callback", x0, client_data, x2);
            }
            return (int)mh$.invokeExact(x0, client_data, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_disk_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_disk_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive *archive_write_disk_new()
     * }
     */
    public static FunctionDescriptor archive_write_disk_new$descriptor() {
        return archive_write_disk_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive *archive_write_disk_new()
     * }
     */
    public static MethodHandle archive_write_disk_new$handle() {
        return archive_write_disk_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive *archive_write_disk_new()
     * }
     */
    public static MemorySegment archive_write_disk_new$address() {
        return archive_write_disk_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive *archive_write_disk_new()
     * }
     */
    public static MemorySegment archive_write_disk_new() {
        var mh$ = archive_write_disk_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_disk_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_disk_set_skip_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_disk_set_skip_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_disk_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_write_disk_set_skip_file$descriptor() {
        return archive_write_disk_set_skip_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_disk_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static MethodHandle archive_write_disk_set_skip_file$handle() {
        return archive_write_disk_set_skip_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_disk_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static MemorySegment archive_write_disk_set_skip_file$address() {
        return archive_write_disk_set_skip_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_disk_set_skip_file(struct archive *, la_int64_t, la_int64_t)
     * }
     */
    public static int archive_write_disk_set_skip_file(MemorySegment x0, long x1, long x2) {
        var mh$ = archive_write_disk_set_skip_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_disk_set_skip_file", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_disk_set_options {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_disk_set_options");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_disk_set_options(struct archive *, int flags)
     * }
     */
    public static FunctionDescriptor archive_write_disk_set_options$descriptor() {
        return archive_write_disk_set_options.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_disk_set_options(struct archive *, int flags)
     * }
     */
    public static MethodHandle archive_write_disk_set_options$handle() {
        return archive_write_disk_set_options.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_disk_set_options(struct archive *, int flags)
     * }
     */
    public static MemorySegment archive_write_disk_set_options$address() {
        return archive_write_disk_set_options.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_disk_set_options(struct archive *, int flags)
     * }
     */
    public static int archive_write_disk_set_options(MemorySegment x0, int flags) {
        var mh$ = archive_write_disk_set_options.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_disk_set_options", x0, flags);
            }
            return (int)mh$.invokeExact(x0, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_disk_set_standard_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_disk_set_standard_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_disk_set_standard_lookup(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_write_disk_set_standard_lookup$descriptor() {
        return archive_write_disk_set_standard_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_disk_set_standard_lookup(struct archive *)
     * }
     */
    public static MethodHandle archive_write_disk_set_standard_lookup$handle() {
        return archive_write_disk_set_standard_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_disk_set_standard_lookup(struct archive *)
     * }
     */
    public static MemorySegment archive_write_disk_set_standard_lookup$address() {
        return archive_write_disk_set_standard_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_disk_set_standard_lookup(struct archive *)
     * }
     */
    public static int archive_write_disk_set_standard_lookup(MemorySegment x0) {
        var mh$ = archive_write_disk_set_standard_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_disk_set_standard_lookup", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_disk_set_group_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_disk_set_group_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_disk_set_group_lookup(struct archive *, void *, la_int64_t (*)(void *, const char *, la_int64_t), void (*)(void *))
     * }
     */
    public static FunctionDescriptor archive_write_disk_set_group_lookup$descriptor() {
        return archive_write_disk_set_group_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_disk_set_group_lookup(struct archive *, void *, la_int64_t (*)(void *, const char *, la_int64_t), void (*)(void *))
     * }
     */
    public static MethodHandle archive_write_disk_set_group_lookup$handle() {
        return archive_write_disk_set_group_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_disk_set_group_lookup(struct archive *, void *, la_int64_t (*)(void *, const char *, la_int64_t), void (*)(void *))
     * }
     */
    public static MemorySegment archive_write_disk_set_group_lookup$address() {
        return archive_write_disk_set_group_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_disk_set_group_lookup(struct archive *, void *, la_int64_t (*)(void *, const char *, la_int64_t), void (*)(void *))
     * }
     */
    public static int archive_write_disk_set_group_lookup(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = archive_write_disk_set_group_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_disk_set_group_lookup", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_disk_set_user_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_disk_set_user_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_write_disk_set_user_lookup(struct archive *, void *, la_int64_t (*)(void *, const char *, la_int64_t), void (*)(void *))
     * }
     */
    public static FunctionDescriptor archive_write_disk_set_user_lookup$descriptor() {
        return archive_write_disk_set_user_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_write_disk_set_user_lookup(struct archive *, void *, la_int64_t (*)(void *, const char *, la_int64_t), void (*)(void *))
     * }
     */
    public static MethodHandle archive_write_disk_set_user_lookup$handle() {
        return archive_write_disk_set_user_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_write_disk_set_user_lookup(struct archive *, void *, la_int64_t (*)(void *, const char *, la_int64_t), void (*)(void *))
     * }
     */
    public static MemorySegment archive_write_disk_set_user_lookup$address() {
        return archive_write_disk_set_user_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_write_disk_set_user_lookup(struct archive *, void *, la_int64_t (*)(void *, const char *, la_int64_t), void (*)(void *))
     * }
     */
    public static int archive_write_disk_set_user_lookup(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = archive_write_disk_set_user_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_disk_set_user_lookup", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_disk_gid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_disk_gid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_write_disk_gid(struct archive *, const char *, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_write_disk_gid$descriptor() {
        return archive_write_disk_gid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_write_disk_gid(struct archive *, const char *, la_int64_t)
     * }
     */
    public static MethodHandle archive_write_disk_gid$handle() {
        return archive_write_disk_gid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_write_disk_gid(struct archive *, const char *, la_int64_t)
     * }
     */
    public static MemorySegment archive_write_disk_gid$address() {
        return archive_write_disk_gid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_write_disk_gid(struct archive *, const char *, la_int64_t)
     * }
     */
    public static long archive_write_disk_gid(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = archive_write_disk_gid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_disk_gid", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_write_disk_uid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_write_disk_uid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_write_disk_uid(struct archive *, const char *, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_write_disk_uid$descriptor() {
        return archive_write_disk_uid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_write_disk_uid(struct archive *, const char *, la_int64_t)
     * }
     */
    public static MethodHandle archive_write_disk_uid$handle() {
        return archive_write_disk_uid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_write_disk_uid(struct archive *, const char *, la_int64_t)
     * }
     */
    public static MemorySegment archive_write_disk_uid$address() {
        return archive_write_disk_uid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_write_disk_uid(struct archive *, const char *, la_int64_t)
     * }
     */
    public static long archive_write_disk_uid(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = archive_write_disk_uid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_write_disk_uid", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive *archive_read_disk_new()
     * }
     */
    public static FunctionDescriptor archive_read_disk_new$descriptor() {
        return archive_read_disk_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive *archive_read_disk_new()
     * }
     */
    public static MethodHandle archive_read_disk_new$handle() {
        return archive_read_disk_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive *archive_read_disk_new()
     * }
     */
    public static MemorySegment archive_read_disk_new$address() {
        return archive_read_disk_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive *archive_read_disk_new()
     * }
     */
    public static MemorySegment archive_read_disk_new() {
        var mh$ = archive_read_disk_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_set_symlink_logical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_set_symlink_logical");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_logical(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_set_symlink_logical$descriptor() {
        return archive_read_disk_set_symlink_logical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_logical(struct archive *)
     * }
     */
    public static MethodHandle archive_read_disk_set_symlink_logical$handle() {
        return archive_read_disk_set_symlink_logical.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_logical(struct archive *)
     * }
     */
    public static MemorySegment archive_read_disk_set_symlink_logical$address() {
        return archive_read_disk_set_symlink_logical.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_logical(struct archive *)
     * }
     */
    public static int archive_read_disk_set_symlink_logical(MemorySegment x0) {
        var mh$ = archive_read_disk_set_symlink_logical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_set_symlink_logical", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_set_symlink_physical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_set_symlink_physical");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_physical(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_set_symlink_physical$descriptor() {
        return archive_read_disk_set_symlink_physical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_physical(struct archive *)
     * }
     */
    public static MethodHandle archive_read_disk_set_symlink_physical$handle() {
        return archive_read_disk_set_symlink_physical.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_physical(struct archive *)
     * }
     */
    public static MemorySegment archive_read_disk_set_symlink_physical$address() {
        return archive_read_disk_set_symlink_physical.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_physical(struct archive *)
     * }
     */
    public static int archive_read_disk_set_symlink_physical(MemorySegment x0) {
        var mh$ = archive_read_disk_set_symlink_physical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_set_symlink_physical", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_set_symlink_hybrid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_set_symlink_hybrid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_hybrid(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_set_symlink_hybrid$descriptor() {
        return archive_read_disk_set_symlink_hybrid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_hybrid(struct archive *)
     * }
     */
    public static MethodHandle archive_read_disk_set_symlink_hybrid$handle() {
        return archive_read_disk_set_symlink_hybrid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_hybrid(struct archive *)
     * }
     */
    public static MemorySegment archive_read_disk_set_symlink_hybrid$address() {
        return archive_read_disk_set_symlink_hybrid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_set_symlink_hybrid(struct archive *)
     * }
     */
    public static int archive_read_disk_set_symlink_hybrid(MemorySegment x0) {
        var mh$ = archive_read_disk_set_symlink_hybrid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_set_symlink_hybrid", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_entry_from_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_entry_from_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_entry_from_file(struct archive *, struct archive_entry *, int, const struct stat *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_entry_from_file$descriptor() {
        return archive_read_disk_entry_from_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_entry_from_file(struct archive *, struct archive_entry *, int, const struct stat *)
     * }
     */
    public static MethodHandle archive_read_disk_entry_from_file$handle() {
        return archive_read_disk_entry_from_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_entry_from_file(struct archive *, struct archive_entry *, int, const struct stat *)
     * }
     */
    public static MemorySegment archive_read_disk_entry_from_file$address() {
        return archive_read_disk_entry_from_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_entry_from_file(struct archive *, struct archive_entry *, int, const struct stat *)
     * }
     */
    public static int archive_read_disk_entry_from_file(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = archive_read_disk_entry_from_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_entry_from_file", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_gname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_gname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_read_disk_gname(struct archive *, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_read_disk_gname$descriptor() {
        return archive_read_disk_gname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_read_disk_gname(struct archive *, la_int64_t)
     * }
     */
    public static MethodHandle archive_read_disk_gname$handle() {
        return archive_read_disk_gname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_read_disk_gname(struct archive *, la_int64_t)
     * }
     */
    public static MemorySegment archive_read_disk_gname$address() {
        return archive_read_disk_gname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_read_disk_gname(struct archive *, la_int64_t)
     * }
     */
    public static MemorySegment archive_read_disk_gname(MemorySegment x0, long x1) {
        var mh$ = archive_read_disk_gname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_gname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_uname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_uname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_read_disk_uname(struct archive *, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_read_disk_uname$descriptor() {
        return archive_read_disk_uname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_read_disk_uname(struct archive *, la_int64_t)
     * }
     */
    public static MethodHandle archive_read_disk_uname$handle() {
        return archive_read_disk_uname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_read_disk_uname(struct archive *, la_int64_t)
     * }
     */
    public static MemorySegment archive_read_disk_uname$address() {
        return archive_read_disk_uname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_read_disk_uname(struct archive *, la_int64_t)
     * }
     */
    public static MemorySegment archive_read_disk_uname(MemorySegment x0, long x1) {
        var mh$ = archive_read_disk_uname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_uname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_set_standard_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_set_standard_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_set_standard_lookup(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_set_standard_lookup$descriptor() {
        return archive_read_disk_set_standard_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_set_standard_lookup(struct archive *)
     * }
     */
    public static MethodHandle archive_read_disk_set_standard_lookup$handle() {
        return archive_read_disk_set_standard_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_set_standard_lookup(struct archive *)
     * }
     */
    public static MemorySegment archive_read_disk_set_standard_lookup$address() {
        return archive_read_disk_set_standard_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_set_standard_lookup(struct archive *)
     * }
     */
    public static int archive_read_disk_set_standard_lookup(MemorySegment x0) {
        var mh$ = archive_read_disk_set_standard_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_set_standard_lookup", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_set_gname_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_set_gname_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_set_gname_lookup(struct archive *, void *, const char *(*)(void *, la_int64_t), void (*)(void *))
     * }
     */
    public static FunctionDescriptor archive_read_disk_set_gname_lookup$descriptor() {
        return archive_read_disk_set_gname_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_set_gname_lookup(struct archive *, void *, const char *(*)(void *, la_int64_t), void (*)(void *))
     * }
     */
    public static MethodHandle archive_read_disk_set_gname_lookup$handle() {
        return archive_read_disk_set_gname_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_set_gname_lookup(struct archive *, void *, const char *(*)(void *, la_int64_t), void (*)(void *))
     * }
     */
    public static MemorySegment archive_read_disk_set_gname_lookup$address() {
        return archive_read_disk_set_gname_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_set_gname_lookup(struct archive *, void *, const char *(*)(void *, la_int64_t), void (*)(void *))
     * }
     */
    public static int archive_read_disk_set_gname_lookup(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = archive_read_disk_set_gname_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_set_gname_lookup", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_set_uname_lookup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_set_uname_lookup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_set_uname_lookup(struct archive *, void *, const char *(*)(void *, la_int64_t), void (*)(void *))
     * }
     */
    public static FunctionDescriptor archive_read_disk_set_uname_lookup$descriptor() {
        return archive_read_disk_set_uname_lookup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_set_uname_lookup(struct archive *, void *, const char *(*)(void *, la_int64_t), void (*)(void *))
     * }
     */
    public static MethodHandle archive_read_disk_set_uname_lookup$handle() {
        return archive_read_disk_set_uname_lookup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_set_uname_lookup(struct archive *, void *, const char *(*)(void *, la_int64_t), void (*)(void *))
     * }
     */
    public static MemorySegment archive_read_disk_set_uname_lookup$address() {
        return archive_read_disk_set_uname_lookup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_set_uname_lookup(struct archive *, void *, const char *(*)(void *, la_int64_t), void (*)(void *))
     * }
     */
    public static int archive_read_disk_set_uname_lookup(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = archive_read_disk_set_uname_lookup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_set_uname_lookup", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_open(struct archive *, const char *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_open$descriptor() {
        return archive_read_disk_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_open(struct archive *, const char *)
     * }
     */
    public static MethodHandle archive_read_disk_open$handle() {
        return archive_read_disk_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_open(struct archive *, const char *)
     * }
     */
    public static MemorySegment archive_read_disk_open$address() {
        return archive_read_disk_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_open(struct archive *, const char *)
     * }
     */
    public static int archive_read_disk_open(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_disk_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_open", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_open_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_open_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_open_w(struct archive *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_open_w$descriptor() {
        return archive_read_disk_open_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_open_w(struct archive *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_read_disk_open_w$handle() {
        return archive_read_disk_open_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_open_w(struct archive *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_read_disk_open_w$address() {
        return archive_read_disk_open_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_open_w(struct archive *, const wchar_t *)
     * }
     */
    public static int archive_read_disk_open_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_read_disk_open_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_open_w", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_descend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_descend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_descend(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_descend$descriptor() {
        return archive_read_disk_descend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_descend(struct archive *)
     * }
     */
    public static MethodHandle archive_read_disk_descend$handle() {
        return archive_read_disk_descend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_descend(struct archive *)
     * }
     */
    public static MemorySegment archive_read_disk_descend$address() {
        return archive_read_disk_descend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_descend(struct archive *)
     * }
     */
    public static int archive_read_disk_descend(MemorySegment x0) {
        var mh$ = archive_read_disk_descend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_descend", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_can_descend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_can_descend");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_can_descend(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_can_descend$descriptor() {
        return archive_read_disk_can_descend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_can_descend(struct archive *)
     * }
     */
    public static MethodHandle archive_read_disk_can_descend$handle() {
        return archive_read_disk_can_descend.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_can_descend(struct archive *)
     * }
     */
    public static MemorySegment archive_read_disk_can_descend$address() {
        return archive_read_disk_can_descend.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_can_descend(struct archive *)
     * }
     */
    public static int archive_read_disk_can_descend(MemorySegment x0) {
        var mh$ = archive_read_disk_can_descend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_can_descend", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_current_filesystem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_current_filesystem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_current_filesystem$descriptor() {
        return archive_read_disk_current_filesystem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem(struct archive *)
     * }
     */
    public static MethodHandle archive_read_disk_current_filesystem$handle() {
        return archive_read_disk_current_filesystem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem(struct archive *)
     * }
     */
    public static MemorySegment archive_read_disk_current_filesystem$address() {
        return archive_read_disk_current_filesystem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem(struct archive *)
     * }
     */
    public static int archive_read_disk_current_filesystem(MemorySegment x0) {
        var mh$ = archive_read_disk_current_filesystem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_current_filesystem", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_current_filesystem_is_synthetic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_current_filesystem_is_synthetic");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem_is_synthetic(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_current_filesystem_is_synthetic$descriptor() {
        return archive_read_disk_current_filesystem_is_synthetic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem_is_synthetic(struct archive *)
     * }
     */
    public static MethodHandle archive_read_disk_current_filesystem_is_synthetic$handle() {
        return archive_read_disk_current_filesystem_is_synthetic.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem_is_synthetic(struct archive *)
     * }
     */
    public static MemorySegment archive_read_disk_current_filesystem_is_synthetic$address() {
        return archive_read_disk_current_filesystem_is_synthetic.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem_is_synthetic(struct archive *)
     * }
     */
    public static int archive_read_disk_current_filesystem_is_synthetic(MemorySegment x0) {
        var mh$ = archive_read_disk_current_filesystem_is_synthetic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_current_filesystem_is_synthetic", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_current_filesystem_is_remote {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_current_filesystem_is_remote");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem_is_remote(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_current_filesystem_is_remote$descriptor() {
        return archive_read_disk_current_filesystem_is_remote.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem_is_remote(struct archive *)
     * }
     */
    public static MethodHandle archive_read_disk_current_filesystem_is_remote$handle() {
        return archive_read_disk_current_filesystem_is_remote.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem_is_remote(struct archive *)
     * }
     */
    public static MemorySegment archive_read_disk_current_filesystem_is_remote$address() {
        return archive_read_disk_current_filesystem_is_remote.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_current_filesystem_is_remote(struct archive *)
     * }
     */
    public static int archive_read_disk_current_filesystem_is_remote(MemorySegment x0) {
        var mh$ = archive_read_disk_current_filesystem_is_remote.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_current_filesystem_is_remote", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_set_atime_restored {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_set_atime_restored");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_set_atime_restored(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_read_disk_set_atime_restored$descriptor() {
        return archive_read_disk_set_atime_restored.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_set_atime_restored(struct archive *)
     * }
     */
    public static MethodHandle archive_read_disk_set_atime_restored$handle() {
        return archive_read_disk_set_atime_restored.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_set_atime_restored(struct archive *)
     * }
     */
    public static MemorySegment archive_read_disk_set_atime_restored$address() {
        return archive_read_disk_set_atime_restored.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_set_atime_restored(struct archive *)
     * }
     */
    public static int archive_read_disk_set_atime_restored(MemorySegment x0) {
        var mh$ = archive_read_disk_set_atime_restored.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_set_atime_restored", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_set_behavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_set_behavior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_set_behavior(struct archive *, int flags)
     * }
     */
    public static FunctionDescriptor archive_read_disk_set_behavior$descriptor() {
        return archive_read_disk_set_behavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_set_behavior(struct archive *, int flags)
     * }
     */
    public static MethodHandle archive_read_disk_set_behavior$handle() {
        return archive_read_disk_set_behavior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_set_behavior(struct archive *, int flags)
     * }
     */
    public static MemorySegment archive_read_disk_set_behavior$address() {
        return archive_read_disk_set_behavior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_set_behavior(struct archive *, int flags)
     * }
     */
    public static int archive_read_disk_set_behavior(MemorySegment x0, int flags) {
        var mh$ = archive_read_disk_set_behavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_set_behavior", x0, flags);
            }
            return (int)mh$.invokeExact(x0, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_set_matching {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_set_matching");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_set_matching(struct archive *, struct archive *_matching, void (*_excluded_func)(struct archive *, void *, struct archive_entry *), void *_client_data)
     * }
     */
    public static FunctionDescriptor archive_read_disk_set_matching$descriptor() {
        return archive_read_disk_set_matching.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_set_matching(struct archive *, struct archive *_matching, void (*_excluded_func)(struct archive *, void *, struct archive_entry *), void *_client_data)
     * }
     */
    public static MethodHandle archive_read_disk_set_matching$handle() {
        return archive_read_disk_set_matching.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_set_matching(struct archive *, struct archive *_matching, void (*_excluded_func)(struct archive *, void *, struct archive_entry *), void *_client_data)
     * }
     */
    public static MemorySegment archive_read_disk_set_matching$address() {
        return archive_read_disk_set_matching.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_set_matching(struct archive *, struct archive *_matching, void (*_excluded_func)(struct archive *, void *, struct archive_entry *), void *_client_data)
     * }
     */
    public static int archive_read_disk_set_matching(MemorySegment x0, MemorySegment _matching, MemorySegment _excluded_func, MemorySegment _client_data) {
        var mh$ = archive_read_disk_set_matching.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_set_matching", x0, _matching, _excluded_func, _client_data);
            }
            return (int)mh$.invokeExact(x0, _matching, _excluded_func, _client_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_read_disk_set_metadata_filter_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_read_disk_set_metadata_filter_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_read_disk_set_metadata_filter_callback(struct archive *, int (*_metadata_filter_func)(struct archive *, void *, struct archive_entry *), void *_client_data)
     * }
     */
    public static FunctionDescriptor archive_read_disk_set_metadata_filter_callback$descriptor() {
        return archive_read_disk_set_metadata_filter_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_read_disk_set_metadata_filter_callback(struct archive *, int (*_metadata_filter_func)(struct archive *, void *, struct archive_entry *), void *_client_data)
     * }
     */
    public static MethodHandle archive_read_disk_set_metadata_filter_callback$handle() {
        return archive_read_disk_set_metadata_filter_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_read_disk_set_metadata_filter_callback(struct archive *, int (*_metadata_filter_func)(struct archive *, void *, struct archive_entry *), void *_client_data)
     * }
     */
    public static MemorySegment archive_read_disk_set_metadata_filter_callback$address() {
        return archive_read_disk_set_metadata_filter_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_read_disk_set_metadata_filter_callback(struct archive *, int (*_metadata_filter_func)(struct archive *, void *, struct archive_entry *), void *_client_data)
     * }
     */
    public static int archive_read_disk_set_metadata_filter_callback(MemorySegment x0, MemorySegment _metadata_filter_func, MemorySegment _client_data) {
        var mh$ = archive_read_disk_set_metadata_filter_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_read_disk_set_metadata_filter_callback", x0, _metadata_filter_func, _client_data);
            }
            return (int)mh$.invokeExact(x0, _metadata_filter_func, _client_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_free(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_free$descriptor() {
        return archive_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_free(struct archive *)
     * }
     */
    public static MethodHandle archive_free$handle() {
        return archive_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_free(struct archive *)
     * }
     */
    public static MemorySegment archive_free$address() {
        return archive_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_free(struct archive *)
     * }
     */
    public static int archive_free(MemorySegment x0) {
        var mh$ = archive_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_free", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_filter_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_filter_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_filter_count(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_filter_count$descriptor() {
        return archive_filter_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_filter_count(struct archive *)
     * }
     */
    public static MethodHandle archive_filter_count$handle() {
        return archive_filter_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_filter_count(struct archive *)
     * }
     */
    public static MemorySegment archive_filter_count$address() {
        return archive_filter_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_filter_count(struct archive *)
     * }
     */
    public static int archive_filter_count(MemorySegment x0) {
        var mh$ = archive_filter_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_filter_count", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_filter_bytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_filter_bytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_filter_bytes(struct archive *, int)
     * }
     */
    public static FunctionDescriptor archive_filter_bytes$descriptor() {
        return archive_filter_bytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_filter_bytes(struct archive *, int)
     * }
     */
    public static MethodHandle archive_filter_bytes$handle() {
        return archive_filter_bytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_filter_bytes(struct archive *, int)
     * }
     */
    public static MemorySegment archive_filter_bytes$address() {
        return archive_filter_bytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_filter_bytes(struct archive *, int)
     * }
     */
    public static long archive_filter_bytes(MemorySegment x0, int x1) {
        var mh$ = archive_filter_bytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_filter_bytes", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_filter_code {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_filter_code");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_filter_code(struct archive *, int)
     * }
     */
    public static FunctionDescriptor archive_filter_code$descriptor() {
        return archive_filter_code.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_filter_code(struct archive *, int)
     * }
     */
    public static MethodHandle archive_filter_code$handle() {
        return archive_filter_code.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_filter_code(struct archive *, int)
     * }
     */
    public static MemorySegment archive_filter_code$address() {
        return archive_filter_code.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_filter_code(struct archive *, int)
     * }
     */
    public static int archive_filter_code(MemorySegment x0, int x1) {
        var mh$ = archive_filter_code.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_filter_code", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_filter_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_filter_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_filter_name(struct archive *, int)
     * }
     */
    public static FunctionDescriptor archive_filter_name$descriptor() {
        return archive_filter_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_filter_name(struct archive *, int)
     * }
     */
    public static MethodHandle archive_filter_name$handle() {
        return archive_filter_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_filter_name(struct archive *, int)
     * }
     */
    public static MemorySegment archive_filter_name$address() {
        return archive_filter_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_filter_name(struct archive *, int)
     * }
     */
    public static MemorySegment archive_filter_name(MemorySegment x0, int x1) {
        var mh$ = archive_filter_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_filter_name", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_position_compressed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_position_compressed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_position_compressed(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_position_compressed$descriptor() {
        return archive_position_compressed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_position_compressed(struct archive *)
     * }
     */
    public static MethodHandle archive_position_compressed$handle() {
        return archive_position_compressed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_position_compressed(struct archive *)
     * }
     */
    public static MemorySegment archive_position_compressed$address() {
        return archive_position_compressed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_position_compressed(struct archive *)
     * }
     */
    public static long archive_position_compressed(MemorySegment x0) {
        var mh$ = archive_position_compressed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_position_compressed", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_position_uncompressed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_position_uncompressed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_position_uncompressed(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_position_uncompressed$descriptor() {
        return archive_position_uncompressed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_position_uncompressed(struct archive *)
     * }
     */
    public static MethodHandle archive_position_uncompressed$handle() {
        return archive_position_uncompressed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_position_uncompressed(struct archive *)
     * }
     */
    public static MemorySegment archive_position_uncompressed$address() {
        return archive_position_uncompressed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_position_uncompressed(struct archive *)
     * }
     */
    public static long archive_position_uncompressed(MemorySegment x0) {
        var mh$ = archive_position_uncompressed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_position_uncompressed", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_compression_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_compression_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_compression_name(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_compression_name$descriptor() {
        return archive_compression_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_compression_name(struct archive *)
     * }
     */
    public static MethodHandle archive_compression_name$handle() {
        return archive_compression_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_compression_name(struct archive *)
     * }
     */
    public static MemorySegment archive_compression_name$address() {
        return archive_compression_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_compression_name(struct archive *)
     * }
     */
    public static MemorySegment archive_compression_name(MemorySegment x0) {
        var mh$ = archive_compression_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_compression_name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_compression {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_compression");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_compression(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_compression$descriptor() {
        return archive_compression.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_compression(struct archive *)
     * }
     */
    public static MethodHandle archive_compression$handle() {
        return archive_compression.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_compression(struct archive *)
     * }
     */
    public static MemorySegment archive_compression$address() {
        return archive_compression.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_compression(struct archive *)
     * }
     */
    public static int archive_compression(MemorySegment x0) {
        var mh$ = archive_compression.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_compression", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_errno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_errno(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_errno$descriptor() {
        return archive_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_errno(struct archive *)
     * }
     */
    public static MethodHandle archive_errno$handle() {
        return archive_errno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_errno(struct archive *)
     * }
     */
    public static MemorySegment archive_errno$address() {
        return archive_errno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_errno(struct archive *)
     * }
     */
    public static int archive_errno(MemorySegment x0) {
        var mh$ = archive_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_errno", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_error_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_error_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_error_string(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_error_string$descriptor() {
        return archive_error_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_error_string(struct archive *)
     * }
     */
    public static MethodHandle archive_error_string$handle() {
        return archive_error_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_error_string(struct archive *)
     * }
     */
    public static MemorySegment archive_error_string$address() {
        return archive_error_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_error_string(struct archive *)
     * }
     */
    public static MemorySegment archive_error_string(MemorySegment x0) {
        var mh$ = archive_error_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_error_string", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_format_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_format_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_format_name(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_format_name$descriptor() {
        return archive_format_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_format_name(struct archive *)
     * }
     */
    public static MethodHandle archive_format_name$handle() {
        return archive_format_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_format_name(struct archive *)
     * }
     */
    public static MemorySegment archive_format_name$address() {
        return archive_format_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_format_name(struct archive *)
     * }
     */
    public static MemorySegment archive_format_name(MemorySegment x0) {
        var mh$ = archive_format_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_format_name", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_format(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_format$descriptor() {
        return archive_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_format(struct archive *)
     * }
     */
    public static MethodHandle archive_format$handle() {
        return archive_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_format(struct archive *)
     * }
     */
    public static MemorySegment archive_format$address() {
        return archive_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_format(struct archive *)
     * }
     */
    public static int archive_format(MemorySegment x0) {
        var mh$ = archive_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_format", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_clear_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_clear_error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_clear_error(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_clear_error$descriptor() {
        return archive_clear_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_clear_error(struct archive *)
     * }
     */
    public static MethodHandle archive_clear_error$handle() {
        return archive_clear_error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_clear_error(struct archive *)
     * }
     */
    public static MemorySegment archive_clear_error$address() {
        return archive_clear_error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_clear_error(struct archive *)
     * }
     */
    public static void archive_clear_error(MemorySegment x0) {
        var mh$ = archive_clear_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_clear_error", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void archive_set_error(struct archive *, int _err, const char *fmt, ...)
     * }
     */
    public static class archive_set_error {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                archive_h.C_POINTER,
                archive_h.C_INT,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("archive_set_error");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private archive_set_error(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void archive_set_error(struct archive *, int _err, const char *fmt, ...)
         * }
         */
        public static archive_set_error makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new archive_set_error(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, int _err, MemorySegment fmt, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("archive_set_error", x0, _err, fmt, x3);
                }
                spreader.invokeExact(x0, _err, fmt, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class archive_copy_error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_copy_error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_copy_error(struct archive *dest, struct archive *src)
     * }
     */
    public static FunctionDescriptor archive_copy_error$descriptor() {
        return archive_copy_error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_copy_error(struct archive *dest, struct archive *src)
     * }
     */
    public static MethodHandle archive_copy_error$handle() {
        return archive_copy_error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_copy_error(struct archive *dest, struct archive *src)
     * }
     */
    public static MemorySegment archive_copy_error$address() {
        return archive_copy_error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_copy_error(struct archive *dest, struct archive *src)
     * }
     */
    public static void archive_copy_error(MemorySegment dest, MemorySegment src) {
        var mh$ = archive_copy_error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_copy_error", dest, src);
            }
            mh$.invokeExact(dest, src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_file_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_file_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_file_count(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_file_count$descriptor() {
        return archive_file_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_file_count(struct archive *)
     * }
     */
    public static MethodHandle archive_file_count$handle() {
        return archive_file_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_file_count(struct archive *)
     * }
     */
    public static MemorySegment archive_file_count$address() {
        return archive_file_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_file_count(struct archive *)
     * }
     */
    public static int archive_file_count(MemorySegment x0) {
        var mh$ = archive_file_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_file_count", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive *archive_match_new()
     * }
     */
    public static FunctionDescriptor archive_match_new$descriptor() {
        return archive_match_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive *archive_match_new()
     * }
     */
    public static MethodHandle archive_match_new$handle() {
        return archive_match_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive *archive_match_new()
     * }
     */
    public static MemorySegment archive_match_new$address() {
        return archive_match_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive *archive_match_new()
     * }
     */
    public static MemorySegment archive_match_new() {
        var mh$ = archive_match_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_free(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_match_free$descriptor() {
        return archive_match_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_free(struct archive *)
     * }
     */
    public static MethodHandle archive_match_free$handle() {
        return archive_match_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_free(struct archive *)
     * }
     */
    public static MemorySegment archive_match_free$address() {
        return archive_match_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_free(struct archive *)
     * }
     */
    public static int archive_match_free(MemorySegment x0) {
        var mh$ = archive_match_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_free", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_excluded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_excluded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_match_excluded$descriptor() {
        return archive_match_excluded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static MethodHandle archive_match_excluded$handle() {
        return archive_match_excluded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static MemorySegment archive_match_excluded$address() {
        return archive_match_excluded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static int archive_match_excluded(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_excluded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_excluded", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_path_excluded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_path_excluded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_path_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_match_path_excluded$descriptor() {
        return archive_match_path_excluded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_path_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static MethodHandle archive_match_path_excluded$handle() {
        return archive_match_path_excluded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_path_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static MemorySegment archive_match_path_excluded$address() {
        return archive_match_path_excluded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_path_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static int archive_match_path_excluded(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_path_excluded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_path_excluded", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_set_inclusion_recursion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_set_inclusion_recursion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_set_inclusion_recursion(struct archive *, int)
     * }
     */
    public static FunctionDescriptor archive_match_set_inclusion_recursion$descriptor() {
        return archive_match_set_inclusion_recursion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_set_inclusion_recursion(struct archive *, int)
     * }
     */
    public static MethodHandle archive_match_set_inclusion_recursion$handle() {
        return archive_match_set_inclusion_recursion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_set_inclusion_recursion(struct archive *, int)
     * }
     */
    public static MemorySegment archive_match_set_inclusion_recursion$address() {
        return archive_match_set_inclusion_recursion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_set_inclusion_recursion(struct archive *, int)
     * }
     */
    public static int archive_match_set_inclusion_recursion(MemorySegment x0, int x1) {
        var mh$ = archive_match_set_inclusion_recursion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_set_inclusion_recursion", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_exclude_pattern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_exclude_pattern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern(struct archive *, const char *)
     * }
     */
    public static FunctionDescriptor archive_match_exclude_pattern$descriptor() {
        return archive_match_exclude_pattern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern(struct archive *, const char *)
     * }
     */
    public static MethodHandle archive_match_exclude_pattern$handle() {
        return archive_match_exclude_pattern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern(struct archive *, const char *)
     * }
     */
    public static MemorySegment archive_match_exclude_pattern$address() {
        return archive_match_exclude_pattern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_exclude_pattern(struct archive *, const char *)
     * }
     */
    public static int archive_match_exclude_pattern(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_exclude_pattern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_exclude_pattern", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_exclude_pattern_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_exclude_pattern_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_w(struct archive *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_match_exclude_pattern_w$descriptor() {
        return archive_match_exclude_pattern_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_w(struct archive *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_match_exclude_pattern_w$handle() {
        return archive_match_exclude_pattern_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_w(struct archive *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_match_exclude_pattern_w$address() {
        return archive_match_exclude_pattern_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_w(struct archive *, const wchar_t *)
     * }
     */
    public static int archive_match_exclude_pattern_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_exclude_pattern_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_exclude_pattern_w", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_exclude_pattern_from_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_exclude_pattern_from_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_from_file(struct archive *, const char *, int _nullSeparator)
     * }
     */
    public static FunctionDescriptor archive_match_exclude_pattern_from_file$descriptor() {
        return archive_match_exclude_pattern_from_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_from_file(struct archive *, const char *, int _nullSeparator)
     * }
     */
    public static MethodHandle archive_match_exclude_pattern_from_file$handle() {
        return archive_match_exclude_pattern_from_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_from_file(struct archive *, const char *, int _nullSeparator)
     * }
     */
    public static MemorySegment archive_match_exclude_pattern_from_file$address() {
        return archive_match_exclude_pattern_from_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_from_file(struct archive *, const char *, int _nullSeparator)
     * }
     */
    public static int archive_match_exclude_pattern_from_file(MemorySegment x0, MemorySegment x1, int _nullSeparator) {
        var mh$ = archive_match_exclude_pattern_from_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_exclude_pattern_from_file", x0, x1, _nullSeparator);
            }
            return (int)mh$.invokeExact(x0, x1, _nullSeparator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_exclude_pattern_from_file_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_exclude_pattern_from_file_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_from_file_w(struct archive *, const wchar_t *, int _nullSeparator)
     * }
     */
    public static FunctionDescriptor archive_match_exclude_pattern_from_file_w$descriptor() {
        return archive_match_exclude_pattern_from_file_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_from_file_w(struct archive *, const wchar_t *, int _nullSeparator)
     * }
     */
    public static MethodHandle archive_match_exclude_pattern_from_file_w$handle() {
        return archive_match_exclude_pattern_from_file_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_from_file_w(struct archive *, const wchar_t *, int _nullSeparator)
     * }
     */
    public static MemorySegment archive_match_exclude_pattern_from_file_w$address() {
        return archive_match_exclude_pattern_from_file_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_exclude_pattern_from_file_w(struct archive *, const wchar_t *, int _nullSeparator)
     * }
     */
    public static int archive_match_exclude_pattern_from_file_w(MemorySegment x0, MemorySegment x1, int _nullSeparator) {
        var mh$ = archive_match_exclude_pattern_from_file_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_exclude_pattern_from_file_w", x0, x1, _nullSeparator);
            }
            return (int)mh$.invokeExact(x0, x1, _nullSeparator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_pattern {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_pattern");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_pattern(struct archive *, const char *)
     * }
     */
    public static FunctionDescriptor archive_match_include_pattern$descriptor() {
        return archive_match_include_pattern.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_pattern(struct archive *, const char *)
     * }
     */
    public static MethodHandle archive_match_include_pattern$handle() {
        return archive_match_include_pattern.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_pattern(struct archive *, const char *)
     * }
     */
    public static MemorySegment archive_match_include_pattern$address() {
        return archive_match_include_pattern.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_pattern(struct archive *, const char *)
     * }
     */
    public static int archive_match_include_pattern(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_include_pattern.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_pattern", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_pattern_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_pattern_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_pattern_w(struct archive *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_match_include_pattern_w$descriptor() {
        return archive_match_include_pattern_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_pattern_w(struct archive *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_match_include_pattern_w$handle() {
        return archive_match_include_pattern_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_pattern_w(struct archive *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_match_include_pattern_w$address() {
        return archive_match_include_pattern_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_pattern_w(struct archive *, const wchar_t *)
     * }
     */
    public static int archive_match_include_pattern_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_include_pattern_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_pattern_w", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_pattern_from_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_pattern_from_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_pattern_from_file(struct archive *, const char *, int _nullSeparator)
     * }
     */
    public static FunctionDescriptor archive_match_include_pattern_from_file$descriptor() {
        return archive_match_include_pattern_from_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_pattern_from_file(struct archive *, const char *, int _nullSeparator)
     * }
     */
    public static MethodHandle archive_match_include_pattern_from_file$handle() {
        return archive_match_include_pattern_from_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_pattern_from_file(struct archive *, const char *, int _nullSeparator)
     * }
     */
    public static MemorySegment archive_match_include_pattern_from_file$address() {
        return archive_match_include_pattern_from_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_pattern_from_file(struct archive *, const char *, int _nullSeparator)
     * }
     */
    public static int archive_match_include_pattern_from_file(MemorySegment x0, MemorySegment x1, int _nullSeparator) {
        var mh$ = archive_match_include_pattern_from_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_pattern_from_file", x0, x1, _nullSeparator);
            }
            return (int)mh$.invokeExact(x0, x1, _nullSeparator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_pattern_from_file_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_pattern_from_file_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_pattern_from_file_w(struct archive *, const wchar_t *, int _nullSeparator)
     * }
     */
    public static FunctionDescriptor archive_match_include_pattern_from_file_w$descriptor() {
        return archive_match_include_pattern_from_file_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_pattern_from_file_w(struct archive *, const wchar_t *, int _nullSeparator)
     * }
     */
    public static MethodHandle archive_match_include_pattern_from_file_w$handle() {
        return archive_match_include_pattern_from_file_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_pattern_from_file_w(struct archive *, const wchar_t *, int _nullSeparator)
     * }
     */
    public static MemorySegment archive_match_include_pattern_from_file_w$address() {
        return archive_match_include_pattern_from_file_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_pattern_from_file_w(struct archive *, const wchar_t *, int _nullSeparator)
     * }
     */
    public static int archive_match_include_pattern_from_file_w(MemorySegment x0, MemorySegment x1, int _nullSeparator) {
        var mh$ = archive_match_include_pattern_from_file_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_pattern_from_file_w", x0, x1, _nullSeparator);
            }
            return (int)mh$.invokeExact(x0, x1, _nullSeparator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_path_unmatched_inclusions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_path_unmatched_inclusions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_match_path_unmatched_inclusions$descriptor() {
        return archive_match_path_unmatched_inclusions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions(struct archive *)
     * }
     */
    public static MethodHandle archive_match_path_unmatched_inclusions$handle() {
        return archive_match_path_unmatched_inclusions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions(struct archive *)
     * }
     */
    public static MemorySegment archive_match_path_unmatched_inclusions$address() {
        return archive_match_path_unmatched_inclusions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions(struct archive *)
     * }
     */
    public static int archive_match_path_unmatched_inclusions(MemorySegment x0) {
        var mh$ = archive_match_path_unmatched_inclusions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_path_unmatched_inclusions", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_path_unmatched_inclusions_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_path_unmatched_inclusions_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions_next(struct archive *, const char **)
     * }
     */
    public static FunctionDescriptor archive_match_path_unmatched_inclusions_next$descriptor() {
        return archive_match_path_unmatched_inclusions_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions_next(struct archive *, const char **)
     * }
     */
    public static MethodHandle archive_match_path_unmatched_inclusions_next$handle() {
        return archive_match_path_unmatched_inclusions_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions_next(struct archive *, const char **)
     * }
     */
    public static MemorySegment archive_match_path_unmatched_inclusions_next$address() {
        return archive_match_path_unmatched_inclusions_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions_next(struct archive *, const char **)
     * }
     */
    public static int archive_match_path_unmatched_inclusions_next(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_path_unmatched_inclusions_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_path_unmatched_inclusions_next", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_path_unmatched_inclusions_next_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_path_unmatched_inclusions_next_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions_next_w(struct archive *, const wchar_t **)
     * }
     */
    public static FunctionDescriptor archive_match_path_unmatched_inclusions_next_w$descriptor() {
        return archive_match_path_unmatched_inclusions_next_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions_next_w(struct archive *, const wchar_t **)
     * }
     */
    public static MethodHandle archive_match_path_unmatched_inclusions_next_w$handle() {
        return archive_match_path_unmatched_inclusions_next_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions_next_w(struct archive *, const wchar_t **)
     * }
     */
    public static MemorySegment archive_match_path_unmatched_inclusions_next_w$address() {
        return archive_match_path_unmatched_inclusions_next_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_path_unmatched_inclusions_next_w(struct archive *, const wchar_t **)
     * }
     */
    public static int archive_match_path_unmatched_inclusions_next_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_path_unmatched_inclusions_next_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_path_unmatched_inclusions_next_w", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_time_excluded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_time_excluded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_time_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_match_time_excluded$descriptor() {
        return archive_match_time_excluded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_time_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static MethodHandle archive_match_time_excluded$handle() {
        return archive_match_time_excluded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_time_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static MemorySegment archive_match_time_excluded$address() {
        return archive_match_time_excluded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_time_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static int archive_match_time_excluded(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_time_excluded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_time_excluded", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_time(struct archive *, int _flag, time_t _sec, long _nsec)
     * }
     */
    public static FunctionDescriptor archive_match_include_time$descriptor() {
        return archive_match_include_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_time(struct archive *, int _flag, time_t _sec, long _nsec)
     * }
     */
    public static MethodHandle archive_match_include_time$handle() {
        return archive_match_include_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_time(struct archive *, int _flag, time_t _sec, long _nsec)
     * }
     */
    public static MemorySegment archive_match_include_time$address() {
        return archive_match_include_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_time(struct archive *, int _flag, time_t _sec, long _nsec)
     * }
     */
    public static int archive_match_include_time(MemorySegment x0, int _flag, long _sec, long _nsec) {
        var mh$ = archive_match_include_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_time", x0, _flag, _sec, _nsec);
            }
            return (int)mh$.invokeExact(x0, _flag, _sec, _nsec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_date {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_date");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_date(struct archive *, int _flag, const char *_datestr)
     * }
     */
    public static FunctionDescriptor archive_match_include_date$descriptor() {
        return archive_match_include_date.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_date(struct archive *, int _flag, const char *_datestr)
     * }
     */
    public static MethodHandle archive_match_include_date$handle() {
        return archive_match_include_date.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_date(struct archive *, int _flag, const char *_datestr)
     * }
     */
    public static MemorySegment archive_match_include_date$address() {
        return archive_match_include_date.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_date(struct archive *, int _flag, const char *_datestr)
     * }
     */
    public static int archive_match_include_date(MemorySegment x0, int _flag, MemorySegment _datestr) {
        var mh$ = archive_match_include_date.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_date", x0, _flag, _datestr);
            }
            return (int)mh$.invokeExact(x0, _flag, _datestr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_date_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_date_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_date_w(struct archive *, int _flag, const wchar_t *_datestr)
     * }
     */
    public static FunctionDescriptor archive_match_include_date_w$descriptor() {
        return archive_match_include_date_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_date_w(struct archive *, int _flag, const wchar_t *_datestr)
     * }
     */
    public static MethodHandle archive_match_include_date_w$handle() {
        return archive_match_include_date_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_date_w(struct archive *, int _flag, const wchar_t *_datestr)
     * }
     */
    public static MemorySegment archive_match_include_date_w$address() {
        return archive_match_include_date_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_date_w(struct archive *, int _flag, const wchar_t *_datestr)
     * }
     */
    public static int archive_match_include_date_w(MemorySegment x0, int _flag, MemorySegment _datestr) {
        var mh$ = archive_match_include_date_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_date_w", x0, _flag, _datestr);
            }
            return (int)mh$.invokeExact(x0, _flag, _datestr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_file_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_file_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_file_time(struct archive *, int _flag, const char *_pathname)
     * }
     */
    public static FunctionDescriptor archive_match_include_file_time$descriptor() {
        return archive_match_include_file_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_file_time(struct archive *, int _flag, const char *_pathname)
     * }
     */
    public static MethodHandle archive_match_include_file_time$handle() {
        return archive_match_include_file_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_file_time(struct archive *, int _flag, const char *_pathname)
     * }
     */
    public static MemorySegment archive_match_include_file_time$address() {
        return archive_match_include_file_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_file_time(struct archive *, int _flag, const char *_pathname)
     * }
     */
    public static int archive_match_include_file_time(MemorySegment x0, int _flag, MemorySegment _pathname) {
        var mh$ = archive_match_include_file_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_file_time", x0, _flag, _pathname);
            }
            return (int)mh$.invokeExact(x0, _flag, _pathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_file_time_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_file_time_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_file_time_w(struct archive *, int _flag, const wchar_t *_pathname)
     * }
     */
    public static FunctionDescriptor archive_match_include_file_time_w$descriptor() {
        return archive_match_include_file_time_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_file_time_w(struct archive *, int _flag, const wchar_t *_pathname)
     * }
     */
    public static MethodHandle archive_match_include_file_time_w$handle() {
        return archive_match_include_file_time_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_file_time_w(struct archive *, int _flag, const wchar_t *_pathname)
     * }
     */
    public static MemorySegment archive_match_include_file_time_w$address() {
        return archive_match_include_file_time_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_file_time_w(struct archive *, int _flag, const wchar_t *_pathname)
     * }
     */
    public static int archive_match_include_file_time_w(MemorySegment x0, int _flag, MemorySegment _pathname) {
        var mh$ = archive_match_include_file_time_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_file_time_w", x0, _flag, _pathname);
            }
            return (int)mh$.invokeExact(x0, _flag, _pathname);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_exclude_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_exclude_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_exclude_entry(struct archive *, int _flag, struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_match_exclude_entry$descriptor() {
        return archive_match_exclude_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_exclude_entry(struct archive *, int _flag, struct archive_entry *)
     * }
     */
    public static MethodHandle archive_match_exclude_entry$handle() {
        return archive_match_exclude_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_exclude_entry(struct archive *, int _flag, struct archive_entry *)
     * }
     */
    public static MemorySegment archive_match_exclude_entry$address() {
        return archive_match_exclude_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_exclude_entry(struct archive *, int _flag, struct archive_entry *)
     * }
     */
    public static int archive_match_exclude_entry(MemorySegment x0, int _flag, MemorySegment x2) {
        var mh$ = archive_match_exclude_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_exclude_entry", x0, _flag, x2);
            }
            return (int)mh$.invokeExact(x0, _flag, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_owner_excluded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_owner_excluded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_owner_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_match_owner_excluded$descriptor() {
        return archive_match_owner_excluded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_owner_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static MethodHandle archive_match_owner_excluded$handle() {
        return archive_match_owner_excluded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_owner_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static MemorySegment archive_match_owner_excluded$address() {
        return archive_match_owner_excluded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_owner_excluded(struct archive *, struct archive_entry *)
     * }
     */
    public static int archive_match_owner_excluded(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_owner_excluded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_owner_excluded", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_uid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_uid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_uid(struct archive *, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_match_include_uid$descriptor() {
        return archive_match_include_uid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_uid(struct archive *, la_int64_t)
     * }
     */
    public static MethodHandle archive_match_include_uid$handle() {
        return archive_match_include_uid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_uid(struct archive *, la_int64_t)
     * }
     */
    public static MemorySegment archive_match_include_uid$address() {
        return archive_match_include_uid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_uid(struct archive *, la_int64_t)
     * }
     */
    public static int archive_match_include_uid(MemorySegment x0, long x1) {
        var mh$ = archive_match_include_uid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_uid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_gid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_gid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_gid(struct archive *, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_match_include_gid$descriptor() {
        return archive_match_include_gid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_gid(struct archive *, la_int64_t)
     * }
     */
    public static MethodHandle archive_match_include_gid$handle() {
        return archive_match_include_gid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_gid(struct archive *, la_int64_t)
     * }
     */
    public static MemorySegment archive_match_include_gid$address() {
        return archive_match_include_gid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_gid(struct archive *, la_int64_t)
     * }
     */
    public static int archive_match_include_gid(MemorySegment x0, long x1) {
        var mh$ = archive_match_include_gid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_gid", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_uname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_uname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_uname(struct archive *, const char *)
     * }
     */
    public static FunctionDescriptor archive_match_include_uname$descriptor() {
        return archive_match_include_uname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_uname(struct archive *, const char *)
     * }
     */
    public static MethodHandle archive_match_include_uname$handle() {
        return archive_match_include_uname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_uname(struct archive *, const char *)
     * }
     */
    public static MemorySegment archive_match_include_uname$address() {
        return archive_match_include_uname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_uname(struct archive *, const char *)
     * }
     */
    public static int archive_match_include_uname(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_include_uname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_uname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_uname_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_uname_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_uname_w(struct archive *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_match_include_uname_w$descriptor() {
        return archive_match_include_uname_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_uname_w(struct archive *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_match_include_uname_w$handle() {
        return archive_match_include_uname_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_uname_w(struct archive *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_match_include_uname_w$address() {
        return archive_match_include_uname_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_uname_w(struct archive *, const wchar_t *)
     * }
     */
    public static int archive_match_include_uname_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_include_uname_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_uname_w", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_gname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_gname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_gname(struct archive *, const char *)
     * }
     */
    public static FunctionDescriptor archive_match_include_gname$descriptor() {
        return archive_match_include_gname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_gname(struct archive *, const char *)
     * }
     */
    public static MethodHandle archive_match_include_gname$handle() {
        return archive_match_include_gname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_gname(struct archive *, const char *)
     * }
     */
    public static MemorySegment archive_match_include_gname$address() {
        return archive_match_include_gname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_gname(struct archive *, const char *)
     * }
     */
    public static int archive_match_include_gname(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_include_gname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_gname", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_match_include_gname_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_match_include_gname_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_match_include_gname_w(struct archive *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_match_include_gname_w$descriptor() {
        return archive_match_include_gname_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_match_include_gname_w(struct archive *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_match_include_gname_w$handle() {
        return archive_match_include_gname_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_match_include_gname_w(struct archive *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_match_include_gname_w$address() {
        return archive_match_include_gname_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_match_include_gname_w(struct archive *, const wchar_t *)
     * }
     */
    public static int archive_match_include_gname_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_match_include_gname_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_match_include_gname_w", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_utility_string_sort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_utility_string_sort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_utility_string_sort(char **)
     * }
     */
    public static FunctionDescriptor archive_utility_string_sort$descriptor() {
        return archive_utility_string_sort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_utility_string_sort(char **)
     * }
     */
    public static MethodHandle archive_utility_string_sort$handle() {
        return archive_utility_string_sort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_utility_string_sort(char **)
     * }
     */
    public static MemorySegment archive_utility_string_sort$address() {
        return archive_utility_string_sort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_utility_string_sort(char **)
     * }
     */
    public static int archive_utility_string_sort(MemorySegment x0) {
        var mh$ = archive_utility_string_sort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_utility_string_sort", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_char
     * }
     */
    public static final OfByte u_char = archive_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_short
     * }
     */
    public static final OfShort u_short = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int
     * }
     */
    public static final OfInt u_int = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long u_long
     * }
     */
    public static final OfLong u_long = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t quad_t
     * }
     */
    public static final OfLong quad_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef quad_t *qaddr_t
     * }
     */
    public static final AddressLayout qaddr_t = archive_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef char *caddr_t
     * }
     */
    public static final AddressLayout caddr_t = archive_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int32_t daddr_t
     * }
     */
    public static final OfInt daddr_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef u_int32_t fixpt_t
     * }
     */
    public static final OfInt fixpt_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t in_addr_t
     * }
     */
    public static final OfInt in_addr_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t in_port_t
     * }
     */
    public static final OfShort in_port_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t key_t
     * }
     */
    public static final OfInt key_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t segsz_t
     * }
     */
    public static final OfInt segsz_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int32_t swblk_t
     * }
     */
    public static final OfInt swblk_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t fd_mask
     * }
     */
    public static final OfInt fd_mask = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_t pthread_t
     * }
     */
    public static final AddressLayout pthread_t = archive_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_pthread_key_t pthread_key_t
     * }
     */
    public static final OfLong pthread_key_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfInt fsblkcnt_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfInt fsfilcnt_t = archive_h.C_INT;

    private static class archive_entry_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_clear(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_clear$descriptor() {
        return archive_entry_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_clear(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_clear$handle() {
        return archive_entry_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_clear(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_clear$address() {
        return archive_entry_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_clear(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_clear(MemorySegment x0) {
        var mh$ = archive_entry_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_clear", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_clone(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_clone$descriptor() {
        return archive_entry_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_clone(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_clone$handle() {
        return archive_entry_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_clone(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_clone$address() {
        return archive_entry_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_clone(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_clone(MemorySegment x0) {
        var mh$ = archive_entry_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_clone", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_free(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_free$descriptor() {
        return archive_entry_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_free(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_free$handle() {
        return archive_entry_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_free(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_free$address() {
        return archive_entry_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_free(struct archive_entry *)
     * }
     */
    public static void archive_entry_free(MemorySegment x0) {
        var mh$ = archive_entry_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_new()
     * }
     */
    public static FunctionDescriptor archive_entry_new$descriptor() {
        return archive_entry_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_new()
     * }
     */
    public static MethodHandle archive_entry_new$handle() {
        return archive_entry_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_new()
     * }
     */
    public static MemorySegment archive_entry_new$address() {
        return archive_entry_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_new()
     * }
     */
    public static MemorySegment archive_entry_new() {
        var mh$ = archive_entry_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_new2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_new2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_new2(struct archive *)
     * }
     */
    public static FunctionDescriptor archive_entry_new2$descriptor() {
        return archive_entry_new2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_new2(struct archive *)
     * }
     */
    public static MethodHandle archive_entry_new2$handle() {
        return archive_entry_new2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_new2(struct archive *)
     * }
     */
    public static MemorySegment archive_entry_new2$address() {
        return archive_entry_new2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_new2(struct archive *)
     * }
     */
    public static MemorySegment archive_entry_new2(MemorySegment x0) {
        var mh$ = archive_entry_new2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_new2", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_atime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_atime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t archive_entry_atime(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_atime$descriptor() {
        return archive_entry_atime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t archive_entry_atime(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_atime$handle() {
        return archive_entry_atime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t archive_entry_atime(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_atime$address() {
        return archive_entry_atime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t archive_entry_atime(struct archive_entry *)
     * }
     */
    public static long archive_entry_atime(MemorySegment x0) {
        var mh$ = archive_entry_atime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_atime", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_atime_nsec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_atime_nsec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long archive_entry_atime_nsec(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_atime_nsec$descriptor() {
        return archive_entry_atime_nsec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long archive_entry_atime_nsec(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_atime_nsec$handle() {
        return archive_entry_atime_nsec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long archive_entry_atime_nsec(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_atime_nsec$address() {
        return archive_entry_atime_nsec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long archive_entry_atime_nsec(struct archive_entry *)
     * }
     */
    public static long archive_entry_atime_nsec(MemorySegment x0) {
        var mh$ = archive_entry_atime_nsec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_atime_nsec", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_atime_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_atime_is_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_atime_is_set(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_atime_is_set$descriptor() {
        return archive_entry_atime_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_atime_is_set(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_atime_is_set$handle() {
        return archive_entry_atime_is_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_atime_is_set(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_atime_is_set$address() {
        return archive_entry_atime_is_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_atime_is_set(struct archive_entry *)
     * }
     */
    public static int archive_entry_atime_is_set(MemorySegment x0) {
        var mh$ = archive_entry_atime_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_atime_is_set", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_birthtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_birthtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t archive_entry_birthtime(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_birthtime$descriptor() {
        return archive_entry_birthtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t archive_entry_birthtime(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_birthtime$handle() {
        return archive_entry_birthtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t archive_entry_birthtime(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_birthtime$address() {
        return archive_entry_birthtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t archive_entry_birthtime(struct archive_entry *)
     * }
     */
    public static long archive_entry_birthtime(MemorySegment x0) {
        var mh$ = archive_entry_birthtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_birthtime", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_birthtime_nsec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_birthtime_nsec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long archive_entry_birthtime_nsec(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_birthtime_nsec$descriptor() {
        return archive_entry_birthtime_nsec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long archive_entry_birthtime_nsec(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_birthtime_nsec$handle() {
        return archive_entry_birthtime_nsec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long archive_entry_birthtime_nsec(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_birthtime_nsec$address() {
        return archive_entry_birthtime_nsec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long archive_entry_birthtime_nsec(struct archive_entry *)
     * }
     */
    public static long archive_entry_birthtime_nsec(MemorySegment x0) {
        var mh$ = archive_entry_birthtime_nsec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_birthtime_nsec", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_birthtime_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_birthtime_is_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_birthtime_is_set(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_birthtime_is_set$descriptor() {
        return archive_entry_birthtime_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_birthtime_is_set(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_birthtime_is_set$handle() {
        return archive_entry_birthtime_is_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_birthtime_is_set(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_birthtime_is_set$address() {
        return archive_entry_birthtime_is_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_birthtime_is_set(struct archive_entry *)
     * }
     */
    public static int archive_entry_birthtime_is_set(MemorySegment x0) {
        var mh$ = archive_entry_birthtime_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_birthtime_is_set", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t archive_entry_ctime(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_ctime$descriptor() {
        return archive_entry_ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t archive_entry_ctime(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_ctime$handle() {
        return archive_entry_ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t archive_entry_ctime(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_ctime$address() {
        return archive_entry_ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t archive_entry_ctime(struct archive_entry *)
     * }
     */
    public static long archive_entry_ctime(MemorySegment x0) {
        var mh$ = archive_entry_ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_ctime", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_ctime_nsec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_ctime_nsec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long archive_entry_ctime_nsec(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_ctime_nsec$descriptor() {
        return archive_entry_ctime_nsec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long archive_entry_ctime_nsec(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_ctime_nsec$handle() {
        return archive_entry_ctime_nsec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long archive_entry_ctime_nsec(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_ctime_nsec$address() {
        return archive_entry_ctime_nsec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long archive_entry_ctime_nsec(struct archive_entry *)
     * }
     */
    public static long archive_entry_ctime_nsec(MemorySegment x0) {
        var mh$ = archive_entry_ctime_nsec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_ctime_nsec", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_ctime_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_ctime_is_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_ctime_is_set(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_ctime_is_set$descriptor() {
        return archive_entry_ctime_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_ctime_is_set(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_ctime_is_set$handle() {
        return archive_entry_ctime_is_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_ctime_is_set(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_ctime_is_set$address() {
        return archive_entry_ctime_is_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_ctime_is_set(struct archive_entry *)
     * }
     */
    public static int archive_entry_ctime_is_set(MemorySegment x0) {
        var mh$ = archive_entry_ctime_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_ctime_is_set", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_dev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_dev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * dev_t archive_entry_dev(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_dev$descriptor() {
        return archive_entry_dev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * dev_t archive_entry_dev(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_dev$handle() {
        return archive_entry_dev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * dev_t archive_entry_dev(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_dev$address() {
        return archive_entry_dev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * dev_t archive_entry_dev(struct archive_entry *)
     * }
     */
    public static int archive_entry_dev(MemorySegment x0) {
        var mh$ = archive_entry_dev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_dev", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_dev_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_dev_is_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_dev_is_set(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_dev_is_set$descriptor() {
        return archive_entry_dev_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_dev_is_set(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_dev_is_set$handle() {
        return archive_entry_dev_is_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_dev_is_set(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_dev_is_set$address() {
        return archive_entry_dev_is_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_dev_is_set(struct archive_entry *)
     * }
     */
    public static int archive_entry_dev_is_set(MemorySegment x0) {
        var mh$ = archive_entry_dev_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_dev_is_set", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_devmajor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_devmajor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * dev_t archive_entry_devmajor(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_devmajor$descriptor() {
        return archive_entry_devmajor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * dev_t archive_entry_devmajor(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_devmajor$handle() {
        return archive_entry_devmajor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * dev_t archive_entry_devmajor(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_devmajor$address() {
        return archive_entry_devmajor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * dev_t archive_entry_devmajor(struct archive_entry *)
     * }
     */
    public static int archive_entry_devmajor(MemorySegment x0) {
        var mh$ = archive_entry_devmajor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_devmajor", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_devminor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_devminor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * dev_t archive_entry_devminor(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_devminor$descriptor() {
        return archive_entry_devminor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * dev_t archive_entry_devminor(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_devminor$handle() {
        return archive_entry_devminor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * dev_t archive_entry_devminor(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_devminor$address() {
        return archive_entry_devminor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * dev_t archive_entry_devminor(struct archive_entry *)
     * }
     */
    public static int archive_entry_devminor(MemorySegment x0) {
        var mh$ = archive_entry_devminor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_devminor", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_filetype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_SHORT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_filetype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t archive_entry_filetype(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_filetype$descriptor() {
        return archive_entry_filetype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t archive_entry_filetype(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_filetype$handle() {
        return archive_entry_filetype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t archive_entry_filetype(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_filetype$address() {
        return archive_entry_filetype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t archive_entry_filetype(struct archive_entry *)
     * }
     */
    public static short archive_entry_filetype(MemorySegment x0) {
        var mh$ = archive_entry_filetype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_filetype", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_fflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_fflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_fflags(struct archive_entry *, unsigned long *, unsigned long *)
     * }
     */
    public static FunctionDescriptor archive_entry_fflags$descriptor() {
        return archive_entry_fflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_fflags(struct archive_entry *, unsigned long *, unsigned long *)
     * }
     */
    public static MethodHandle archive_entry_fflags$handle() {
        return archive_entry_fflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_fflags(struct archive_entry *, unsigned long *, unsigned long *)
     * }
     */
    public static MemorySegment archive_entry_fflags$address() {
        return archive_entry_fflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_fflags(struct archive_entry *, unsigned long *, unsigned long *)
     * }
     */
    public static void archive_entry_fflags(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = archive_entry_fflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_fflags", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_fflags_text {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_fflags_text");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_fflags_text(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_fflags_text$descriptor() {
        return archive_entry_fflags_text.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_fflags_text(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_fflags_text$handle() {
        return archive_entry_fflags_text.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_fflags_text(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_fflags_text$address() {
        return archive_entry_fflags_text.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_fflags_text(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_fflags_text(MemorySegment x0) {
        var mh$ = archive_entry_fflags_text.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_fflags_text", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_gid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_gid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_gid(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_gid$descriptor() {
        return archive_entry_gid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_gid(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_gid$handle() {
        return archive_entry_gid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_gid(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_gid$address() {
        return archive_entry_gid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_entry_gid(struct archive_entry *)
     * }
     */
    public static long archive_entry_gid(MemorySegment x0) {
        var mh$ = archive_entry_gid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_gid", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_gname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_gname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_gname(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_gname$descriptor() {
        return archive_entry_gname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_gname(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_gname$handle() {
        return archive_entry_gname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_gname(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_gname$address() {
        return archive_entry_gname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_gname(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_gname(MemorySegment x0) {
        var mh$ = archive_entry_gname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_gname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_gname_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_gname_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_gname_utf8(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_gname_utf8$descriptor() {
        return archive_entry_gname_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_gname_utf8(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_gname_utf8$handle() {
        return archive_entry_gname_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_gname_utf8(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_gname_utf8$address() {
        return archive_entry_gname_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_gname_utf8(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_gname_utf8(MemorySegment x0) {
        var mh$ = archive_entry_gname_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_gname_utf8", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_gname_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_gname_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_gname_w(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_gname_w$descriptor() {
        return archive_entry_gname_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_gname_w(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_gname_w$handle() {
        return archive_entry_gname_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_gname_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_gname_w$address() {
        return archive_entry_gname_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wchar_t *archive_entry_gname_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_gname_w(MemorySegment x0) {
        var mh$ = archive_entry_gname_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_gname_w", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_hardlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_hardlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_hardlink(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_hardlink$descriptor() {
        return archive_entry_hardlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_hardlink(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_hardlink$handle() {
        return archive_entry_hardlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_hardlink(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_hardlink$address() {
        return archive_entry_hardlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_hardlink(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_hardlink(MemorySegment x0) {
        var mh$ = archive_entry_hardlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_hardlink", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_hardlink_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_hardlink_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_hardlink_utf8(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_hardlink_utf8$descriptor() {
        return archive_entry_hardlink_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_hardlink_utf8(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_hardlink_utf8$handle() {
        return archive_entry_hardlink_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_hardlink_utf8(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_hardlink_utf8$address() {
        return archive_entry_hardlink_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_hardlink_utf8(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_hardlink_utf8(MemorySegment x0) {
        var mh$ = archive_entry_hardlink_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_hardlink_utf8", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_hardlink_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_hardlink_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_hardlink_w(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_hardlink_w$descriptor() {
        return archive_entry_hardlink_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_hardlink_w(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_hardlink_w$handle() {
        return archive_entry_hardlink_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_hardlink_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_hardlink_w$address() {
        return archive_entry_hardlink_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wchar_t *archive_entry_hardlink_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_hardlink_w(MemorySegment x0) {
        var mh$ = archive_entry_hardlink_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_hardlink_w", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_ino {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_ino");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_ino(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_ino$descriptor() {
        return archive_entry_ino.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_ino(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_ino$handle() {
        return archive_entry_ino.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_ino(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_ino$address() {
        return archive_entry_ino.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_entry_ino(struct archive_entry *)
     * }
     */
    public static long archive_entry_ino(MemorySegment x0) {
        var mh$ = archive_entry_ino.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_ino", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_ino64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_ino64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_ino64(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_ino64$descriptor() {
        return archive_entry_ino64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_ino64(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_ino64$handle() {
        return archive_entry_ino64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_ino64(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_ino64$address() {
        return archive_entry_ino64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_entry_ino64(struct archive_entry *)
     * }
     */
    public static long archive_entry_ino64(MemorySegment x0) {
        var mh$ = archive_entry_ino64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_ino64", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_ino_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_ino_is_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_ino_is_set(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_ino_is_set$descriptor() {
        return archive_entry_ino_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_ino_is_set(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_ino_is_set$handle() {
        return archive_entry_ino_is_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_ino_is_set(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_ino_is_set$address() {
        return archive_entry_ino_is_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_ino_is_set(struct archive_entry *)
     * }
     */
    public static int archive_entry_ino_is_set(MemorySegment x0) {
        var mh$ = archive_entry_ino_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_ino_is_set", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_SHORT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t archive_entry_mode(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_mode$descriptor() {
        return archive_entry_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t archive_entry_mode(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_mode$handle() {
        return archive_entry_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t archive_entry_mode(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_mode$address() {
        return archive_entry_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t archive_entry_mode(struct archive_entry *)
     * }
     */
    public static short archive_entry_mode(MemorySegment x0) {
        var mh$ = archive_entry_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_mode", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_mtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_mtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t archive_entry_mtime(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_mtime$descriptor() {
        return archive_entry_mtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t archive_entry_mtime(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_mtime$handle() {
        return archive_entry_mtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t archive_entry_mtime(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_mtime$address() {
        return archive_entry_mtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t archive_entry_mtime(struct archive_entry *)
     * }
     */
    public static long archive_entry_mtime(MemorySegment x0) {
        var mh$ = archive_entry_mtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_mtime", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_mtime_nsec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_mtime_nsec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long archive_entry_mtime_nsec(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_mtime_nsec$descriptor() {
        return archive_entry_mtime_nsec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long archive_entry_mtime_nsec(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_mtime_nsec$handle() {
        return archive_entry_mtime_nsec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long archive_entry_mtime_nsec(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_mtime_nsec$address() {
        return archive_entry_mtime_nsec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long archive_entry_mtime_nsec(struct archive_entry *)
     * }
     */
    public static long archive_entry_mtime_nsec(MemorySegment x0) {
        var mh$ = archive_entry_mtime_nsec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_mtime_nsec", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_mtime_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_mtime_is_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_mtime_is_set(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_mtime_is_set$descriptor() {
        return archive_entry_mtime_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_mtime_is_set(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_mtime_is_set$handle() {
        return archive_entry_mtime_is_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_mtime_is_set(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_mtime_is_set$address() {
        return archive_entry_mtime_is_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_mtime_is_set(struct archive_entry *)
     * }
     */
    public static int archive_entry_mtime_is_set(MemorySegment x0) {
        var mh$ = archive_entry_mtime_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_mtime_is_set", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_nlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_nlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int archive_entry_nlink(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_nlink$descriptor() {
        return archive_entry_nlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int archive_entry_nlink(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_nlink$handle() {
        return archive_entry_nlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int archive_entry_nlink(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_nlink$address() {
        return archive_entry_nlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int archive_entry_nlink(struct archive_entry *)
     * }
     */
    public static int archive_entry_nlink(MemorySegment x0) {
        var mh$ = archive_entry_nlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_nlink", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_pathname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_pathname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_pathname(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_pathname$descriptor() {
        return archive_entry_pathname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_pathname(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_pathname$handle() {
        return archive_entry_pathname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_pathname(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_pathname$address() {
        return archive_entry_pathname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_pathname(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_pathname(MemorySegment x0) {
        var mh$ = archive_entry_pathname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_pathname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_pathname_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_pathname_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_pathname_utf8(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_pathname_utf8$descriptor() {
        return archive_entry_pathname_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_pathname_utf8(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_pathname_utf8$handle() {
        return archive_entry_pathname_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_pathname_utf8(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_pathname_utf8$address() {
        return archive_entry_pathname_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_pathname_utf8(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_pathname_utf8(MemorySegment x0) {
        var mh$ = archive_entry_pathname_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_pathname_utf8", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_pathname_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_pathname_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_pathname_w(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_pathname_w$descriptor() {
        return archive_entry_pathname_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_pathname_w(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_pathname_w$handle() {
        return archive_entry_pathname_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_pathname_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_pathname_w$address() {
        return archive_entry_pathname_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wchar_t *archive_entry_pathname_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_pathname_w(MemorySegment x0) {
        var mh$ = archive_entry_pathname_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_pathname_w", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_perm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_SHORT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_perm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t archive_entry_perm(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_perm$descriptor() {
        return archive_entry_perm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t archive_entry_perm(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_perm$handle() {
        return archive_entry_perm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t archive_entry_perm(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_perm$address() {
        return archive_entry_perm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t archive_entry_perm(struct archive_entry *)
     * }
     */
    public static short archive_entry_perm(MemorySegment x0) {
        var mh$ = archive_entry_perm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_perm", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_rdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_rdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * dev_t archive_entry_rdev(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_rdev$descriptor() {
        return archive_entry_rdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * dev_t archive_entry_rdev(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_rdev$handle() {
        return archive_entry_rdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * dev_t archive_entry_rdev(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_rdev$address() {
        return archive_entry_rdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * dev_t archive_entry_rdev(struct archive_entry *)
     * }
     */
    public static int archive_entry_rdev(MemorySegment x0) {
        var mh$ = archive_entry_rdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_rdev", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_rdevmajor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_rdevmajor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * dev_t archive_entry_rdevmajor(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_rdevmajor$descriptor() {
        return archive_entry_rdevmajor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * dev_t archive_entry_rdevmajor(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_rdevmajor$handle() {
        return archive_entry_rdevmajor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * dev_t archive_entry_rdevmajor(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_rdevmajor$address() {
        return archive_entry_rdevmajor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * dev_t archive_entry_rdevmajor(struct archive_entry *)
     * }
     */
    public static int archive_entry_rdevmajor(MemorySegment x0) {
        var mh$ = archive_entry_rdevmajor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_rdevmajor", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_rdevminor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_rdevminor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * dev_t archive_entry_rdevminor(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_rdevminor$descriptor() {
        return archive_entry_rdevminor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * dev_t archive_entry_rdevminor(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_rdevminor$handle() {
        return archive_entry_rdevminor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * dev_t archive_entry_rdevminor(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_rdevminor$address() {
        return archive_entry_rdevminor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * dev_t archive_entry_rdevminor(struct archive_entry *)
     * }
     */
    public static int archive_entry_rdevminor(MemorySegment x0) {
        var mh$ = archive_entry_rdevminor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_rdevminor", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_sourcepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_sourcepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_sourcepath(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_sourcepath$descriptor() {
        return archive_entry_sourcepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_sourcepath(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_sourcepath$handle() {
        return archive_entry_sourcepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_sourcepath(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_sourcepath$address() {
        return archive_entry_sourcepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_sourcepath(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_sourcepath(MemorySegment x0) {
        var mh$ = archive_entry_sourcepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_sourcepath", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_sourcepath_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_sourcepath_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_sourcepath_w(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_sourcepath_w$descriptor() {
        return archive_entry_sourcepath_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_sourcepath_w(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_sourcepath_w$handle() {
        return archive_entry_sourcepath_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_sourcepath_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_sourcepath_w$address() {
        return archive_entry_sourcepath_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wchar_t *archive_entry_sourcepath_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_sourcepath_w(MemorySegment x0) {
        var mh$ = archive_entry_sourcepath_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_sourcepath_w", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_size(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_size$descriptor() {
        return archive_entry_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_size(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_size$handle() {
        return archive_entry_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_size(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_size$address() {
        return archive_entry_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_entry_size(struct archive_entry *)
     * }
     */
    public static long archive_entry_size(MemorySegment x0) {
        var mh$ = archive_entry_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_size_is_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_size_is_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_size_is_set(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_size_is_set$descriptor() {
        return archive_entry_size_is_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_size_is_set(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_size_is_set$handle() {
        return archive_entry_size_is_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_size_is_set(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_size_is_set$address() {
        return archive_entry_size_is_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_size_is_set(struct archive_entry *)
     * }
     */
    public static int archive_entry_size_is_set(MemorySegment x0) {
        var mh$ = archive_entry_size_is_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_size_is_set", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_strmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_strmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_strmode(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_strmode$descriptor() {
        return archive_entry_strmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_strmode(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_strmode$handle() {
        return archive_entry_strmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_strmode(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_strmode$address() {
        return archive_entry_strmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_strmode(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_strmode(MemorySegment x0) {
        var mh$ = archive_entry_strmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_strmode", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_symlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_symlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_symlink(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_symlink$descriptor() {
        return archive_entry_symlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_symlink(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_symlink$handle() {
        return archive_entry_symlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_symlink(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_symlink$address() {
        return archive_entry_symlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_symlink(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_symlink(MemorySegment x0) {
        var mh$ = archive_entry_symlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_symlink", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_symlink_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_symlink_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_symlink_utf8(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_symlink_utf8$descriptor() {
        return archive_entry_symlink_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_symlink_utf8(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_symlink_utf8$handle() {
        return archive_entry_symlink_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_symlink_utf8(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_symlink_utf8$address() {
        return archive_entry_symlink_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_symlink_utf8(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_symlink_utf8(MemorySegment x0) {
        var mh$ = archive_entry_symlink_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_symlink_utf8", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_symlink_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_symlink_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_symlink_type(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_symlink_type$descriptor() {
        return archive_entry_symlink_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_symlink_type(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_symlink_type$handle() {
        return archive_entry_symlink_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_symlink_type(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_symlink_type$address() {
        return archive_entry_symlink_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_symlink_type(struct archive_entry *)
     * }
     */
    public static int archive_entry_symlink_type(MemorySegment x0) {
        var mh$ = archive_entry_symlink_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_symlink_type", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_symlink_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_symlink_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_symlink_w(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_symlink_w$descriptor() {
        return archive_entry_symlink_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_symlink_w(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_symlink_w$handle() {
        return archive_entry_symlink_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_symlink_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_symlink_w$address() {
        return archive_entry_symlink_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wchar_t *archive_entry_symlink_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_symlink_w(MemorySegment x0) {
        var mh$ = archive_entry_symlink_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_symlink_w", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_uid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_uid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_uid(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_uid$descriptor() {
        return archive_entry_uid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_uid(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_uid$handle() {
        return archive_entry_uid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * la_int64_t archive_entry_uid(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_uid$address() {
        return archive_entry_uid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * la_int64_t archive_entry_uid(struct archive_entry *)
     * }
     */
    public static long archive_entry_uid(MemorySegment x0) {
        var mh$ = archive_entry_uid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_uid", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_uname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_uname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_uname(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_uname$descriptor() {
        return archive_entry_uname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_uname(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_uname$handle() {
        return archive_entry_uname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_uname(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_uname$address() {
        return archive_entry_uname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_uname(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_uname(MemorySegment x0) {
        var mh$ = archive_entry_uname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_uname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_uname_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_uname_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_uname_utf8(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_uname_utf8$descriptor() {
        return archive_entry_uname_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_uname_utf8(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_uname_utf8$handle() {
        return archive_entry_uname_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_uname_utf8(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_uname_utf8$address() {
        return archive_entry_uname_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_uname_utf8(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_uname_utf8(MemorySegment x0) {
        var mh$ = archive_entry_uname_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_uname_utf8", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_uname_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_uname_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_uname_w(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_uname_w$descriptor() {
        return archive_entry_uname_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_uname_w(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_uname_w$handle() {
        return archive_entry_uname_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_uname_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_uname_w$address() {
        return archive_entry_uname_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wchar_t *archive_entry_uname_w(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_uname_w(MemorySegment x0) {
        var mh$ = archive_entry_uname_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_uname_w", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_is_data_encrypted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_is_data_encrypted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_is_data_encrypted(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_is_data_encrypted$descriptor() {
        return archive_entry_is_data_encrypted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_is_data_encrypted(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_is_data_encrypted$handle() {
        return archive_entry_is_data_encrypted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_is_data_encrypted(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_is_data_encrypted$address() {
        return archive_entry_is_data_encrypted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_is_data_encrypted(struct archive_entry *)
     * }
     */
    public static int archive_entry_is_data_encrypted(MemorySegment x0) {
        var mh$ = archive_entry_is_data_encrypted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_is_data_encrypted", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_is_metadata_encrypted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_is_metadata_encrypted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_is_metadata_encrypted(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_is_metadata_encrypted$descriptor() {
        return archive_entry_is_metadata_encrypted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_is_metadata_encrypted(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_is_metadata_encrypted$handle() {
        return archive_entry_is_metadata_encrypted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_is_metadata_encrypted(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_is_metadata_encrypted$address() {
        return archive_entry_is_metadata_encrypted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_is_metadata_encrypted(struct archive_entry *)
     * }
     */
    public static int archive_entry_is_metadata_encrypted(MemorySegment x0) {
        var mh$ = archive_entry_is_metadata_encrypted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_is_metadata_encrypted", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_is_encrypted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_is_encrypted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_is_encrypted(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_is_encrypted$descriptor() {
        return archive_entry_is_encrypted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_is_encrypted(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_is_encrypted$handle() {
        return archive_entry_is_encrypted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_is_encrypted(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_is_encrypted$address() {
        return archive_entry_is_encrypted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_is_encrypted(struct archive_entry *)
     * }
     */
    public static int archive_entry_is_encrypted(MemorySegment x0) {
        var mh$ = archive_entry_is_encrypted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_is_encrypted", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_atime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_atime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_atime(struct archive_entry *, time_t, long)
     * }
     */
    public static FunctionDescriptor archive_entry_set_atime$descriptor() {
        return archive_entry_set_atime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_atime(struct archive_entry *, time_t, long)
     * }
     */
    public static MethodHandle archive_entry_set_atime$handle() {
        return archive_entry_set_atime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_atime(struct archive_entry *, time_t, long)
     * }
     */
    public static MemorySegment archive_entry_set_atime$address() {
        return archive_entry_set_atime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_atime(struct archive_entry *, time_t, long)
     * }
     */
    public static void archive_entry_set_atime(MemorySegment x0, long x1, long x2) {
        var mh$ = archive_entry_set_atime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_atime", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_unset_atime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_unset_atime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_unset_atime(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_unset_atime$descriptor() {
        return archive_entry_unset_atime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_unset_atime(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_unset_atime$handle() {
        return archive_entry_unset_atime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_unset_atime(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_unset_atime$address() {
        return archive_entry_unset_atime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_unset_atime(struct archive_entry *)
     * }
     */
    public static void archive_entry_unset_atime(MemorySegment x0) {
        var mh$ = archive_entry_unset_atime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_unset_atime", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_birthtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_birthtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_birthtime(struct archive_entry *, time_t, long)
     * }
     */
    public static FunctionDescriptor archive_entry_set_birthtime$descriptor() {
        return archive_entry_set_birthtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_birthtime(struct archive_entry *, time_t, long)
     * }
     */
    public static MethodHandle archive_entry_set_birthtime$handle() {
        return archive_entry_set_birthtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_birthtime(struct archive_entry *, time_t, long)
     * }
     */
    public static MemorySegment archive_entry_set_birthtime$address() {
        return archive_entry_set_birthtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_birthtime(struct archive_entry *, time_t, long)
     * }
     */
    public static void archive_entry_set_birthtime(MemorySegment x0, long x1, long x2) {
        var mh$ = archive_entry_set_birthtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_birthtime", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_unset_birthtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_unset_birthtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_unset_birthtime(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_unset_birthtime$descriptor() {
        return archive_entry_unset_birthtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_unset_birthtime(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_unset_birthtime$handle() {
        return archive_entry_unset_birthtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_unset_birthtime(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_unset_birthtime$address() {
        return archive_entry_unset_birthtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_unset_birthtime(struct archive_entry *)
     * }
     */
    public static void archive_entry_unset_birthtime(MemorySegment x0) {
        var mh$ = archive_entry_unset_birthtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_unset_birthtime", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_ctime(struct archive_entry *, time_t, long)
     * }
     */
    public static FunctionDescriptor archive_entry_set_ctime$descriptor() {
        return archive_entry_set_ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_ctime(struct archive_entry *, time_t, long)
     * }
     */
    public static MethodHandle archive_entry_set_ctime$handle() {
        return archive_entry_set_ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_ctime(struct archive_entry *, time_t, long)
     * }
     */
    public static MemorySegment archive_entry_set_ctime$address() {
        return archive_entry_set_ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_ctime(struct archive_entry *, time_t, long)
     * }
     */
    public static void archive_entry_set_ctime(MemorySegment x0, long x1, long x2) {
        var mh$ = archive_entry_set_ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_ctime", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_unset_ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_unset_ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_unset_ctime(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_unset_ctime$descriptor() {
        return archive_entry_unset_ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_unset_ctime(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_unset_ctime$handle() {
        return archive_entry_unset_ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_unset_ctime(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_unset_ctime$address() {
        return archive_entry_unset_ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_unset_ctime(struct archive_entry *)
     * }
     */
    public static void archive_entry_unset_ctime(MemorySegment x0) {
        var mh$ = archive_entry_unset_ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_unset_ctime", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_dev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_dev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_dev(struct archive_entry *, dev_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_dev$descriptor() {
        return archive_entry_set_dev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_dev(struct archive_entry *, dev_t)
     * }
     */
    public static MethodHandle archive_entry_set_dev$handle() {
        return archive_entry_set_dev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_dev(struct archive_entry *, dev_t)
     * }
     */
    public static MemorySegment archive_entry_set_dev$address() {
        return archive_entry_set_dev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_dev(struct archive_entry *, dev_t)
     * }
     */
    public static void archive_entry_set_dev(MemorySegment x0, int x1) {
        var mh$ = archive_entry_set_dev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_dev", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_devmajor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_devmajor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_devmajor(struct archive_entry *, dev_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_devmajor$descriptor() {
        return archive_entry_set_devmajor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_devmajor(struct archive_entry *, dev_t)
     * }
     */
    public static MethodHandle archive_entry_set_devmajor$handle() {
        return archive_entry_set_devmajor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_devmajor(struct archive_entry *, dev_t)
     * }
     */
    public static MemorySegment archive_entry_set_devmajor$address() {
        return archive_entry_set_devmajor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_devmajor(struct archive_entry *, dev_t)
     * }
     */
    public static void archive_entry_set_devmajor(MemorySegment x0, int x1) {
        var mh$ = archive_entry_set_devmajor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_devmajor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_devminor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_devminor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_devminor(struct archive_entry *, dev_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_devminor$descriptor() {
        return archive_entry_set_devminor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_devminor(struct archive_entry *, dev_t)
     * }
     */
    public static MethodHandle archive_entry_set_devminor$handle() {
        return archive_entry_set_devminor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_devminor(struct archive_entry *, dev_t)
     * }
     */
    public static MemorySegment archive_entry_set_devminor$address() {
        return archive_entry_set_devminor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_devminor(struct archive_entry *, dev_t)
     * }
     */
    public static void archive_entry_set_devminor(MemorySegment x0, int x1) {
        var mh$ = archive_entry_set_devminor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_devminor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_filetype {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_filetype");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_filetype(struct archive_entry *, unsigned int)
     * }
     */
    public static FunctionDescriptor archive_entry_set_filetype$descriptor() {
        return archive_entry_set_filetype.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_filetype(struct archive_entry *, unsigned int)
     * }
     */
    public static MethodHandle archive_entry_set_filetype$handle() {
        return archive_entry_set_filetype.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_filetype(struct archive_entry *, unsigned int)
     * }
     */
    public static MemorySegment archive_entry_set_filetype$address() {
        return archive_entry_set_filetype.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_filetype(struct archive_entry *, unsigned int)
     * }
     */
    public static void archive_entry_set_filetype(MemorySegment x0, int x1) {
        var mh$ = archive_entry_set_filetype.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_filetype", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_fflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_fflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_fflags(struct archive_entry *, unsigned long, unsigned long)
     * }
     */
    public static FunctionDescriptor archive_entry_set_fflags$descriptor() {
        return archive_entry_set_fflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_fflags(struct archive_entry *, unsigned long, unsigned long)
     * }
     */
    public static MethodHandle archive_entry_set_fflags$handle() {
        return archive_entry_set_fflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_fflags(struct archive_entry *, unsigned long, unsigned long)
     * }
     */
    public static MemorySegment archive_entry_set_fflags$address() {
        return archive_entry_set_fflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_fflags(struct archive_entry *, unsigned long, unsigned long)
     * }
     */
    public static void archive_entry_set_fflags(MemorySegment x0, long x1, long x2) {
        var mh$ = archive_entry_set_fflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_fflags", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_fflags_text {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_fflags_text");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_copy_fflags_text(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_fflags_text$descriptor() {
        return archive_entry_copy_fflags_text.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_copy_fflags_text(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_copy_fflags_text$handle() {
        return archive_entry_copy_fflags_text.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_copy_fflags_text(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_copy_fflags_text$address() {
        return archive_entry_copy_fflags_text.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_copy_fflags_text(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_copy_fflags_text(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_fflags_text.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_fflags_text", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_fflags_text_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_fflags_text_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_copy_fflags_text_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_fflags_text_w$descriptor() {
        return archive_entry_copy_fflags_text_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_copy_fflags_text_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_entry_copy_fflags_text_w$handle() {
        return archive_entry_copy_fflags_text_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_copy_fflags_text_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_entry_copy_fflags_text_w$address() {
        return archive_entry_copy_fflags_text_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wchar_t *archive_entry_copy_fflags_text_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_entry_copy_fflags_text_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_fflags_text_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_fflags_text_w", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_gid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_gid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_gid(struct archive_entry *, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_gid$descriptor() {
        return archive_entry_set_gid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_gid(struct archive_entry *, la_int64_t)
     * }
     */
    public static MethodHandle archive_entry_set_gid$handle() {
        return archive_entry_set_gid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_gid(struct archive_entry *, la_int64_t)
     * }
     */
    public static MemorySegment archive_entry_set_gid$address() {
        return archive_entry_set_gid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_gid(struct archive_entry *, la_int64_t)
     * }
     */
    public static void archive_entry_set_gid(MemorySegment x0, long x1) {
        var mh$ = archive_entry_set_gid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_gid", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_gname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_gname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_gname(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_gname$descriptor() {
        return archive_entry_set_gname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_gname(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_gname$handle() {
        return archive_entry_set_gname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_gname(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_gname$address() {
        return archive_entry_set_gname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_gname(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_gname(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_gname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_gname", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_gname_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_gname_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_gname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_gname_utf8$descriptor() {
        return archive_entry_set_gname_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_gname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_gname_utf8$handle() {
        return archive_entry_set_gname_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_gname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_gname_utf8$address() {
        return archive_entry_set_gname_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_gname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_gname_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_gname_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_gname_utf8", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_gname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_gname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_gname(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_gname$descriptor() {
        return archive_entry_copy_gname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_gname(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_copy_gname$handle() {
        return archive_entry_copy_gname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_gname(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_copy_gname$address() {
        return archive_entry_copy_gname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_gname(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_copy_gname(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_gname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_gname", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_gname_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_gname_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_gname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_gname_w$descriptor() {
        return archive_entry_copy_gname_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_gname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_entry_copy_gname_w$handle() {
        return archive_entry_copy_gname_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_gname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_entry_copy_gname_w$address() {
        return archive_entry_copy_gname_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_gname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static void archive_entry_copy_gname_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_gname_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_gname_w", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_update_gname_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_update_gname_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_update_gname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_update_gname_utf8$descriptor() {
        return archive_entry_update_gname_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_update_gname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_update_gname_utf8$handle() {
        return archive_entry_update_gname_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_update_gname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_update_gname_utf8$address() {
        return archive_entry_update_gname_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_update_gname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static int archive_entry_update_gname_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_update_gname_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_update_gname_utf8", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_hardlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_hardlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_hardlink(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_hardlink$descriptor() {
        return archive_entry_set_hardlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_hardlink(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_hardlink$handle() {
        return archive_entry_set_hardlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_hardlink(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_hardlink$address() {
        return archive_entry_set_hardlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_hardlink(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_hardlink(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_hardlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_hardlink", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_hardlink_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_hardlink_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_hardlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_hardlink_utf8$descriptor() {
        return archive_entry_set_hardlink_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_hardlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_hardlink_utf8$handle() {
        return archive_entry_set_hardlink_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_hardlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_hardlink_utf8$address() {
        return archive_entry_set_hardlink_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_hardlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_hardlink_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_hardlink_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_hardlink_utf8", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_hardlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_hardlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_hardlink(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_hardlink$descriptor() {
        return archive_entry_copy_hardlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_hardlink(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_copy_hardlink$handle() {
        return archive_entry_copy_hardlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_hardlink(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_copy_hardlink$address() {
        return archive_entry_copy_hardlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_hardlink(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_copy_hardlink(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_hardlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_hardlink", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_hardlink_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_hardlink_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_hardlink_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_hardlink_w$descriptor() {
        return archive_entry_copy_hardlink_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_hardlink_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_entry_copy_hardlink_w$handle() {
        return archive_entry_copy_hardlink_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_hardlink_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_entry_copy_hardlink_w$address() {
        return archive_entry_copy_hardlink_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_hardlink_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static void archive_entry_copy_hardlink_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_hardlink_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_hardlink_w", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_update_hardlink_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_update_hardlink_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_update_hardlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_update_hardlink_utf8$descriptor() {
        return archive_entry_update_hardlink_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_update_hardlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_update_hardlink_utf8$handle() {
        return archive_entry_update_hardlink_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_update_hardlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_update_hardlink_utf8$address() {
        return archive_entry_update_hardlink_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_update_hardlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static int archive_entry_update_hardlink_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_update_hardlink_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_update_hardlink_utf8", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_ino {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_ino");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_ino(struct archive_entry *, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_ino$descriptor() {
        return archive_entry_set_ino.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_ino(struct archive_entry *, la_int64_t)
     * }
     */
    public static MethodHandle archive_entry_set_ino$handle() {
        return archive_entry_set_ino.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_ino(struct archive_entry *, la_int64_t)
     * }
     */
    public static MemorySegment archive_entry_set_ino$address() {
        return archive_entry_set_ino.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_ino(struct archive_entry *, la_int64_t)
     * }
     */
    public static void archive_entry_set_ino(MemorySegment x0, long x1) {
        var mh$ = archive_entry_set_ino.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_ino", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_ino64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_ino64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_ino64(struct archive_entry *, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_ino64$descriptor() {
        return archive_entry_set_ino64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_ino64(struct archive_entry *, la_int64_t)
     * }
     */
    public static MethodHandle archive_entry_set_ino64$handle() {
        return archive_entry_set_ino64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_ino64(struct archive_entry *, la_int64_t)
     * }
     */
    public static MemorySegment archive_entry_set_ino64$address() {
        return archive_entry_set_ino64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_ino64(struct archive_entry *, la_int64_t)
     * }
     */
    public static void archive_entry_set_ino64(MemorySegment x0, long x1) {
        var mh$ = archive_entry_set_ino64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_ino64", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_link(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_link$descriptor() {
        return archive_entry_set_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_link(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_link$handle() {
        return archive_entry_set_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_link(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_link$address() {
        return archive_entry_set_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_link(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_link(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_link", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_link_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_link_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_link_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_link_utf8$descriptor() {
        return archive_entry_set_link_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_link_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_link_utf8$handle() {
        return archive_entry_set_link_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_link_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_link_utf8$address() {
        return archive_entry_set_link_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_link_utf8(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_link_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_link_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_link_utf8", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_link(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_link$descriptor() {
        return archive_entry_copy_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_link(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_copy_link$handle() {
        return archive_entry_copy_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_link(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_copy_link$address() {
        return archive_entry_copy_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_link(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_copy_link(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_link", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_link_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_link_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_link_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_link_w$descriptor() {
        return archive_entry_copy_link_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_link_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_entry_copy_link_w$handle() {
        return archive_entry_copy_link_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_link_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_entry_copy_link_w$address() {
        return archive_entry_copy_link_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_link_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static void archive_entry_copy_link_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_link_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_link_w", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_update_link_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_update_link_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_update_link_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_update_link_utf8$descriptor() {
        return archive_entry_update_link_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_update_link_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_update_link_utf8$handle() {
        return archive_entry_update_link_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_update_link_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_update_link_utf8$address() {
        return archive_entry_update_link_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_update_link_utf8(struct archive_entry *, const char *)
     * }
     */
    public static int archive_entry_update_link_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_update_link_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_update_link_utf8", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_mode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_mode(struct archive_entry *, mode_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_mode$descriptor() {
        return archive_entry_set_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_mode(struct archive_entry *, mode_t)
     * }
     */
    public static MethodHandle archive_entry_set_mode$handle() {
        return archive_entry_set_mode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_mode(struct archive_entry *, mode_t)
     * }
     */
    public static MemorySegment archive_entry_set_mode$address() {
        return archive_entry_set_mode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_mode(struct archive_entry *, mode_t)
     * }
     */
    public static void archive_entry_set_mode(MemorySegment x0, short x1) {
        var mh$ = archive_entry_set_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_mode", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_mtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_mtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_mtime(struct archive_entry *, time_t, long)
     * }
     */
    public static FunctionDescriptor archive_entry_set_mtime$descriptor() {
        return archive_entry_set_mtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_mtime(struct archive_entry *, time_t, long)
     * }
     */
    public static MethodHandle archive_entry_set_mtime$handle() {
        return archive_entry_set_mtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_mtime(struct archive_entry *, time_t, long)
     * }
     */
    public static MemorySegment archive_entry_set_mtime$address() {
        return archive_entry_set_mtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_mtime(struct archive_entry *, time_t, long)
     * }
     */
    public static void archive_entry_set_mtime(MemorySegment x0, long x1, long x2) {
        var mh$ = archive_entry_set_mtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_mtime", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_unset_mtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_unset_mtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_unset_mtime(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_unset_mtime$descriptor() {
        return archive_entry_unset_mtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_unset_mtime(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_unset_mtime$handle() {
        return archive_entry_unset_mtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_unset_mtime(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_unset_mtime$address() {
        return archive_entry_unset_mtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_unset_mtime(struct archive_entry *)
     * }
     */
    public static void archive_entry_unset_mtime(MemorySegment x0) {
        var mh$ = archive_entry_unset_mtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_unset_mtime", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_nlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_nlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_nlink(struct archive_entry *, unsigned int)
     * }
     */
    public static FunctionDescriptor archive_entry_set_nlink$descriptor() {
        return archive_entry_set_nlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_nlink(struct archive_entry *, unsigned int)
     * }
     */
    public static MethodHandle archive_entry_set_nlink$handle() {
        return archive_entry_set_nlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_nlink(struct archive_entry *, unsigned int)
     * }
     */
    public static MemorySegment archive_entry_set_nlink$address() {
        return archive_entry_set_nlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_nlink(struct archive_entry *, unsigned int)
     * }
     */
    public static void archive_entry_set_nlink(MemorySegment x0, int x1) {
        var mh$ = archive_entry_set_nlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_nlink", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_pathname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_pathname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_pathname(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_pathname$descriptor() {
        return archive_entry_set_pathname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_pathname(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_pathname$handle() {
        return archive_entry_set_pathname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_pathname(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_pathname$address() {
        return archive_entry_set_pathname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_pathname(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_pathname(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_pathname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_pathname", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_pathname_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_pathname_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_pathname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_pathname_utf8$descriptor() {
        return archive_entry_set_pathname_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_pathname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_pathname_utf8$handle() {
        return archive_entry_set_pathname_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_pathname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_pathname_utf8$address() {
        return archive_entry_set_pathname_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_pathname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_pathname_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_pathname_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_pathname_utf8", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_pathname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_pathname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_pathname(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_pathname$descriptor() {
        return archive_entry_copy_pathname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_pathname(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_copy_pathname$handle() {
        return archive_entry_copy_pathname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_pathname(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_copy_pathname$address() {
        return archive_entry_copy_pathname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_pathname(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_copy_pathname(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_pathname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_pathname", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_pathname_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_pathname_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_pathname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_pathname_w$descriptor() {
        return archive_entry_copy_pathname_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_pathname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_entry_copy_pathname_w$handle() {
        return archive_entry_copy_pathname_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_pathname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_entry_copy_pathname_w$address() {
        return archive_entry_copy_pathname_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_pathname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static void archive_entry_copy_pathname_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_pathname_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_pathname_w", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_update_pathname_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_update_pathname_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_update_pathname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_update_pathname_utf8$descriptor() {
        return archive_entry_update_pathname_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_update_pathname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_update_pathname_utf8$handle() {
        return archive_entry_update_pathname_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_update_pathname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_update_pathname_utf8$address() {
        return archive_entry_update_pathname_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_update_pathname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static int archive_entry_update_pathname_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_update_pathname_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_update_pathname_utf8", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_perm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_perm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_perm(struct archive_entry *, mode_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_perm$descriptor() {
        return archive_entry_set_perm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_perm(struct archive_entry *, mode_t)
     * }
     */
    public static MethodHandle archive_entry_set_perm$handle() {
        return archive_entry_set_perm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_perm(struct archive_entry *, mode_t)
     * }
     */
    public static MemorySegment archive_entry_set_perm$address() {
        return archive_entry_set_perm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_perm(struct archive_entry *, mode_t)
     * }
     */
    public static void archive_entry_set_perm(MemorySegment x0, short x1) {
        var mh$ = archive_entry_set_perm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_perm", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_rdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_rdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_rdev(struct archive_entry *, dev_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_rdev$descriptor() {
        return archive_entry_set_rdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_rdev(struct archive_entry *, dev_t)
     * }
     */
    public static MethodHandle archive_entry_set_rdev$handle() {
        return archive_entry_set_rdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_rdev(struct archive_entry *, dev_t)
     * }
     */
    public static MemorySegment archive_entry_set_rdev$address() {
        return archive_entry_set_rdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_rdev(struct archive_entry *, dev_t)
     * }
     */
    public static void archive_entry_set_rdev(MemorySegment x0, int x1) {
        var mh$ = archive_entry_set_rdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_rdev", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_rdevmajor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_rdevmajor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_rdevmajor(struct archive_entry *, dev_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_rdevmajor$descriptor() {
        return archive_entry_set_rdevmajor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_rdevmajor(struct archive_entry *, dev_t)
     * }
     */
    public static MethodHandle archive_entry_set_rdevmajor$handle() {
        return archive_entry_set_rdevmajor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_rdevmajor(struct archive_entry *, dev_t)
     * }
     */
    public static MemorySegment archive_entry_set_rdevmajor$address() {
        return archive_entry_set_rdevmajor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_rdevmajor(struct archive_entry *, dev_t)
     * }
     */
    public static void archive_entry_set_rdevmajor(MemorySegment x0, int x1) {
        var mh$ = archive_entry_set_rdevmajor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_rdevmajor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_rdevminor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_rdevminor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_rdevminor(struct archive_entry *, dev_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_rdevminor$descriptor() {
        return archive_entry_set_rdevminor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_rdevminor(struct archive_entry *, dev_t)
     * }
     */
    public static MethodHandle archive_entry_set_rdevminor$handle() {
        return archive_entry_set_rdevminor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_rdevminor(struct archive_entry *, dev_t)
     * }
     */
    public static MemorySegment archive_entry_set_rdevminor$address() {
        return archive_entry_set_rdevminor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_rdevminor(struct archive_entry *, dev_t)
     * }
     */
    public static void archive_entry_set_rdevminor(MemorySegment x0, int x1) {
        var mh$ = archive_entry_set_rdevminor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_rdevminor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_size(struct archive_entry *, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_size$descriptor() {
        return archive_entry_set_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_size(struct archive_entry *, la_int64_t)
     * }
     */
    public static MethodHandle archive_entry_set_size$handle() {
        return archive_entry_set_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_size(struct archive_entry *, la_int64_t)
     * }
     */
    public static MemorySegment archive_entry_set_size$address() {
        return archive_entry_set_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_size(struct archive_entry *, la_int64_t)
     * }
     */
    public static void archive_entry_set_size(MemorySegment x0, long x1) {
        var mh$ = archive_entry_set_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_size", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_unset_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_unset_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_unset_size(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_unset_size$descriptor() {
        return archive_entry_unset_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_unset_size(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_unset_size$handle() {
        return archive_entry_unset_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_unset_size(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_unset_size$address() {
        return archive_entry_unset_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_unset_size(struct archive_entry *)
     * }
     */
    public static void archive_entry_unset_size(MemorySegment x0) {
        var mh$ = archive_entry_unset_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_unset_size", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_sourcepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_sourcepath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_sourcepath(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_sourcepath$descriptor() {
        return archive_entry_copy_sourcepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_sourcepath(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_copy_sourcepath$handle() {
        return archive_entry_copy_sourcepath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_sourcepath(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_copy_sourcepath$address() {
        return archive_entry_copy_sourcepath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_sourcepath(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_copy_sourcepath(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_sourcepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_sourcepath", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_sourcepath_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_sourcepath_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_sourcepath_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_sourcepath_w$descriptor() {
        return archive_entry_copy_sourcepath_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_sourcepath_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_entry_copy_sourcepath_w$handle() {
        return archive_entry_copy_sourcepath_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_sourcepath_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_entry_copy_sourcepath_w$address() {
        return archive_entry_copy_sourcepath_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_sourcepath_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static void archive_entry_copy_sourcepath_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_sourcepath_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_sourcepath_w", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_symlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_symlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_symlink(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_symlink$descriptor() {
        return archive_entry_set_symlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_symlink(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_symlink$handle() {
        return archive_entry_set_symlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_symlink(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_symlink$address() {
        return archive_entry_set_symlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_symlink(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_symlink(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_symlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_symlink", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_symlink_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_symlink_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_symlink_type(struct archive_entry *, int)
     * }
     */
    public static FunctionDescriptor archive_entry_set_symlink_type$descriptor() {
        return archive_entry_set_symlink_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_symlink_type(struct archive_entry *, int)
     * }
     */
    public static MethodHandle archive_entry_set_symlink_type$handle() {
        return archive_entry_set_symlink_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_symlink_type(struct archive_entry *, int)
     * }
     */
    public static MemorySegment archive_entry_set_symlink_type$address() {
        return archive_entry_set_symlink_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_symlink_type(struct archive_entry *, int)
     * }
     */
    public static void archive_entry_set_symlink_type(MemorySegment x0, int x1) {
        var mh$ = archive_entry_set_symlink_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_symlink_type", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_symlink_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_symlink_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_symlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_symlink_utf8$descriptor() {
        return archive_entry_set_symlink_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_symlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_symlink_utf8$handle() {
        return archive_entry_set_symlink_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_symlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_symlink_utf8$address() {
        return archive_entry_set_symlink_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_symlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_symlink_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_symlink_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_symlink_utf8", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_symlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_symlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_symlink(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_symlink$descriptor() {
        return archive_entry_copy_symlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_symlink(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_copy_symlink$handle() {
        return archive_entry_copy_symlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_symlink(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_copy_symlink$address() {
        return archive_entry_copy_symlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_symlink(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_copy_symlink(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_symlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_symlink", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_symlink_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_symlink_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_symlink_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_symlink_w$descriptor() {
        return archive_entry_copy_symlink_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_symlink_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_entry_copy_symlink_w$handle() {
        return archive_entry_copy_symlink_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_symlink_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_entry_copy_symlink_w$address() {
        return archive_entry_copy_symlink_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_symlink_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static void archive_entry_copy_symlink_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_symlink_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_symlink_w", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_update_symlink_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_update_symlink_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_update_symlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_update_symlink_utf8$descriptor() {
        return archive_entry_update_symlink_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_update_symlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_update_symlink_utf8$handle() {
        return archive_entry_update_symlink_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_update_symlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_update_symlink_utf8$address() {
        return archive_entry_update_symlink_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_update_symlink_utf8(struct archive_entry *, const char *)
     * }
     */
    public static int archive_entry_update_symlink_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_update_symlink_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_update_symlink_utf8", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_uid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_uid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_uid(struct archive_entry *, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_entry_set_uid$descriptor() {
        return archive_entry_set_uid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_uid(struct archive_entry *, la_int64_t)
     * }
     */
    public static MethodHandle archive_entry_set_uid$handle() {
        return archive_entry_set_uid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_uid(struct archive_entry *, la_int64_t)
     * }
     */
    public static MemorySegment archive_entry_set_uid$address() {
        return archive_entry_set_uid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_uid(struct archive_entry *, la_int64_t)
     * }
     */
    public static void archive_entry_set_uid(MemorySegment x0, long x1) {
        var mh$ = archive_entry_set_uid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_uid", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_uname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_uname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_uname(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_uname$descriptor() {
        return archive_entry_set_uname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_uname(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_uname$handle() {
        return archive_entry_set_uname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_uname(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_uname$address() {
        return archive_entry_set_uname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_uname(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_uname(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_uname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_uname", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_uname_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_uname_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_uname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_set_uname_utf8$descriptor() {
        return archive_entry_set_uname_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_uname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_set_uname_utf8$handle() {
        return archive_entry_set_uname_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_uname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_set_uname_utf8$address() {
        return archive_entry_set_uname_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_uname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_set_uname_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_set_uname_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_uname_utf8", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_uname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_uname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_uname(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_uname$descriptor() {
        return archive_entry_copy_uname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_uname(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_copy_uname$handle() {
        return archive_entry_copy_uname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_uname(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_copy_uname$address() {
        return archive_entry_copy_uname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_uname(struct archive_entry *, const char *)
     * }
     */
    public static void archive_entry_copy_uname(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_uname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_uname", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_uname_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_uname_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_uname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_uname_w$descriptor() {
        return archive_entry_copy_uname_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_uname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MethodHandle archive_entry_copy_uname_w$handle() {
        return archive_entry_copy_uname_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_uname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static MemorySegment archive_entry_copy_uname_w$address() {
        return archive_entry_copy_uname_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_uname_w(struct archive_entry *, const wchar_t *)
     * }
     */
    public static void archive_entry_copy_uname_w(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_uname_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_uname_w", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_update_uname_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_update_uname_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_update_uname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_update_uname_utf8$descriptor() {
        return archive_entry_update_uname_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_update_uname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MethodHandle archive_entry_update_uname_utf8$handle() {
        return archive_entry_update_uname_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_update_uname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static MemorySegment archive_entry_update_uname_utf8$address() {
        return archive_entry_update_uname_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_update_uname_utf8(struct archive_entry *, const char *)
     * }
     */
    public static int archive_entry_update_uname_utf8(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_update_uname_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_update_uname_utf8", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_is_data_encrypted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_CHAR
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_is_data_encrypted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_is_data_encrypted(struct archive_entry *, char is_encrypted)
     * }
     */
    public static FunctionDescriptor archive_entry_set_is_data_encrypted$descriptor() {
        return archive_entry_set_is_data_encrypted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_is_data_encrypted(struct archive_entry *, char is_encrypted)
     * }
     */
    public static MethodHandle archive_entry_set_is_data_encrypted$handle() {
        return archive_entry_set_is_data_encrypted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_is_data_encrypted(struct archive_entry *, char is_encrypted)
     * }
     */
    public static MemorySegment archive_entry_set_is_data_encrypted$address() {
        return archive_entry_set_is_data_encrypted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_is_data_encrypted(struct archive_entry *, char is_encrypted)
     * }
     */
    public static void archive_entry_set_is_data_encrypted(MemorySegment x0, byte is_encrypted) {
        var mh$ = archive_entry_set_is_data_encrypted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_is_data_encrypted", x0, is_encrypted);
            }
            mh$.invokeExact(x0, is_encrypted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_set_is_metadata_encrypted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_CHAR
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_set_is_metadata_encrypted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_set_is_metadata_encrypted(struct archive_entry *, char is_encrypted)
     * }
     */
    public static FunctionDescriptor archive_entry_set_is_metadata_encrypted$descriptor() {
        return archive_entry_set_is_metadata_encrypted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_set_is_metadata_encrypted(struct archive_entry *, char is_encrypted)
     * }
     */
    public static MethodHandle archive_entry_set_is_metadata_encrypted$handle() {
        return archive_entry_set_is_metadata_encrypted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_set_is_metadata_encrypted(struct archive_entry *, char is_encrypted)
     * }
     */
    public static MemorySegment archive_entry_set_is_metadata_encrypted$address() {
        return archive_entry_set_is_metadata_encrypted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_set_is_metadata_encrypted(struct archive_entry *, char is_encrypted)
     * }
     */
    public static void archive_entry_set_is_metadata_encrypted(MemorySegment x0, byte is_encrypted) {
        var mh$ = archive_entry_set_is_metadata_encrypted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_set_is_metadata_encrypted", x0, is_encrypted);
            }
            mh$.invokeExact(x0, is_encrypted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_stat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_stat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct stat *archive_entry_stat(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_stat$descriptor() {
        return archive_entry_stat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct stat *archive_entry_stat(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_stat$handle() {
        return archive_entry_stat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct stat *archive_entry_stat(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_stat$address() {
        return archive_entry_stat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct stat *archive_entry_stat(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_stat(MemorySegment x0) {
        var mh$ = archive_entry_stat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_stat", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_stat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_stat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_stat(struct archive_entry *, const struct stat *)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_stat$descriptor() {
        return archive_entry_copy_stat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_stat(struct archive_entry *, const struct stat *)
     * }
     */
    public static MethodHandle archive_entry_copy_stat$handle() {
        return archive_entry_copy_stat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_stat(struct archive_entry *, const struct stat *)
     * }
     */
    public static MemorySegment archive_entry_copy_stat$address() {
        return archive_entry_copy_stat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_stat(struct archive_entry *, const struct stat *)
     * }
     */
    public static void archive_entry_copy_stat(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_copy_stat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_stat", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_mac_metadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_mac_metadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const void *archive_entry_mac_metadata(struct archive_entry *, size_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_mac_metadata$descriptor() {
        return archive_entry_mac_metadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const void *archive_entry_mac_metadata(struct archive_entry *, size_t *)
     * }
     */
    public static MethodHandle archive_entry_mac_metadata$handle() {
        return archive_entry_mac_metadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const void *archive_entry_mac_metadata(struct archive_entry *, size_t *)
     * }
     */
    public static MemorySegment archive_entry_mac_metadata$address() {
        return archive_entry_mac_metadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const void *archive_entry_mac_metadata(struct archive_entry *, size_t *)
     * }
     */
    public static MemorySegment archive_entry_mac_metadata(MemorySegment x0, MemorySegment x1) {
        var mh$ = archive_entry_mac_metadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_mac_metadata", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_copy_mac_metadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_copy_mac_metadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_copy_mac_metadata(struct archive_entry *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor archive_entry_copy_mac_metadata$descriptor() {
        return archive_entry_copy_mac_metadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_copy_mac_metadata(struct archive_entry *, const void *, size_t)
     * }
     */
    public static MethodHandle archive_entry_copy_mac_metadata$handle() {
        return archive_entry_copy_mac_metadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_copy_mac_metadata(struct archive_entry *, const void *, size_t)
     * }
     */
    public static MemorySegment archive_entry_copy_mac_metadata$address() {
        return archive_entry_copy_mac_metadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_copy_mac_metadata(struct archive_entry *, const void *, size_t)
     * }
     */
    public static void archive_entry_copy_mac_metadata(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = archive_entry_copy_mac_metadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_copy_mac_metadata", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_digest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_digest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const unsigned char *archive_entry_digest(struct archive_entry *, int)
     * }
     */
    public static FunctionDescriptor archive_entry_digest$descriptor() {
        return archive_entry_digest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const unsigned char *archive_entry_digest(struct archive_entry *, int)
     * }
     */
    public static MethodHandle archive_entry_digest$handle() {
        return archive_entry_digest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const unsigned char *archive_entry_digest(struct archive_entry *, int)
     * }
     */
    public static MemorySegment archive_entry_digest$address() {
        return archive_entry_digest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const unsigned char *archive_entry_digest(struct archive_entry *, int)
     * }
     */
    public static MemorySegment archive_entry_digest(MemorySegment x0, int x1) {
        var mh$ = archive_entry_digest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_digest", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_acl_clear(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_clear$descriptor() {
        return archive_entry_acl_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_acl_clear(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_acl_clear$handle() {
        return archive_entry_acl_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_acl_clear(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_acl_clear$address() {
        return archive_entry_acl_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_acl_clear(struct archive_entry *)
     * }
     */
    public static void archive_entry_acl_clear(MemorySegment x0) {
        var mh$ = archive_entry_acl_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_add_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_add_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_acl_add_entry(struct archive_entry *, int, int, int, int, const char *)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_add_entry$descriptor() {
        return archive_entry_acl_add_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_acl_add_entry(struct archive_entry *, int, int, int, int, const char *)
     * }
     */
    public static MethodHandle archive_entry_acl_add_entry$handle() {
        return archive_entry_acl_add_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_acl_add_entry(struct archive_entry *, int, int, int, int, const char *)
     * }
     */
    public static MemorySegment archive_entry_acl_add_entry$address() {
        return archive_entry_acl_add_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_acl_add_entry(struct archive_entry *, int, int, int, int, const char *)
     * }
     */
    public static int archive_entry_acl_add_entry(MemorySegment x0, int x1, int x2, int x3, int x4, MemorySegment x5) {
        var mh$ = archive_entry_acl_add_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_add_entry", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_add_entry_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_add_entry_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_acl_add_entry_w(struct archive_entry *, int, int, int, int, const wchar_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_add_entry_w$descriptor() {
        return archive_entry_acl_add_entry_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_acl_add_entry_w(struct archive_entry *, int, int, int, int, const wchar_t *)
     * }
     */
    public static MethodHandle archive_entry_acl_add_entry_w$handle() {
        return archive_entry_acl_add_entry_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_acl_add_entry_w(struct archive_entry *, int, int, int, int, const wchar_t *)
     * }
     */
    public static MemorySegment archive_entry_acl_add_entry_w$address() {
        return archive_entry_acl_add_entry_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_acl_add_entry_w(struct archive_entry *, int, int, int, int, const wchar_t *)
     * }
     */
    public static int archive_entry_acl_add_entry_w(MemorySegment x0, int x1, int x2, int x3, int x4, MemorySegment x5) {
        var mh$ = archive_entry_acl_add_entry_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_add_entry_w", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_acl_reset(struct archive_entry *, int)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_reset$descriptor() {
        return archive_entry_acl_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_acl_reset(struct archive_entry *, int)
     * }
     */
    public static MethodHandle archive_entry_acl_reset$handle() {
        return archive_entry_acl_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_acl_reset(struct archive_entry *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_reset$address() {
        return archive_entry_acl_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_acl_reset(struct archive_entry *, int)
     * }
     */
    public static int archive_entry_acl_reset(MemorySegment x0, int x1) {
        var mh$ = archive_entry_acl_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_reset", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_acl_next(struct archive_entry *, int, int *, int *, int *, int *, const char **)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_next$descriptor() {
        return archive_entry_acl_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_acl_next(struct archive_entry *, int, int *, int *, int *, int *, const char **)
     * }
     */
    public static MethodHandle archive_entry_acl_next$handle() {
        return archive_entry_acl_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_acl_next(struct archive_entry *, int, int *, int *, int *, int *, const char **)
     * }
     */
    public static MemorySegment archive_entry_acl_next$address() {
        return archive_entry_acl_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_acl_next(struct archive_entry *, int, int *, int *, int *, int *, const char **)
     * }
     */
    public static int archive_entry_acl_next(MemorySegment x0, int x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = archive_entry_acl_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_next", x0, x1, x2, x3, x4, x5, x6);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_to_text_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_to_text_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *archive_entry_acl_to_text_w(struct archive_entry *, la_ssize_t *, int)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_to_text_w$descriptor() {
        return archive_entry_acl_to_text_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *archive_entry_acl_to_text_w(struct archive_entry *, la_ssize_t *, int)
     * }
     */
    public static MethodHandle archive_entry_acl_to_text_w$handle() {
        return archive_entry_acl_to_text_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * wchar_t *archive_entry_acl_to_text_w(struct archive_entry *, la_ssize_t *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_to_text_w$address() {
        return archive_entry_acl_to_text_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * wchar_t *archive_entry_acl_to_text_w(struct archive_entry *, la_ssize_t *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_to_text_w(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = archive_entry_acl_to_text_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_to_text_w", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_to_text {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_to_text");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *archive_entry_acl_to_text(struct archive_entry *, la_ssize_t *, int)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_to_text$descriptor() {
        return archive_entry_acl_to_text.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *archive_entry_acl_to_text(struct archive_entry *, la_ssize_t *, int)
     * }
     */
    public static MethodHandle archive_entry_acl_to_text$handle() {
        return archive_entry_acl_to_text.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *archive_entry_acl_to_text(struct archive_entry *, la_ssize_t *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_to_text$address() {
        return archive_entry_acl_to_text.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *archive_entry_acl_to_text(struct archive_entry *, la_ssize_t *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_to_text(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = archive_entry_acl_to_text.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_to_text", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_from_text_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_from_text_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_acl_from_text_w(struct archive_entry *, const wchar_t *, int)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_from_text_w$descriptor() {
        return archive_entry_acl_from_text_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_acl_from_text_w(struct archive_entry *, const wchar_t *, int)
     * }
     */
    public static MethodHandle archive_entry_acl_from_text_w$handle() {
        return archive_entry_acl_from_text_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_acl_from_text_w(struct archive_entry *, const wchar_t *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_from_text_w$address() {
        return archive_entry_acl_from_text_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_acl_from_text_w(struct archive_entry *, const wchar_t *, int)
     * }
     */
    public static int archive_entry_acl_from_text_w(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = archive_entry_acl_from_text_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_from_text_w", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_from_text {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_from_text");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_acl_from_text(struct archive_entry *, const char *, int)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_from_text$descriptor() {
        return archive_entry_acl_from_text.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_acl_from_text(struct archive_entry *, const char *, int)
     * }
     */
    public static MethodHandle archive_entry_acl_from_text$handle() {
        return archive_entry_acl_from_text.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_acl_from_text(struct archive_entry *, const char *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_from_text$address() {
        return archive_entry_acl_from_text.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_acl_from_text(struct archive_entry *, const char *, int)
     * }
     */
    public static int archive_entry_acl_from_text(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = archive_entry_acl_from_text.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_from_text", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_text_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_text_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_acl_text_w(struct archive_entry *, int)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_text_w$descriptor() {
        return archive_entry_acl_text_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_acl_text_w(struct archive_entry *, int)
     * }
     */
    public static MethodHandle archive_entry_acl_text_w$handle() {
        return archive_entry_acl_text_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const wchar_t *archive_entry_acl_text_w(struct archive_entry *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_text_w$address() {
        return archive_entry_acl_text_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const wchar_t *archive_entry_acl_text_w(struct archive_entry *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_text_w(MemorySegment x0, int x1) {
        var mh$ = archive_entry_acl_text_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_text_w", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_text {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_text");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *archive_entry_acl_text(struct archive_entry *, int)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_text$descriptor() {
        return archive_entry_acl_text.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *archive_entry_acl_text(struct archive_entry *, int)
     * }
     */
    public static MethodHandle archive_entry_acl_text$handle() {
        return archive_entry_acl_text.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *archive_entry_acl_text(struct archive_entry *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_text$address() {
        return archive_entry_acl_text.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *archive_entry_acl_text(struct archive_entry *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_text(MemorySegment x0, int x1) {
        var mh$ = archive_entry_acl_text.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_text", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_types {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_types");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_acl_types(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_types$descriptor() {
        return archive_entry_acl_types.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_acl_types(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_acl_types$handle() {
        return archive_entry_acl_types.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_acl_types(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_acl_types$address() {
        return archive_entry_acl_types.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_acl_types(struct archive_entry *)
     * }
     */
    public static int archive_entry_acl_types(MemorySegment x0) {
        var mh$ = archive_entry_acl_types.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_types", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_acl_count(struct archive_entry *, int)
     * }
     */
    public static FunctionDescriptor archive_entry_acl_count$descriptor() {
        return archive_entry_acl_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_acl_count(struct archive_entry *, int)
     * }
     */
    public static MethodHandle archive_entry_acl_count$handle() {
        return archive_entry_acl_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_acl_count(struct archive_entry *, int)
     * }
     */
    public static MemorySegment archive_entry_acl_count$address() {
        return archive_entry_acl_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_acl_count(struct archive_entry *, int)
     * }
     */
    public static int archive_entry_acl_count(MemorySegment x0, int x1) {
        var mh$ = archive_entry_acl_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl_count", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_acl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_acl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive_acl *archive_entry_acl(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_acl$descriptor() {
        return archive_entry_acl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive_acl *archive_entry_acl(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_acl$handle() {
        return archive_entry_acl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive_acl *archive_entry_acl(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_acl$address() {
        return archive_entry_acl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive_acl *archive_entry_acl(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_acl(MemorySegment x0) {
        var mh$ = archive_entry_acl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_acl", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_xattr_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_xattr_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_xattr_clear(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_xattr_clear$descriptor() {
        return archive_entry_xattr_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_xattr_clear(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_xattr_clear$handle() {
        return archive_entry_xattr_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_xattr_clear(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_xattr_clear$address() {
        return archive_entry_xattr_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_xattr_clear(struct archive_entry *)
     * }
     */
    public static void archive_entry_xattr_clear(MemorySegment x0) {
        var mh$ = archive_entry_xattr_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_xattr_clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_xattr_add_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_xattr_add_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_xattr_add_entry(struct archive_entry *, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor archive_entry_xattr_add_entry$descriptor() {
        return archive_entry_xattr_add_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_xattr_add_entry(struct archive_entry *, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle archive_entry_xattr_add_entry$handle() {
        return archive_entry_xattr_add_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_xattr_add_entry(struct archive_entry *, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment archive_entry_xattr_add_entry$address() {
        return archive_entry_xattr_add_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_xattr_add_entry(struct archive_entry *, const char *, const void *, size_t)
     * }
     */
    public static void archive_entry_xattr_add_entry(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = archive_entry_xattr_add_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_xattr_add_entry", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_xattr_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_xattr_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_xattr_count(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_xattr_count$descriptor() {
        return archive_entry_xattr_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_xattr_count(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_xattr_count$handle() {
        return archive_entry_xattr_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_xattr_count(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_xattr_count$address() {
        return archive_entry_xattr_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_xattr_count(struct archive_entry *)
     * }
     */
    public static int archive_entry_xattr_count(MemorySegment x0) {
        var mh$ = archive_entry_xattr_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_xattr_count", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_xattr_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_xattr_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_xattr_reset(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_xattr_reset$descriptor() {
        return archive_entry_xattr_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_xattr_reset(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_xattr_reset$handle() {
        return archive_entry_xattr_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_xattr_reset(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_xattr_reset$address() {
        return archive_entry_xattr_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_xattr_reset(struct archive_entry *)
     * }
     */
    public static int archive_entry_xattr_reset(MemorySegment x0) {
        var mh$ = archive_entry_xattr_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_xattr_reset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_xattr_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_xattr_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_xattr_next(struct archive_entry *, const char **, const void **, size_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_xattr_next$descriptor() {
        return archive_entry_xattr_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_xattr_next(struct archive_entry *, const char **, const void **, size_t *)
     * }
     */
    public static MethodHandle archive_entry_xattr_next$handle() {
        return archive_entry_xattr_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_xattr_next(struct archive_entry *, const char **, const void **, size_t *)
     * }
     */
    public static MemorySegment archive_entry_xattr_next$address() {
        return archive_entry_xattr_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_xattr_next(struct archive_entry *, const char **, const void **, size_t *)
     * }
     */
    public static int archive_entry_xattr_next(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = archive_entry_xattr_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_xattr_next", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_sparse_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_sparse_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_sparse_clear(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_sparse_clear$descriptor() {
        return archive_entry_sparse_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_sparse_clear(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_sparse_clear$handle() {
        return archive_entry_sparse_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_sparse_clear(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_sparse_clear$address() {
        return archive_entry_sparse_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_sparse_clear(struct archive_entry *)
     * }
     */
    public static void archive_entry_sparse_clear(MemorySegment x0) {
        var mh$ = archive_entry_sparse_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_sparse_clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_sparse_add_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_sparse_add_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_sparse_add_entry(struct archive_entry *, la_int64_t, la_int64_t)
     * }
     */
    public static FunctionDescriptor archive_entry_sparse_add_entry$descriptor() {
        return archive_entry_sparse_add_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_sparse_add_entry(struct archive_entry *, la_int64_t, la_int64_t)
     * }
     */
    public static MethodHandle archive_entry_sparse_add_entry$handle() {
        return archive_entry_sparse_add_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_sparse_add_entry(struct archive_entry *, la_int64_t, la_int64_t)
     * }
     */
    public static MemorySegment archive_entry_sparse_add_entry$address() {
        return archive_entry_sparse_add_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_sparse_add_entry(struct archive_entry *, la_int64_t, la_int64_t)
     * }
     */
    public static void archive_entry_sparse_add_entry(MemorySegment x0, long x1, long x2) {
        var mh$ = archive_entry_sparse_add_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_sparse_add_entry", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_sparse_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_sparse_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_sparse_count(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_sparse_count$descriptor() {
        return archive_entry_sparse_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_sparse_count(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_sparse_count$handle() {
        return archive_entry_sparse_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_sparse_count(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_sparse_count$address() {
        return archive_entry_sparse_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_sparse_count(struct archive_entry *)
     * }
     */
    public static int archive_entry_sparse_count(MemorySegment x0) {
        var mh$ = archive_entry_sparse_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_sparse_count", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_sparse_reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_sparse_reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_sparse_reset(struct archive_entry *)
     * }
     */
    public static FunctionDescriptor archive_entry_sparse_reset$descriptor() {
        return archive_entry_sparse_reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_sparse_reset(struct archive_entry *)
     * }
     */
    public static MethodHandle archive_entry_sparse_reset$handle() {
        return archive_entry_sparse_reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_sparse_reset(struct archive_entry *)
     * }
     */
    public static MemorySegment archive_entry_sparse_reset$address() {
        return archive_entry_sparse_reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_sparse_reset(struct archive_entry *)
     * }
     */
    public static int archive_entry_sparse_reset(MemorySegment x0) {
        var mh$ = archive_entry_sparse_reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_sparse_reset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_sparse_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_sparse_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int archive_entry_sparse_next(struct archive_entry *, la_int64_t *, la_int64_t *)
     * }
     */
    public static FunctionDescriptor archive_entry_sparse_next$descriptor() {
        return archive_entry_sparse_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int archive_entry_sparse_next(struct archive_entry *, la_int64_t *, la_int64_t *)
     * }
     */
    public static MethodHandle archive_entry_sparse_next$handle() {
        return archive_entry_sparse_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int archive_entry_sparse_next(struct archive_entry *, la_int64_t *, la_int64_t *)
     * }
     */
    public static MemorySegment archive_entry_sparse_next$address() {
        return archive_entry_sparse_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int archive_entry_sparse_next(struct archive_entry *, la_int64_t *, la_int64_t *)
     * }
     */
    public static int archive_entry_sparse_next(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = archive_entry_sparse_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_sparse_next", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_linkresolver_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_linkresolver_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive_entry_linkresolver *archive_entry_linkresolver_new()
     * }
     */
    public static FunctionDescriptor archive_entry_linkresolver_new$descriptor() {
        return archive_entry_linkresolver_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive_entry_linkresolver *archive_entry_linkresolver_new()
     * }
     */
    public static MethodHandle archive_entry_linkresolver_new$handle() {
        return archive_entry_linkresolver_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive_entry_linkresolver *archive_entry_linkresolver_new()
     * }
     */
    public static MemorySegment archive_entry_linkresolver_new$address() {
        return archive_entry_linkresolver_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive_entry_linkresolver *archive_entry_linkresolver_new()
     * }
     */
    public static MemorySegment archive_entry_linkresolver_new() {
        var mh$ = archive_entry_linkresolver_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_linkresolver_new");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_linkresolver_set_strategy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_linkresolver_set_strategy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_linkresolver_set_strategy(struct archive_entry_linkresolver *, int)
     * }
     */
    public static FunctionDescriptor archive_entry_linkresolver_set_strategy$descriptor() {
        return archive_entry_linkresolver_set_strategy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_linkresolver_set_strategy(struct archive_entry_linkresolver *, int)
     * }
     */
    public static MethodHandle archive_entry_linkresolver_set_strategy$handle() {
        return archive_entry_linkresolver_set_strategy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_linkresolver_set_strategy(struct archive_entry_linkresolver *, int)
     * }
     */
    public static MemorySegment archive_entry_linkresolver_set_strategy$address() {
        return archive_entry_linkresolver_set_strategy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_linkresolver_set_strategy(struct archive_entry_linkresolver *, int)
     * }
     */
    public static void archive_entry_linkresolver_set_strategy(MemorySegment x0, int x1) {
        var mh$ = archive_entry_linkresolver_set_strategy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_linkresolver_set_strategy", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_linkresolver_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_linkresolver_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_linkresolver_free(struct archive_entry_linkresolver *)
     * }
     */
    public static FunctionDescriptor archive_entry_linkresolver_free$descriptor() {
        return archive_entry_linkresolver_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_linkresolver_free(struct archive_entry_linkresolver *)
     * }
     */
    public static MethodHandle archive_entry_linkresolver_free$handle() {
        return archive_entry_linkresolver_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_linkresolver_free(struct archive_entry_linkresolver *)
     * }
     */
    public static MemorySegment archive_entry_linkresolver_free$address() {
        return archive_entry_linkresolver_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_linkresolver_free(struct archive_entry_linkresolver *)
     * }
     */
    public static void archive_entry_linkresolver_free(MemorySegment x0) {
        var mh$ = archive_entry_linkresolver_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_linkresolver_free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_linkify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_linkify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void archive_entry_linkify(struct archive_entry_linkresolver *, struct archive_entry **, struct archive_entry **)
     * }
     */
    public static FunctionDescriptor archive_entry_linkify$descriptor() {
        return archive_entry_linkify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void archive_entry_linkify(struct archive_entry_linkresolver *, struct archive_entry **, struct archive_entry **)
     * }
     */
    public static MethodHandle archive_entry_linkify$handle() {
        return archive_entry_linkify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void archive_entry_linkify(struct archive_entry_linkresolver *, struct archive_entry **, struct archive_entry **)
     * }
     */
    public static MemorySegment archive_entry_linkify$address() {
        return archive_entry_linkify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void archive_entry_linkify(struct archive_entry_linkresolver *, struct archive_entry **, struct archive_entry **)
     * }
     */
    public static void archive_entry_linkify(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = archive_entry_linkify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_linkify", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class archive_entry_partial_links {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("archive_entry_partial_links");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_partial_links(struct archive_entry_linkresolver *res, unsigned int *links)
     * }
     */
    public static FunctionDescriptor archive_entry_partial_links$descriptor() {
        return archive_entry_partial_links.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_partial_links(struct archive_entry_linkresolver *res, unsigned int *links)
     * }
     */
    public static MethodHandle archive_entry_partial_links$handle() {
        return archive_entry_partial_links.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_partial_links(struct archive_entry_linkresolver *res, unsigned int *links)
     * }
     */
    public static MemorySegment archive_entry_partial_links$address() {
        return archive_entry_partial_links.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct archive_entry *archive_entry_partial_links(struct archive_entry_linkresolver *res, unsigned int *links)
     * }
     */
    public static MemorySegment archive_entry_partial_links(MemorySegment res, MemorySegment links) {
        var mh$ = archive_entry_partial_links.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("archive_entry_partial_links", res, links);
            }
            return (MemorySegment)mh$.invokeExact(res, links);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = archive_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final int MAC_OS_X_VERSION_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }
    private static final int MAC_OS_X_VERSION_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }
    private static final int MAC_OS_X_VERSION_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }
    private static final int MAC_OS_X_VERSION_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }
    private static final int MAC_OS_X_VERSION_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }
    private static final int MAC_OS_X_VERSION_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }
    private static final int MAC_OS_X_VERSION_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }
    private static final int MAC_OS_X_VERSION_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }
    private static final int MAC_OS_X_VERSION_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }
    private static final int MAC_OS_X_VERSION_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }
    private static final int MAC_OS_X_VERSION_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }
    private static final int MAC_OS_X_VERSION_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }
    private static final int MAC_OS_X_VERSION_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }
    private static final int MAC_OS_X_VERSION_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }
    private static final int MAC_OS_X_VERSION_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }
    private static final int MAC_OS_X_VERSION_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }
    private static final int MAC_OS_X_VERSION_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }
    private static final int MAC_OS_X_VERSION_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }
    private static final int MAC_OS_X_VERSION_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }
    private static final int MAC_OS_X_VERSION_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }
    private static final int MAC_OS_X_VERSION_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }
    private static final int MAC_OS_X_VERSION_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }
    private static final int MAC_OS_X_VERSION_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }
    private static final int MAC_OS_X_VERSION_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }
    private static final int MAC_OS_X_VERSION_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }
    private static final int MAC_OS_X_VERSION_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }
    private static final int MAC_OS_X_VERSION_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }
    private static final int MAC_OS_X_VERSION_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }
    private static final int MAC_OS_X_VERSION_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }
    private static final int MAC_OS_X_VERSION_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }
    private static final int MAC_OS_VERSION_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }
    private static final int MAC_OS_VERSION_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }
    private static final int MAC_OS_VERSION_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }
    private static final int MAC_OS_VERSION_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }
    private static final int MAC_OS_VERSION_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }
    private static final int MAC_OS_VERSION_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }
    private static final int MAC_OS_VERSION_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }
    private static final int MAC_OS_VERSION_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }
    private static final int MAC_OS_VERSION_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }
    private static final int MAC_OS_VERSION_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }
    private static final int MAC_OS_VERSION_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }
    private static final int MAC_OS_VERSION_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }
    private static final int MAC_OS_VERSION_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_6 120600
     * }
     */
    public static int MAC_OS_VERSION_12_6() {
        return MAC_OS_VERSION_12_6;
    }
    private static final int MAC_OS_VERSION_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_7 120700
     * }
     */
    public static int MAC_OS_VERSION_12_7() {
        return MAC_OS_VERSION_12_7;
    }
    private static final int MAC_OS_VERSION_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }
    private static final int MAC_OS_VERSION_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }
    private static final int MAC_OS_VERSION_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }
    private static final int MAC_OS_VERSION_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }
    private static final int MAC_OS_VERSION_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }
    private static final int MAC_OS_VERSION_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_5 130500
     * }
     */
    public static int MAC_OS_VERSION_13_5() {
        return MAC_OS_VERSION_13_5;
    }
    private static final int MAC_OS_VERSION_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_6 130600
     * }
     */
    public static int MAC_OS_VERSION_13_6() {
        return MAC_OS_VERSION_13_6;
    }
    private static final int MAC_OS_VERSION_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }
    private static final int MAC_OS_VERSION_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_1 140100
     * }
     */
    public static int MAC_OS_VERSION_14_1() {
        return MAC_OS_VERSION_14_1;
    }
    private static final int MAC_OS_VERSION_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_2 140200
     * }
     */
    public static int MAC_OS_VERSION_14_2() {
        return MAC_OS_VERSION_14_2;
    }
    private static final int MAC_OS_VERSION_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_3 140300
     * }
     */
    public static int MAC_OS_VERSION_14_3() {
        return MAC_OS_VERSION_14_3;
    }
    private static final int MAC_OS_VERSION_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_4 140400
     * }
     */
    public static int MAC_OS_VERSION_14_4() {
        return MAC_OS_VERSION_14_4;
    }
    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 140400
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }
    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }
    private static final int S_ISTXT = (int)512L;
    /**
     * {@snippet lang=c :
     * #define S_ISTXT 512
     * }
     */
    public static int S_ISTXT() {
        return S_ISTXT;
    }
    private static final int S_IREAD = (int)256L;
    /**
     * {@snippet lang=c :
     * #define S_IREAD 256
     * }
     */
    public static int S_IREAD() {
        return S_IREAD;
    }
    private static final int S_IWRITE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define S_IWRITE 128
     * }
     */
    public static int S_IWRITE() {
        return S_IWRITE;
    }
    private static final int S_IEXEC = (int)64L;
    /**
     * {@snippet lang=c :
     * #define S_IEXEC 64
     * }
     */
    public static int S_IEXEC() {
        return S_IEXEC;
    }
    private static final int ACCESSPERMS = (int)511L;
    /**
     * {@snippet lang=c :
     * #define ACCESSPERMS 511
     * }
     */
    public static int ACCESSPERMS() {
        return ACCESSPERMS;
    }
    private static final int ALLPERMS = (int)4095L;
    /**
     * {@snippet lang=c :
     * #define ALLPERMS 4095
     * }
     */
    public static int ALLPERMS() {
        return ALLPERMS;
    }
    private static final int DEFFILEMODE = (int)438L;
    /**
     * {@snippet lang=c :
     * #define DEFFILEMODE 438
     * }
     */
    public static int DEFFILEMODE() {
        return DEFFILEMODE;
    }
    private static final int SF_SYNTHETIC = (int)3221225472L;
    /**
     * {@snippet lang=c :
     * #define SF_SYNTHETIC 3221225472
     * }
     */
    public static int SF_SYNTHETIC() {
        return SF_SYNTHETIC;
    }
    private static final int UTIME_NOW = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define UTIME_NOW -1
     * }
     */
    public static int UTIME_NOW() {
        return UTIME_NOW;
    }
    private static final int UTIME_OMIT = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define UTIME_OMIT -2
     * }
     */
    public static int UTIME_OMIT() {
        return UTIME_OMIT;
    }
    private static final int __DARWIN_WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MAX 2147483647
     * }
     */
    public static int __DARWIN_WCHAR_MAX() {
        return __DARWIN_WCHAR_MAX;
    }
    private static final int __DARWIN_WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MIN -2147483648
     * }
     */
    public static int __DARWIN_WCHAR_MIN() {
        return __DARWIN_WCHAR_MIN;
    }
    private static final int __DARWIN_WEOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WEOF -1
     * }
     */
    public static int __DARWIN_WEOF() {
        return __DARWIN_WEOF;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/var/tmp/"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = archive_h.LIBRARY_ARENA.allocateFrom("/var/tmp/");
        }
        return Holder.P_tmpdir;
    }
    private static final long CLOCKS_PER_SEC = 1000000L;
    /**
     * {@snippet lang=c :
     * #define CLOCKS_PER_SEC 1000000
     * }
     */
    public static long CLOCKS_PER_SEC() {
        return CLOCKS_PER_SEC;
    }
    private static final int CLOCK_REALTIME = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_REALTIME 0
     * }
     */
    public static int CLOCK_REALTIME() {
        return CLOCK_REALTIME;
    }
    private static final int CLOCK_MONOTONIC = (int)6L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC 6
     * }
     */
    public static int CLOCK_MONOTONIC() {
        return CLOCK_MONOTONIC;
    }
    private static final int CLOCK_MONOTONIC_RAW = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW 4
     * }
     */
    public static int CLOCK_MONOTONIC_RAW() {
        return CLOCK_MONOTONIC_RAW;
    }
    private static final int CLOCK_MONOTONIC_RAW_APPROX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_MONOTONIC_RAW_APPROX 5
     * }
     */
    public static int CLOCK_MONOTONIC_RAW_APPROX() {
        return CLOCK_MONOTONIC_RAW_APPROX;
    }
    private static final int CLOCK_UPTIME_RAW = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_UPTIME_RAW 8
     * }
     */
    public static int CLOCK_UPTIME_RAW() {
        return CLOCK_UPTIME_RAW;
    }
    private static final int CLOCK_UPTIME_RAW_APPROX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_UPTIME_RAW_APPROX 9
     * }
     */
    public static int CLOCK_UPTIME_RAW_APPROX() {
        return CLOCK_UPTIME_RAW_APPROX;
    }
    private static final int CLOCK_PROCESS_CPUTIME_ID = (int)12L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_PROCESS_CPUTIME_ID 12
     * }
     */
    public static int CLOCK_PROCESS_CPUTIME_ID() {
        return CLOCK_PROCESS_CPUTIME_ID;
    }
    private static final int CLOCK_THREAD_CPUTIME_ID = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CLOCK_THREAD_CPUTIME_ID 16
     * }
     */
    public static int CLOCK_THREAD_CPUTIME_ID() {
        return CLOCK_THREAD_CPUTIME_ID;
    }
    /**
     * {@snippet lang=c :
     * #define __PRI_8_LENGTH_MODIFIER__ "hh"
     * }
     */
    public static MemorySegment __PRI_8_LENGTH_MODIFIER__() {
        class Holder {
            static final MemorySegment __PRI_8_LENGTH_MODIFIER__
                = archive_h.LIBRARY_ARENA.allocateFrom("hh");
        }
        return Holder.__PRI_8_LENGTH_MODIFIER__;
    }
    /**
     * {@snippet lang=c :
     * #define __PRI_64_LENGTH_MODIFIER__ "ll"
     * }
     */
    public static MemorySegment __PRI_64_LENGTH_MODIFIER__() {
        class Holder {
            static final MemorySegment __PRI_64_LENGTH_MODIFIER__
                = archive_h.LIBRARY_ARENA.allocateFrom("ll");
        }
        return Holder.__PRI_64_LENGTH_MODIFIER__;
    }
    /**
     * {@snippet lang=c :
     * #define __SCN_64_LENGTH_MODIFIER__ "ll"
     * }
     */
    public static MemorySegment __SCN_64_LENGTH_MODIFIER__() {
        class Holder {
            static final MemorySegment __SCN_64_LENGTH_MODIFIER__
                = archive_h.LIBRARY_ARENA.allocateFrom("ll");
        }
        return Holder.__SCN_64_LENGTH_MODIFIER__;
    }
    /**
     * {@snippet lang=c :
     * #define __PRI_MAX_LENGTH_MODIFIER__ "j"
     * }
     */
    public static MemorySegment __PRI_MAX_LENGTH_MODIFIER__() {
        class Holder {
            static final MemorySegment __PRI_MAX_LENGTH_MODIFIER__
                = archive_h.LIBRARY_ARENA.allocateFrom("j");
        }
        return Holder.__PRI_MAX_LENGTH_MODIFIER__;
    }
    /**
     * {@snippet lang=c :
     * #define __SCN_MAX_LENGTH_MODIFIER__ "j"
     * }
     */
    public static MemorySegment __SCN_MAX_LENGTH_MODIFIER__() {
        class Holder {
            static final MemorySegment __SCN_MAX_LENGTH_MODIFIER__
                = archive_h.LIBRARY_ARENA.allocateFrom("j");
        }
        return Holder.__SCN_MAX_LENGTH_MODIFIER__;
    }
    /**
     * {@snippet lang=c :
     * #define PRId8 "hhd"
     * }
     */
    public static MemorySegment PRId8() {
        class Holder {
            static final MemorySegment PRId8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRId8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi8 "hhi"
     * }
     */
    public static MemorySegment PRIi8() {
        class Holder {
            static final MemorySegment PRIi8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIi8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo8 "hho"
     * }
     */
    public static MemorySegment PRIo8() {
        class Holder {
            static final MemorySegment PRIo8
                = archive_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIo8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu8 "hhu"
     * }
     */
    public static MemorySegment PRIu8() {
        class Holder {
            static final MemorySegment PRIu8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIu8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx8 "hhx"
     * }
     */
    public static MemorySegment PRIx8() {
        class Holder {
            static final MemorySegment PRIx8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIx8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX8 "hhX"
     * }
     */
    public static MemorySegment PRIX8() {
        class Holder {
            static final MemorySegment PRIX8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIX8;
    }
    /**
     * {@snippet lang=c :
     * #define PRId16 "hd"
     * }
     */
    public static MemorySegment PRId16() {
        class Holder {
            static final MemorySegment PRId16
                = archive_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.PRId16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi16 "hi"
     * }
     */
    public static MemorySegment PRIi16() {
        class Holder {
            static final MemorySegment PRIi16
                = archive_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.PRIi16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo16 "ho"
     * }
     */
    public static MemorySegment PRIo16() {
        class Holder {
            static final MemorySegment PRIo16
                = archive_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.PRIo16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu16 "hu"
     * }
     */
    public static MemorySegment PRIu16() {
        class Holder {
            static final MemorySegment PRIu16
                = archive_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.PRIu16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx16 "hx"
     * }
     */
    public static MemorySegment PRIx16() {
        class Holder {
            static final MemorySegment PRIx16
                = archive_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.PRIx16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX16 "hX"
     * }
     */
    public static MemorySegment PRIX16() {
        class Holder {
            static final MemorySegment PRIX16
                = archive_h.LIBRARY_ARENA.allocateFrom("hX");
        }
        return Holder.PRIX16;
    }
    /**
     * {@snippet lang=c :
     * #define PRId32 "d"
     * }
     */
    public static MemorySegment PRId32() {
        class Holder {
            static final MemorySegment PRId32
                = archive_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi32 "i"
     * }
     */
    public static MemorySegment PRIi32() {
        class Holder {
            static final MemorySegment PRIi32
                = archive_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo32 "o"
     * }
     */
    public static MemorySegment PRIo32() {
        class Holder {
            static final MemorySegment PRIo32
                = archive_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu32 "u"
     * }
     */
    public static MemorySegment PRIu32() {
        class Holder {
            static final MemorySegment PRIu32
                = archive_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx32 "x"
     * }
     */
    public static MemorySegment PRIx32() {
        class Holder {
            static final MemorySegment PRIx32
                = archive_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX32 "X"
     * }
     */
    public static MemorySegment PRIX32() {
        class Holder {
            static final MemorySegment PRIX32
                = archive_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX32;
    }
    /**
     * {@snippet lang=c :
     * #define PRId64 "lld"
     * }
     */
    public static MemorySegment PRId64() {
        class Holder {
            static final MemorySegment PRId64
                = archive_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRId64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi64 "lli"
     * }
     */
    public static MemorySegment PRIi64() {
        class Holder {
            static final MemorySegment PRIi64
                = archive_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIi64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo64 "llo"
     * }
     */
    public static MemorySegment PRIo64() {
        class Holder {
            static final MemorySegment PRIo64
                = archive_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIo64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu64 "llu"
     * }
     */
    public static MemorySegment PRIu64() {
        class Holder {
            static final MemorySegment PRIu64
                = archive_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIu64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx64 "llx"
     * }
     */
    public static MemorySegment PRIx64() {
        class Holder {
            static final MemorySegment PRIx64
                = archive_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIx64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX64 "llX"
     * }
     */
    public static MemorySegment PRIX64() {
        class Holder {
            static final MemorySegment PRIX64
                = archive_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIX64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST8 "hhd"
     * }
     */
    public static MemorySegment PRIdLEAST8() {
        class Holder {
            static final MemorySegment PRIdLEAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRIdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST8 "hhi"
     * }
     */
    public static MemorySegment PRIiLEAST8() {
        class Holder {
            static final MemorySegment PRIiLEAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST8 "hho"
     * }
     */
    public static MemorySegment PRIoLEAST8() {
        class Holder {
            static final MemorySegment PRIoLEAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST8 "hhu"
     * }
     */
    public static MemorySegment PRIuLEAST8() {
        class Holder {
            static final MemorySegment PRIuLEAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST8 "hhx"
     * }
     */
    public static MemorySegment PRIxLEAST8() {
        class Holder {
            static final MemorySegment PRIxLEAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST8 "hhX"
     * }
     */
    public static MemorySegment PRIXLEAST8() {
        class Holder {
            static final MemorySegment PRIXLEAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIXLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST16 "hd"
     * }
     */
    public static MemorySegment PRIdLEAST16() {
        class Holder {
            static final MemorySegment PRIdLEAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.PRIdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST16 "hi"
     * }
     */
    public static MemorySegment PRIiLEAST16() {
        class Holder {
            static final MemorySegment PRIiLEAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.PRIiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST16 "ho"
     * }
     */
    public static MemorySegment PRIoLEAST16() {
        class Holder {
            static final MemorySegment PRIoLEAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.PRIoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST16 "hu"
     * }
     */
    public static MemorySegment PRIuLEAST16() {
        class Holder {
            static final MemorySegment PRIuLEAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.PRIuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST16 "hx"
     * }
     */
    public static MemorySegment PRIxLEAST16() {
        class Holder {
            static final MemorySegment PRIxLEAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.PRIxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST16 "hX"
     * }
     */
    public static MemorySegment PRIXLEAST16() {
        class Holder {
            static final MemorySegment PRIXLEAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hX");
        }
        return Holder.PRIXLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST32 "d"
     * }
     */
    public static MemorySegment PRIdLEAST32() {
        class Holder {
            static final MemorySegment PRIdLEAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST32 "i"
     * }
     */
    public static MemorySegment PRIiLEAST32() {
        class Holder {
            static final MemorySegment PRIiLEAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST32 "o"
     * }
     */
    public static MemorySegment PRIoLEAST32() {
        class Holder {
            static final MemorySegment PRIoLEAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST32 "u"
     * }
     */
    public static MemorySegment PRIuLEAST32() {
        class Holder {
            static final MemorySegment PRIuLEAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST32 "x"
     * }
     */
    public static MemorySegment PRIxLEAST32() {
        class Holder {
            static final MemorySegment PRIxLEAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST32 "X"
     * }
     */
    public static MemorySegment PRIXLEAST32() {
        class Holder {
            static final MemorySegment PRIXLEAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST64 "lld"
     * }
     */
    public static MemorySegment PRIdLEAST64() {
        class Holder {
            static final MemorySegment PRIdLEAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST64 "lli"
     * }
     */
    public static MemorySegment PRIiLEAST64() {
        class Holder {
            static final MemorySegment PRIiLEAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST64 "llo"
     * }
     */
    public static MemorySegment PRIoLEAST64() {
        class Holder {
            static final MemorySegment PRIoLEAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST64 "llu"
     * }
     */
    public static MemorySegment PRIuLEAST64() {
        class Holder {
            static final MemorySegment PRIuLEAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST64 "llx"
     * }
     */
    public static MemorySegment PRIxLEAST64() {
        class Holder {
            static final MemorySegment PRIxLEAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST64 "llX"
     * }
     */
    public static MemorySegment PRIXLEAST64() {
        class Holder {
            static final MemorySegment PRIXLEAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST8 "hhd"
     * }
     */
    public static MemorySegment PRIdFAST8() {
        class Holder {
            static final MemorySegment PRIdFAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRIdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST8 "hhi"
     * }
     */
    public static MemorySegment PRIiFAST8() {
        class Holder {
            static final MemorySegment PRIiFAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST8 "hho"
     * }
     */
    public static MemorySegment PRIoFAST8() {
        class Holder {
            static final MemorySegment PRIoFAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST8 "hhu"
     * }
     */
    public static MemorySegment PRIuFAST8() {
        class Holder {
            static final MemorySegment PRIuFAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST8 "hhx"
     * }
     */
    public static MemorySegment PRIxFAST8() {
        class Holder {
            static final MemorySegment PRIxFAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST8 "hhX"
     * }
     */
    public static MemorySegment PRIXFAST8() {
        class Holder {
            static final MemorySegment PRIXFAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIXFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST16 "hd"
     * }
     */
    public static MemorySegment PRIdFAST16() {
        class Holder {
            static final MemorySegment PRIdFAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.PRIdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST16 "hi"
     * }
     */
    public static MemorySegment PRIiFAST16() {
        class Holder {
            static final MemorySegment PRIiFAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.PRIiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST16 "ho"
     * }
     */
    public static MemorySegment PRIoFAST16() {
        class Holder {
            static final MemorySegment PRIoFAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.PRIoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST16 "hu"
     * }
     */
    public static MemorySegment PRIuFAST16() {
        class Holder {
            static final MemorySegment PRIuFAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.PRIuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST16 "hx"
     * }
     */
    public static MemorySegment PRIxFAST16() {
        class Holder {
            static final MemorySegment PRIxFAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.PRIxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST16 "hX"
     * }
     */
    public static MemorySegment PRIXFAST16() {
        class Holder {
            static final MemorySegment PRIXFAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hX");
        }
        return Holder.PRIXFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST32 "d"
     * }
     */
    public static MemorySegment PRIdFAST32() {
        class Holder {
            static final MemorySegment PRIdFAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST32 "i"
     * }
     */
    public static MemorySegment PRIiFAST32() {
        class Holder {
            static final MemorySegment PRIiFAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST32 "o"
     * }
     */
    public static MemorySegment PRIoFAST32() {
        class Holder {
            static final MemorySegment PRIoFAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST32 "u"
     * }
     */
    public static MemorySegment PRIuFAST32() {
        class Holder {
            static final MemorySegment PRIuFAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST32 "x"
     * }
     */
    public static MemorySegment PRIxFAST32() {
        class Holder {
            static final MemorySegment PRIxFAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST32 "X"
     * }
     */
    public static MemorySegment PRIXFAST32() {
        class Holder {
            static final MemorySegment PRIXFAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST64 "lld"
     * }
     */
    public static MemorySegment PRIdFAST64() {
        class Holder {
            static final MemorySegment PRIdFAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST64 "lli"
     * }
     */
    public static MemorySegment PRIiFAST64() {
        class Holder {
            static final MemorySegment PRIiFAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST64 "llo"
     * }
     */
    public static MemorySegment PRIoFAST64() {
        class Holder {
            static final MemorySegment PRIoFAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST64 "llu"
     * }
     */
    public static MemorySegment PRIuFAST64() {
        class Holder {
            static final MemorySegment PRIuFAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST64 "llx"
     * }
     */
    public static MemorySegment PRIxFAST64() {
        class Holder {
            static final MemorySegment PRIxFAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST64 "llX"
     * }
     */
    public static MemorySegment PRIXFAST64() {
        class Holder {
            static final MemorySegment PRIXFAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdPTR "ld"
     * }
     */
    public static MemorySegment PRIdPTR() {
        class Holder {
            static final MemorySegment PRIdPTR
                = archive_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiPTR "li"
     * }
     */
    public static MemorySegment PRIiPTR() {
        class Holder {
            static final MemorySegment PRIiPTR
                = archive_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoPTR "lo"
     * }
     */
    public static MemorySegment PRIoPTR() {
        class Holder {
            static final MemorySegment PRIoPTR
                = archive_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuPTR "lu"
     * }
     */
    public static MemorySegment PRIuPTR() {
        class Holder {
            static final MemorySegment PRIuPTR
                = archive_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxPTR "lx"
     * }
     */
    public static MemorySegment PRIxPTR() {
        class Holder {
            static final MemorySegment PRIxPTR
                = archive_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXPTR "lX"
     * }
     */
    public static MemorySegment PRIXPTR() {
        class Holder {
            static final MemorySegment PRIXPTR
                = archive_h.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdMAX "jd"
     * }
     */
    public static MemorySegment PRIdMAX() {
        class Holder {
            static final MemorySegment PRIdMAX
                = archive_h.LIBRARY_ARENA.allocateFrom("jd");
        }
        return Holder.PRIdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiMAX "ji"
     * }
     */
    public static MemorySegment PRIiMAX() {
        class Holder {
            static final MemorySegment PRIiMAX
                = archive_h.LIBRARY_ARENA.allocateFrom("ji");
        }
        return Holder.PRIiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoMAX "jo"
     * }
     */
    public static MemorySegment PRIoMAX() {
        class Holder {
            static final MemorySegment PRIoMAX
                = archive_h.LIBRARY_ARENA.allocateFrom("jo");
        }
        return Holder.PRIoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuMAX "ju"
     * }
     */
    public static MemorySegment PRIuMAX() {
        class Holder {
            static final MemorySegment PRIuMAX
                = archive_h.LIBRARY_ARENA.allocateFrom("ju");
        }
        return Holder.PRIuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxMAX "jx"
     * }
     */
    public static MemorySegment PRIxMAX() {
        class Holder {
            static final MemorySegment PRIxMAX
                = archive_h.LIBRARY_ARENA.allocateFrom("jx");
        }
        return Holder.PRIxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXMAX "jX"
     * }
     */
    public static MemorySegment PRIXMAX() {
        class Holder {
            static final MemorySegment PRIXMAX
                = archive_h.LIBRARY_ARENA.allocateFrom("jX");
        }
        return Holder.PRIXMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd8 "hhd"
     * }
     */
    public static MemorySegment SCNd8() {
        class Holder {
            static final MemorySegment SCNd8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNd8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi8 "hhi"
     * }
     */
    public static MemorySegment SCNi8() {
        class Holder {
            static final MemorySegment SCNi8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNi8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo8 "hho"
     * }
     */
    public static MemorySegment SCNo8() {
        class Holder {
            static final MemorySegment SCNo8
                = archive_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNo8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu8 "hhu"
     * }
     */
    public static MemorySegment SCNu8() {
        class Holder {
            static final MemorySegment SCNu8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNu8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx8 "hhx"
     * }
     */
    public static MemorySegment SCNx8() {
        class Holder {
            static final MemorySegment SCNx8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNx8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd16 "hd"
     * }
     */
    public static MemorySegment SCNd16() {
        class Holder {
            static final MemorySegment SCNd16
                = archive_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNd16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi16 "hi"
     * }
     */
    public static MemorySegment SCNi16() {
        class Holder {
            static final MemorySegment SCNi16
                = archive_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNi16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo16 "ho"
     * }
     */
    public static MemorySegment SCNo16() {
        class Holder {
            static final MemorySegment SCNo16
                = archive_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNo16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu16 "hu"
     * }
     */
    public static MemorySegment SCNu16() {
        class Holder {
            static final MemorySegment SCNu16
                = archive_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNu16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx16 "hx"
     * }
     */
    public static MemorySegment SCNx16() {
        class Holder {
            static final MemorySegment SCNx16
                = archive_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNx16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd32 "d"
     * }
     */
    public static MemorySegment SCNd32() {
        class Holder {
            static final MemorySegment SCNd32
                = archive_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNd32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi32 "i"
     * }
     */
    public static MemorySegment SCNi32() {
        class Holder {
            static final MemorySegment SCNi32
                = archive_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNi32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo32 "o"
     * }
     */
    public static MemorySegment SCNo32() {
        class Holder {
            static final MemorySegment SCNo32
                = archive_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNo32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu32 "u"
     * }
     */
    public static MemorySegment SCNu32() {
        class Holder {
            static final MemorySegment SCNu32
                = archive_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNu32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx32 "x"
     * }
     */
    public static MemorySegment SCNx32() {
        class Holder {
            static final MemorySegment SCNx32
                = archive_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNx32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd64 "lld"
     * }
     */
    public static MemorySegment SCNd64() {
        class Holder {
            static final MemorySegment SCNd64
                = archive_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNd64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi64 "lli"
     * }
     */
    public static MemorySegment SCNi64() {
        class Holder {
            static final MemorySegment SCNi64
                = archive_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNi64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo64 "llo"
     * }
     */
    public static MemorySegment SCNo64() {
        class Holder {
            static final MemorySegment SCNo64
                = archive_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNo64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu64 "llu"
     * }
     */
    public static MemorySegment SCNu64() {
        class Holder {
            static final MemorySegment SCNu64
                = archive_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNu64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx64 "llx"
     * }
     */
    public static MemorySegment SCNx64() {
        class Holder {
            static final MemorySegment SCNx64
                = archive_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNx64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdLEAST8() {
        class Holder {
            static final MemorySegment SCNdLEAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiLEAST8() {
        class Holder {
            static final MemorySegment SCNiLEAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST8 "hho"
     * }
     */
    public static MemorySegment SCNoLEAST8() {
        class Holder {
            static final MemorySegment SCNoLEAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuLEAST8() {
        class Holder {
            static final MemorySegment SCNuLEAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxLEAST8() {
        class Holder {
            static final MemorySegment SCNxLEAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST16 "hd"
     * }
     */
    public static MemorySegment SCNdLEAST16() {
        class Holder {
            static final MemorySegment SCNdLEAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST16 "hi"
     * }
     */
    public static MemorySegment SCNiLEAST16() {
        class Holder {
            static final MemorySegment SCNiLEAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST16 "ho"
     * }
     */
    public static MemorySegment SCNoLEAST16() {
        class Holder {
            static final MemorySegment SCNoLEAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST16 "hu"
     * }
     */
    public static MemorySegment SCNuLEAST16() {
        class Holder {
            static final MemorySegment SCNuLEAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST16 "hx"
     * }
     */
    public static MemorySegment SCNxLEAST16() {
        class Holder {
            static final MemorySegment SCNxLEAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST32 "d"
     * }
     */
    public static MemorySegment SCNdLEAST32() {
        class Holder {
            static final MemorySegment SCNdLEAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST32 "i"
     * }
     */
    public static MemorySegment SCNiLEAST32() {
        class Holder {
            static final MemorySegment SCNiLEAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST32 "o"
     * }
     */
    public static MemorySegment SCNoLEAST32() {
        class Holder {
            static final MemorySegment SCNoLEAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST32 "u"
     * }
     */
    public static MemorySegment SCNuLEAST32() {
        class Holder {
            static final MemorySegment SCNuLEAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST32 "x"
     * }
     */
    public static MemorySegment SCNxLEAST32() {
        class Holder {
            static final MemorySegment SCNxLEAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST64 "lld"
     * }
     */
    public static MemorySegment SCNdLEAST64() {
        class Holder {
            static final MemorySegment SCNdLEAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST64 "lli"
     * }
     */
    public static MemorySegment SCNiLEAST64() {
        class Holder {
            static final MemorySegment SCNiLEAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST64 "llo"
     * }
     */
    public static MemorySegment SCNoLEAST64() {
        class Holder {
            static final MemorySegment SCNoLEAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST64 "llu"
     * }
     */
    public static MemorySegment SCNuLEAST64() {
        class Holder {
            static final MemorySegment SCNuLEAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST64 "llx"
     * }
     */
    public static MemorySegment SCNxLEAST64() {
        class Holder {
            static final MemorySegment SCNxLEAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdFAST8() {
        class Holder {
            static final MemorySegment SCNdFAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiFAST8() {
        class Holder {
            static final MemorySegment SCNiFAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST8 "hho"
     * }
     */
    public static MemorySegment SCNoFAST8() {
        class Holder {
            static final MemorySegment SCNoFAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuFAST8() {
        class Holder {
            static final MemorySegment SCNuFAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxFAST8() {
        class Holder {
            static final MemorySegment SCNxFAST8
                = archive_h.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST16 "hd"
     * }
     */
    public static MemorySegment SCNdFAST16() {
        class Holder {
            static final MemorySegment SCNdFAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST16 "hi"
     * }
     */
    public static MemorySegment SCNiFAST16() {
        class Holder {
            static final MemorySegment SCNiFAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST16 "ho"
     * }
     */
    public static MemorySegment SCNoFAST16() {
        class Holder {
            static final MemorySegment SCNoFAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST16 "hu"
     * }
     */
    public static MemorySegment SCNuFAST16() {
        class Holder {
            static final MemorySegment SCNuFAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST16 "hx"
     * }
     */
    public static MemorySegment SCNxFAST16() {
        class Holder {
            static final MemorySegment SCNxFAST16
                = archive_h.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST32 "d"
     * }
     */
    public static MemorySegment SCNdFAST32() {
        class Holder {
            static final MemorySegment SCNdFAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST32 "i"
     * }
     */
    public static MemorySegment SCNiFAST32() {
        class Holder {
            static final MemorySegment SCNiFAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST32 "o"
     * }
     */
    public static MemorySegment SCNoFAST32() {
        class Holder {
            static final MemorySegment SCNoFAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST32 "u"
     * }
     */
    public static MemorySegment SCNuFAST32() {
        class Holder {
            static final MemorySegment SCNuFAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST32 "x"
     * }
     */
    public static MemorySegment SCNxFAST32() {
        class Holder {
            static final MemorySegment SCNxFAST32
                = archive_h.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST64 "lld"
     * }
     */
    public static MemorySegment SCNdFAST64() {
        class Holder {
            static final MemorySegment SCNdFAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST64 "lli"
     * }
     */
    public static MemorySegment SCNiFAST64() {
        class Holder {
            static final MemorySegment SCNiFAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST64 "llo"
     * }
     */
    public static MemorySegment SCNoFAST64() {
        class Holder {
            static final MemorySegment SCNoFAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST64 "llu"
     * }
     */
    public static MemorySegment SCNuFAST64() {
        class Holder {
            static final MemorySegment SCNuFAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST64 "llx"
     * }
     */
    public static MemorySegment SCNxFAST64() {
        class Holder {
            static final MemorySegment SCNxFAST64
                = archive_h.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdPTR "ld"
     * }
     */
    public static MemorySegment SCNdPTR() {
        class Holder {
            static final MemorySegment SCNdPTR
                = archive_h.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiPTR "li"
     * }
     */
    public static MemorySegment SCNiPTR() {
        class Holder {
            static final MemorySegment SCNiPTR
                = archive_h.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoPTR "lo"
     * }
     */
    public static MemorySegment SCNoPTR() {
        class Holder {
            static final MemorySegment SCNoPTR
                = archive_h.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuPTR "lu"
     * }
     */
    public static MemorySegment SCNuPTR() {
        class Holder {
            static final MemorySegment SCNuPTR
                = archive_h.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxPTR "lx"
     * }
     */
    public static MemorySegment SCNxPTR() {
        class Holder {
            static final MemorySegment SCNxPTR
                = archive_h.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdMAX "jd"
     * }
     */
    public static MemorySegment SCNdMAX() {
        class Holder {
            static final MemorySegment SCNdMAX
                = archive_h.LIBRARY_ARENA.allocateFrom("jd");
        }
        return Holder.SCNdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiMAX "ji"
     * }
     */
    public static MemorySegment SCNiMAX() {
        class Holder {
            static final MemorySegment SCNiMAX
                = archive_h.LIBRARY_ARENA.allocateFrom("ji");
        }
        return Holder.SCNiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoMAX "jo"
     * }
     */
    public static MemorySegment SCNoMAX() {
        class Holder {
            static final MemorySegment SCNoMAX
                = archive_h.LIBRARY_ARENA.allocateFrom("jo");
        }
        return Holder.SCNoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuMAX "ju"
     * }
     */
    public static MemorySegment SCNuMAX() {
        class Holder {
            static final MemorySegment SCNuMAX
                = archive_h.LIBRARY_ARENA.allocateFrom("ju");
        }
        return Holder.SCNuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxMAX "jx"
     * }
     */
    public static MemorySegment SCNxMAX() {
        class Holder {
            static final MemorySegment SCNxMAX
                = archive_h.LIBRARY_ARENA.allocateFrom("jx");
        }
        return Holder.SCNxMAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final long _POSIX_VERSION = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_VERSION 200112
     * }
     */
    public static long _POSIX_VERSION() {
        return _POSIX_VERSION;
    }
    private static final long _POSIX2_VERSION = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_VERSION 200112
     * }
     */
    public static long _POSIX2_VERSION() {
        return _POSIX2_VERSION;
    }
    private static final byte _POSIX_VDISABLE = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_VDISABLE 255
     * }
     */
    public static byte _POSIX_VDISABLE() {
        return _POSIX_VDISABLE;
    }
    private static final int X_OK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define X_OK 1
     * }
     */
    public static int X_OK() {
        return X_OK;
    }
    private static final int W_OK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define W_OK 2
     * }
     */
    public static int W_OK() {
        return W_OK;
    }
    private static final int R_OK = (int)4L;
    /**
     * {@snippet lang=c :
     * #define R_OK 4
     * }
     */
    public static int R_OK() {
        return R_OK;
    }
    private static final int _READ_OK = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _READ_OK 512
     * }
     */
    public static int _READ_OK() {
        return _READ_OK;
    }
    private static final int _WRITE_OK = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define _WRITE_OK 1024
     * }
     */
    public static int _WRITE_OK() {
        return _WRITE_OK;
    }
    private static final int _EXECUTE_OK = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _EXECUTE_OK 2048
     * }
     */
    public static int _EXECUTE_OK() {
        return _EXECUTE_OK;
    }
    private static final int _DELETE_OK = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _DELETE_OK 4096
     * }
     */
    public static int _DELETE_OK() {
        return _DELETE_OK;
    }
    private static final int _APPEND_OK = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define _APPEND_OK 8192
     * }
     */
    public static int _APPEND_OK() {
        return _APPEND_OK;
    }
    private static final int _RMFILE_OK = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define _RMFILE_OK 16384
     * }
     */
    public static int _RMFILE_OK() {
        return _RMFILE_OK;
    }
    private static final int _RATTR_OK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _RATTR_OK 32768
     * }
     */
    public static int _RATTR_OK() {
        return _RATTR_OK;
    }
    private static final int _WATTR_OK = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define _WATTR_OK 65536
     * }
     */
    public static int _WATTR_OK() {
        return _WATTR_OK;
    }
    private static final int _REXT_OK = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define _REXT_OK 131072
     * }
     */
    public static int _REXT_OK() {
        return _REXT_OK;
    }
    private static final int _WEXT_OK = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define _WEXT_OK 262144
     * }
     */
    public static int _WEXT_OK() {
        return _WEXT_OK;
    }
    private static final int _RPERM_OK = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define _RPERM_OK 524288
     * }
     */
    public static int _RPERM_OK() {
        return _RPERM_OK;
    }
    private static final int _WPERM_OK = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define _WPERM_OK 1048576
     * }
     */
    public static int _WPERM_OK() {
        return _WPERM_OK;
    }
    private static final int _CHOWN_OK = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define _CHOWN_OK 2097152
     * }
     */
    public static int _CHOWN_OK() {
        return _CHOWN_OK;
    }
    private static final int _ACCESS_EXTENDED_MASK = (int)4193792L;
    /**
     * {@snippet lang=c :
     * #define _ACCESS_EXTENDED_MASK 4193792
     * }
     */
    public static int _ACCESS_EXTENDED_MASK() {
        return _ACCESS_EXTENDED_MASK;
    }
    private static final int L_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define L_SET 0
     * }
     */
    public static int L_SET() {
        return L_SET;
    }
    private static final int L_INCR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define L_INCR 1
     * }
     */
    public static int L_INCR() {
        return L_INCR;
    }
    private static final int L_XTND = (int)2L;
    /**
     * {@snippet lang=c :
     * #define L_XTND 2
     * }
     */
    public static int L_XTND() {
        return L_XTND;
    }
    private static final int ACCESSX_MAX_TABLESIZE = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define ACCESSX_MAX_TABLESIZE 16384
     * }
     */
    public static int ACCESSX_MAX_TABLESIZE() {
        return ACCESSX_MAX_TABLESIZE;
    }
    private static final int _POSIX_ADVISORY_INFO = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ADVISORY_INFO -1
     * }
     */
    public static int _POSIX_ADVISORY_INFO() {
        return _POSIX_ADVISORY_INFO;
    }
    private static final int _POSIX_ASYNCHRONOUS_IO = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ASYNCHRONOUS_IO -1
     * }
     */
    public static int _POSIX_ASYNCHRONOUS_IO() {
        return _POSIX_ASYNCHRONOUS_IO;
    }
    private static final int _POSIX_BARRIERS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_BARRIERS -1
     * }
     */
    public static int _POSIX_BARRIERS() {
        return _POSIX_BARRIERS;
    }
    private static final long _POSIX_CHOWN_RESTRICTED = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CHOWN_RESTRICTED 200112
     * }
     */
    public static long _POSIX_CHOWN_RESTRICTED() {
        return _POSIX_CHOWN_RESTRICTED;
    }
    private static final int _POSIX_CLOCK_SELECTION = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CLOCK_SELECTION -1
     * }
     */
    public static int _POSIX_CLOCK_SELECTION() {
        return _POSIX_CLOCK_SELECTION;
    }
    private static final int _POSIX_CPUTIME = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CPUTIME -1
     * }
     */
    public static int _POSIX_CPUTIME() {
        return _POSIX_CPUTIME;
    }
    private static final long _POSIX_FSYNC = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_FSYNC 200112
     * }
     */
    public static long _POSIX_FSYNC() {
        return _POSIX_FSYNC;
    }
    private static final long _POSIX_IPV6 = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_IPV6 200112
     * }
     */
    public static long _POSIX_IPV6() {
        return _POSIX_IPV6;
    }
    private static final long _POSIX_JOB_CONTROL = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_JOB_CONTROL 200112
     * }
     */
    public static long _POSIX_JOB_CONTROL() {
        return _POSIX_JOB_CONTROL;
    }
    private static final long _POSIX_MAPPED_FILES = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAPPED_FILES 200112
     * }
     */
    public static long _POSIX_MAPPED_FILES() {
        return _POSIX_MAPPED_FILES;
    }
    private static final int _POSIX_MEMLOCK = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMLOCK -1
     * }
     */
    public static int _POSIX_MEMLOCK() {
        return _POSIX_MEMLOCK;
    }
    private static final int _POSIX_MEMLOCK_RANGE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMLOCK_RANGE -1
     * }
     */
    public static int _POSIX_MEMLOCK_RANGE() {
        return _POSIX_MEMLOCK_RANGE;
    }
    private static final long _POSIX_MEMORY_PROTECTION = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MEMORY_PROTECTION 200112
     * }
     */
    public static long _POSIX_MEMORY_PROTECTION() {
        return _POSIX_MEMORY_PROTECTION;
    }
    private static final int _POSIX_MESSAGE_PASSING = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MESSAGE_PASSING -1
     * }
     */
    public static int _POSIX_MESSAGE_PASSING() {
        return _POSIX_MESSAGE_PASSING;
    }
    private static final int _POSIX_MONOTONIC_CLOCK = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MONOTONIC_CLOCK -1
     * }
     */
    public static int _POSIX_MONOTONIC_CLOCK() {
        return _POSIX_MONOTONIC_CLOCK;
    }
    private static final long _POSIX_NO_TRUNC = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NO_TRUNC 200112
     * }
     */
    public static long _POSIX_NO_TRUNC() {
        return _POSIX_NO_TRUNC;
    }
    private static final int _POSIX_PRIORITIZED_IO = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PRIORITIZED_IO -1
     * }
     */
    public static int _POSIX_PRIORITIZED_IO() {
        return _POSIX_PRIORITIZED_IO;
    }
    private static final int _POSIX_PRIORITY_SCHEDULING = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PRIORITY_SCHEDULING -1
     * }
     */
    public static int _POSIX_PRIORITY_SCHEDULING() {
        return _POSIX_PRIORITY_SCHEDULING;
    }
    private static final int _POSIX_RAW_SOCKETS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RAW_SOCKETS -1
     * }
     */
    public static int _POSIX_RAW_SOCKETS() {
        return _POSIX_RAW_SOCKETS;
    }
    private static final long _POSIX_READER_WRITER_LOCKS = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_READER_WRITER_LOCKS 200112
     * }
     */
    public static long _POSIX_READER_WRITER_LOCKS() {
        return _POSIX_READER_WRITER_LOCKS;
    }
    private static final int _POSIX_REALTIME_SIGNALS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_REALTIME_SIGNALS -1
     * }
     */
    public static int _POSIX_REALTIME_SIGNALS() {
        return _POSIX_REALTIME_SIGNALS;
    }
    private static final long _POSIX_REGEXP = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_REGEXP 200112
     * }
     */
    public static long _POSIX_REGEXP() {
        return _POSIX_REGEXP;
    }
    private static final long _POSIX_SAVED_IDS = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SAVED_IDS 200112
     * }
     */
    public static long _POSIX_SAVED_IDS() {
        return _POSIX_SAVED_IDS;
    }
    private static final int _POSIX_SEMAPHORES = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEMAPHORES -1
     * }
     */
    public static int _POSIX_SEMAPHORES() {
        return _POSIX_SEMAPHORES;
    }
    private static final int _POSIX_SHARED_MEMORY_OBJECTS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SHARED_MEMORY_OBJECTS -1
     * }
     */
    public static int _POSIX_SHARED_MEMORY_OBJECTS() {
        return _POSIX_SHARED_MEMORY_OBJECTS;
    }
    private static final long _POSIX_SHELL = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SHELL 200112
     * }
     */
    public static long _POSIX_SHELL() {
        return _POSIX_SHELL;
    }
    private static final long _POSIX_SPAWN = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPAWN 200112
     * }
     */
    public static long _POSIX_SPAWN() {
        return _POSIX_SPAWN;
    }
    private static final int _POSIX_SPIN_LOCKS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPIN_LOCKS -1
     * }
     */
    public static int _POSIX_SPIN_LOCKS() {
        return _POSIX_SPIN_LOCKS;
    }
    private static final int _POSIX_SPORADIC_SERVER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SPORADIC_SERVER -1
     * }
     */
    public static int _POSIX_SPORADIC_SERVER() {
        return _POSIX_SPORADIC_SERVER;
    }
    private static final int _POSIX_SYNCHRONIZED_IO = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYNCHRONIZED_IO -1
     * }
     */
    public static int _POSIX_SYNCHRONIZED_IO() {
        return _POSIX_SYNCHRONIZED_IO;
    }
    private static final long _POSIX_THREAD_ATTR_STACKADDR = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ATTR_STACKADDR 200112
     * }
     */
    public static long _POSIX_THREAD_ATTR_STACKADDR() {
        return _POSIX_THREAD_ATTR_STACKADDR;
    }
    private static final long _POSIX_THREAD_ATTR_STACKSIZE = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_ATTR_STACKSIZE 200112
     * }
     */
    public static long _POSIX_THREAD_ATTR_STACKSIZE() {
        return _POSIX_THREAD_ATTR_STACKSIZE;
    }
    private static final int _POSIX_THREAD_CPUTIME = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_CPUTIME -1
     * }
     */
    public static int _POSIX_THREAD_CPUTIME() {
        return _POSIX_THREAD_CPUTIME;
    }
    private static final int _POSIX_THREAD_PRIO_INHERIT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIO_INHERIT -1
     * }
     */
    public static int _POSIX_THREAD_PRIO_INHERIT() {
        return _POSIX_THREAD_PRIO_INHERIT;
    }
    private static final int _POSIX_THREAD_PRIO_PROTECT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIO_PROTECT -1
     * }
     */
    public static int _POSIX_THREAD_PRIO_PROTECT() {
        return _POSIX_THREAD_PRIO_PROTECT;
    }
    private static final int _POSIX_THREAD_PRIORITY_SCHEDULING = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PRIORITY_SCHEDULING -1
     * }
     */
    public static int _POSIX_THREAD_PRIORITY_SCHEDULING() {
        return _POSIX_THREAD_PRIORITY_SCHEDULING;
    }
    private static final long _POSIX_THREAD_PROCESS_SHARED = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_PROCESS_SHARED 200112
     * }
     */
    public static long _POSIX_THREAD_PROCESS_SHARED() {
        return _POSIX_THREAD_PROCESS_SHARED;
    }
    private static final long _POSIX_THREAD_SAFE_FUNCTIONS = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_SAFE_FUNCTIONS 200112
     * }
     */
    public static long _POSIX_THREAD_SAFE_FUNCTIONS() {
        return _POSIX_THREAD_SAFE_FUNCTIONS;
    }
    private static final int _POSIX_THREAD_SPORADIC_SERVER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_SPORADIC_SERVER -1
     * }
     */
    public static int _POSIX_THREAD_SPORADIC_SERVER() {
        return _POSIX_THREAD_SPORADIC_SERVER;
    }
    private static final long _POSIX_THREADS = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREADS 200112
     * }
     */
    public static long _POSIX_THREADS() {
        return _POSIX_THREADS;
    }
    private static final int _POSIX_TIMEOUTS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMEOUTS -1
     * }
     */
    public static int _POSIX_TIMEOUTS() {
        return _POSIX_TIMEOUTS;
    }
    private static final int _POSIX_TIMERS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMERS -1
     * }
     */
    public static int _POSIX_TIMERS() {
        return _POSIX_TIMERS;
    }
    private static final int _POSIX_TRACE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE -1
     * }
     */
    public static int _POSIX_TRACE() {
        return _POSIX_TRACE;
    }
    private static final int _POSIX_TRACE_EVENT_FILTER = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_EVENT_FILTER -1
     * }
     */
    public static int _POSIX_TRACE_EVENT_FILTER() {
        return _POSIX_TRACE_EVENT_FILTER;
    }
    private static final int _POSIX_TRACE_INHERIT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_INHERIT -1
     * }
     */
    public static int _POSIX_TRACE_INHERIT() {
        return _POSIX_TRACE_INHERIT;
    }
    private static final int _POSIX_TRACE_LOG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TRACE_LOG -1
     * }
     */
    public static int _POSIX_TRACE_LOG() {
        return _POSIX_TRACE_LOG;
    }
    private static final int _POSIX_TYPED_MEMORY_OBJECTS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TYPED_MEMORY_OBJECTS -1
     * }
     */
    public static int _POSIX_TYPED_MEMORY_OBJECTS() {
        return _POSIX_TYPED_MEMORY_OBJECTS;
    }
    private static final long _POSIX2_C_BIND = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_C_BIND 200112
     * }
     */
    public static long _POSIX2_C_BIND() {
        return _POSIX2_C_BIND;
    }
    private static final long _POSIX2_C_DEV = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_C_DEV 200112
     * }
     */
    public static long _POSIX2_C_DEV() {
        return _POSIX2_C_DEV;
    }
    private static final long _POSIX2_CHAR_TERM = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_CHAR_TERM 200112
     * }
     */
    public static long _POSIX2_CHAR_TERM() {
        return _POSIX2_CHAR_TERM;
    }
    private static final int _POSIX2_FORT_DEV = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_FORT_DEV -1
     * }
     */
    public static int _POSIX2_FORT_DEV() {
        return _POSIX2_FORT_DEV;
    }
    private static final long _POSIX2_FORT_RUN = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_FORT_RUN 200112
     * }
     */
    public static long _POSIX2_FORT_RUN() {
        return _POSIX2_FORT_RUN;
    }
    private static final long _POSIX2_LOCALEDEF = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_LOCALEDEF 200112
     * }
     */
    public static long _POSIX2_LOCALEDEF() {
        return _POSIX2_LOCALEDEF;
    }
    private static final int _POSIX2_PBS = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS -1
     * }
     */
    public static int _POSIX2_PBS() {
        return _POSIX2_PBS;
    }
    private static final int _POSIX2_PBS_ACCOUNTING = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS_ACCOUNTING -1
     * }
     */
    public static int _POSIX2_PBS_ACCOUNTING() {
        return _POSIX2_PBS_ACCOUNTING;
    }
    private static final int _POSIX2_PBS_CHECKPOINT = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS_CHECKPOINT -1
     * }
     */
    public static int _POSIX2_PBS_CHECKPOINT() {
        return _POSIX2_PBS_CHECKPOINT;
    }
    private static final int _POSIX2_PBS_LOCATE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS_LOCATE -1
     * }
     */
    public static int _POSIX2_PBS_LOCATE() {
        return _POSIX2_PBS_LOCATE;
    }
    private static final int _POSIX2_PBS_MESSAGE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS_MESSAGE -1
     * }
     */
    public static int _POSIX2_PBS_MESSAGE() {
        return _POSIX2_PBS_MESSAGE;
    }
    private static final int _POSIX2_PBS_TRACK = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_PBS_TRACK -1
     * }
     */
    public static int _POSIX2_PBS_TRACK() {
        return _POSIX2_PBS_TRACK;
    }
    private static final long _POSIX2_SW_DEV = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_SW_DEV 200112
     * }
     */
    public static long _POSIX2_SW_DEV() {
        return _POSIX2_SW_DEV;
    }
    private static final long _POSIX2_UPE = 200112L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_UPE 200112
     * }
     */
    public static long _POSIX2_UPE() {
        return _POSIX2_UPE;
    }
    private static final int __ILP32_OFF32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFF32 -1
     * }
     */
    public static int __ILP32_OFF32() {
        return __ILP32_OFF32;
    }
    private static final int __ILP32_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define __ILP32_OFFBIG -1
     * }
     */
    public static int __ILP32_OFFBIG() {
        return __ILP32_OFFBIG;
    }
    private static final int __LP64_OFF64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __LP64_OFF64 1
     * }
     */
    public static int __LP64_OFF64() {
        return __LP64_OFF64;
    }
    private static final int __LPBIG_OFFBIG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __LPBIG_OFFBIG 1
     * }
     */
    public static int __LPBIG_OFFBIG() {
        return __LPBIG_OFFBIG;
    }
    private static final int _POSIX_V6_ILP32_OFF32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V6_ILP32_OFF32 -1
     * }
     */
    public static int _POSIX_V6_ILP32_OFF32() {
        return _POSIX_V6_ILP32_OFF32;
    }
    private static final int _POSIX_V6_ILP32_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V6_ILP32_OFFBIG -1
     * }
     */
    public static int _POSIX_V6_ILP32_OFFBIG() {
        return _POSIX_V6_ILP32_OFFBIG;
    }
    private static final int _POSIX_V6_LP64_OFF64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V6_LP64_OFF64 1
     * }
     */
    public static int _POSIX_V6_LP64_OFF64() {
        return _POSIX_V6_LP64_OFF64;
    }
    private static final int _POSIX_V6_LPBIG_OFFBIG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V6_LPBIG_OFFBIG 1
     * }
     */
    public static int _POSIX_V6_LPBIG_OFFBIG() {
        return _POSIX_V6_LPBIG_OFFBIG;
    }
    private static final int _POSIX_V7_ILP32_OFF32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V7_ILP32_OFF32 -1
     * }
     */
    public static int _POSIX_V7_ILP32_OFF32() {
        return _POSIX_V7_ILP32_OFF32;
    }
    private static final int _POSIX_V7_ILP32_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V7_ILP32_OFFBIG -1
     * }
     */
    public static int _POSIX_V7_ILP32_OFFBIG() {
        return _POSIX_V7_ILP32_OFFBIG;
    }
    private static final int _POSIX_V7_LP64_OFF64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V7_LP64_OFF64 1
     * }
     */
    public static int _POSIX_V7_LP64_OFF64() {
        return _POSIX_V7_LP64_OFF64;
    }
    private static final int _POSIX_V7_LPBIG_OFFBIG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_V7_LPBIG_OFFBIG 1
     * }
     */
    public static int _POSIX_V7_LPBIG_OFFBIG() {
        return _POSIX_V7_LPBIG_OFFBIG;
    }
    private static final int _V6_ILP32_OFF32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _V6_ILP32_OFF32 -1
     * }
     */
    public static int _V6_ILP32_OFF32() {
        return _V6_ILP32_OFF32;
    }
    private static final int _V6_ILP32_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _V6_ILP32_OFFBIG -1
     * }
     */
    public static int _V6_ILP32_OFFBIG() {
        return _V6_ILP32_OFFBIG;
    }
    private static final int _V6_LP64_OFF64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _V6_LP64_OFF64 1
     * }
     */
    public static int _V6_LP64_OFF64() {
        return _V6_LP64_OFF64;
    }
    private static final int _V6_LPBIG_OFFBIG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _V6_LPBIG_OFFBIG 1
     * }
     */
    public static int _V6_LPBIG_OFFBIG() {
        return _V6_LPBIG_OFFBIG;
    }
    private static final int _XBS5_ILP32_OFF32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XBS5_ILP32_OFF32 -1
     * }
     */
    public static int _XBS5_ILP32_OFF32() {
        return _XBS5_ILP32_OFF32;
    }
    private static final int _XBS5_ILP32_OFFBIG = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XBS5_ILP32_OFFBIG -1
     * }
     */
    public static int _XBS5_ILP32_OFFBIG() {
        return _XBS5_ILP32_OFFBIG;
    }
    private static final int _XBS5_LP64_OFF64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _XBS5_LP64_OFF64 1
     * }
     */
    public static int _XBS5_LP64_OFF64() {
        return _XBS5_LP64_OFF64;
    }
    private static final int _XBS5_LPBIG_OFFBIG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _XBS5_LPBIG_OFFBIG 1
     * }
     */
    public static int _XBS5_LPBIG_OFFBIG() {
        return _XBS5_LPBIG_OFFBIG;
    }
    private static final int _XOPEN_CRYPT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_CRYPT 1
     * }
     */
    public static int _XOPEN_CRYPT() {
        return _XOPEN_CRYPT;
    }
    private static final int _XOPEN_ENH_I18N = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_ENH_I18N 1
     * }
     */
    public static int _XOPEN_ENH_I18N() {
        return _XOPEN_ENH_I18N;
    }
    private static final int _XOPEN_LEGACY = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_LEGACY -1
     * }
     */
    public static int _XOPEN_LEGACY() {
        return _XOPEN_LEGACY;
    }
    private static final int _XOPEN_REALTIME = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_REALTIME -1
     * }
     */
    public static int _XOPEN_REALTIME() {
        return _XOPEN_REALTIME;
    }
}

