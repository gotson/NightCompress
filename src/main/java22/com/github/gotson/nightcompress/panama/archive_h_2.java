// Generated by jextract

package com.github.gotson.nightcompress.panama;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class archive_h_2 {

    archive_h_2() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }


    static {
        System.loadLibrary("archive");
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int ARCHIVE_VERSION_NUMBER = (int)3005000L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_VERSION_NUMBER 3005000
     * }
     */
    public static int ARCHIVE_VERSION_NUMBER() {
        return ARCHIVE_VERSION_NUMBER;
    }
    private static final int __has_safe_buffers = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_safe_buffers 0
     * }
     */
    public static int __has_safe_buffers() {
        return __has_safe_buffers;
    }
    private static final int __DARWIN_ONLY_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_ONLY_64_BIT_INO_T() {
        return __DARWIN_ONLY_64_BIT_INO_T;
    }
    private static final int __DARWIN_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int __DARWIN_ONLY_UNIX_CONFORMANCE() {
        return __DARWIN_ONLY_UNIX_CONFORMANCE;
    }
    private static final int __DARWIN_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_ONLY_VERS_1050 1
     * }
     */
    public static int __DARWIN_ONLY_VERS_1050() {
        return __DARWIN_ONLY_VERS_1050;
    }
    private static final int __DARWIN_UNIX03 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_UNIX03 1
     * }
     */
    public static int __DARWIN_UNIX03() {
        return __DARWIN_UNIX03;
    }
    private static final int __DARWIN_64_BIT_INO_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_64_BIT_INO_T 1
     * }
     */
    public static int __DARWIN_64_BIT_INO_T() {
        return __DARWIN_64_BIT_INO_T;
    }
    private static final int __DARWIN_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_VERS_1050 1
     * }
     */
    public static int __DARWIN_VERS_1050() {
        return __DARWIN_VERS_1050;
    }
    private static final int __DARWIN_NON_CANCELABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NON_CANCELABLE 0
     * }
     */
    public static int __DARWIN_NON_CANCELABLE() {
        return __DARWIN_NON_CANCELABLE;
    }
    private static final int __STDC_WANT_LIB_EXT1__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_WANT_LIB_EXT1__ 1
     * }
     */
    public static int __STDC_WANT_LIB_EXT1__() {
        return __STDC_WANT_LIB_EXT1__;
    }
    private static final int __DARWIN_NO_LONG_LONG = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NO_LONG_LONG 0
     * }
     */
    public static int __DARWIN_NO_LONG_LONG() {
        return __DARWIN_NO_LONG_LONG;
    }
    private static final int _DARWIN_FEATURE_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_64_BIT_INODE() {
        return _DARWIN_FEATURE_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_64_BIT_INODE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_64_BIT_INODE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_64_BIT_INODE() {
        return _DARWIN_FEATURE_ONLY_64_BIT_INODE;
    }
    private static final int _DARWIN_FEATURE_ONLY_VERS_1050 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_VERS_1050 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_VERS_1050() {
        return _DARWIN_FEATURE_ONLY_VERS_1050;
    }
    private static final int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1
     * }
     */
    public static int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE;
    }
    private static final int _DARWIN_FEATURE_UNIX_CONFORMANCE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _DARWIN_FEATURE_UNIX_CONFORMANCE 3
     * }
     */
    public static int _DARWIN_FEATURE_UNIX_CONFORMANCE() {
        return _DARWIN_FEATURE_UNIX_CONFORMANCE;
    }
    private static final int __has_ptrcheck = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __has_ptrcheck 0
     * }
     */
    public static int __has_ptrcheck() {
        return __has_ptrcheck;
    }
    private static final int __PTHREAD_SIZE__ = (int)8176L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_SIZE__ 8176
     * }
     */
    public static int __PTHREAD_SIZE__() {
        return __PTHREAD_SIZE__;
    }
    private static final int __PTHREAD_ATTR_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ATTR_SIZE__ 56
     * }
     */
    public static int __PTHREAD_ATTR_SIZE__() {
        return __PTHREAD_ATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEXATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEXATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_MUTEXATTR_SIZE__() {
        return __PTHREAD_MUTEXATTR_SIZE__;
    }
    private static final int __PTHREAD_MUTEX_SIZE__ = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_SIZE__ 56
     * }
     */
    public static int __PTHREAD_MUTEX_SIZE__() {
        return __PTHREAD_MUTEX_SIZE__;
    }
    private static final int __PTHREAD_CONDATTR_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_CONDATTR_SIZE__ 8
     * }
     */
    public static int __PTHREAD_CONDATTR_SIZE__() {
        return __PTHREAD_CONDATTR_SIZE__;
    }
    private static final int __PTHREAD_COND_SIZE__ = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_COND_SIZE__ 40
     * }
     */
    public static int __PTHREAD_COND_SIZE__() {
        return __PTHREAD_COND_SIZE__;
    }
    private static final int __PTHREAD_ONCE_SIZE__ = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_ONCE_SIZE__ 8
     * }
     */
    public static int __PTHREAD_ONCE_SIZE__() {
        return __PTHREAD_ONCE_SIZE__;
    }
    private static final int __PTHREAD_RWLOCK_SIZE__ = (int)192L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCK_SIZE__ 192
     * }
     */
    public static int __PTHREAD_RWLOCK_SIZE__() {
        return __PTHREAD_RWLOCK_SIZE__;
    }
    private static final int __PTHREAD_RWLOCKATTR_SIZE__ = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_RWLOCKATTR_SIZE__ 16
     * }
     */
    public static int __PTHREAD_RWLOCKATTR_SIZE__() {
        return __PTHREAD_RWLOCKATTR_SIZE__;
    }
    private static final int __API_TO_BE_DEPRECATED = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED() {
        return __API_TO_BE_DEPRECATED;
    }
    private static final int __API_TO_BE_DEPRECATED_MACOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACOS() {
        return __API_TO_BE_DEPRECATED_MACOS;
    }
    private static final int __API_TO_BE_DEPRECATED_IOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_IOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_IOS() {
        return __API_TO_BE_DEPRECATED_IOS;
    }
    private static final int __API_TO_BE_DEPRECATED_MACCATALYST = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_MACCATALYST 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_MACCATALYST() {
        return __API_TO_BE_DEPRECATED_MACCATALYST;
    }
    private static final int __API_TO_BE_DEPRECATED_WATCHOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_WATCHOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_WATCHOS() {
        return __API_TO_BE_DEPRECATED_WATCHOS;
    }
    private static final int __API_TO_BE_DEPRECATED_TVOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_TVOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_TVOS() {
        return __API_TO_BE_DEPRECATED_TVOS;
    }
    private static final int __API_TO_BE_DEPRECATED_DRIVERKIT = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_DRIVERKIT 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_DRIVERKIT() {
        return __API_TO_BE_DEPRECATED_DRIVERKIT;
    }
    private static final int __API_TO_BE_DEPRECATED_VISIONOS = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __API_TO_BE_DEPRECATED_VISIONOS 100000
     * }
     */
    public static int __API_TO_BE_DEPRECATED_VISIONOS() {
        return __API_TO_BE_DEPRECATED_VISIONOS;
    }
    private static final int __MAC_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_0 1000
     * }
     */
    public static int __MAC_10_0() {
        return __MAC_10_0;
    }
    private static final int __MAC_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_1 1010
     * }
     */
    public static int __MAC_10_1() {
        return __MAC_10_1;
    }
    private static final int __MAC_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_2 1020
     * }
     */
    public static int __MAC_10_2() {
        return __MAC_10_2;
    }
    private static final int __MAC_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_3 1030
     * }
     */
    public static int __MAC_10_3() {
        return __MAC_10_3;
    }
    private static final int __MAC_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_4 1040
     * }
     */
    public static int __MAC_10_4() {
        return __MAC_10_4;
    }
    private static final int __MAC_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_5 1050
     * }
     */
    public static int __MAC_10_5() {
        return __MAC_10_5;
    }
    private static final int __MAC_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_6 1060
     * }
     */
    public static int __MAC_10_6() {
        return __MAC_10_6;
    }
    private static final int __MAC_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_7 1070
     * }
     */
    public static int __MAC_10_7() {
        return __MAC_10_7;
    }
    private static final int __MAC_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_8 1080
     * }
     */
    public static int __MAC_10_8() {
        return __MAC_10_8;
    }
    private static final int __MAC_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_9 1090
     * }
     */
    public static int __MAC_10_9() {
        return __MAC_10_9;
    }
    private static final int __MAC_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10 101000
     * }
     */
    public static int __MAC_10_10() {
        return __MAC_10_10;
    }
    private static final int __MAC_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10_2 101002
     * }
     */
    public static int __MAC_10_10_2() {
        return __MAC_10_10_2;
    }
    private static final int __MAC_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_10_3 101003
     * }
     */
    public static int __MAC_10_10_3() {
        return __MAC_10_10_3;
    }
    private static final int __MAC_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11 101100
     * }
     */
    public static int __MAC_10_11() {
        return __MAC_10_11;
    }
    private static final int __MAC_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_2 101102
     * }
     */
    public static int __MAC_10_11_2() {
        return __MAC_10_11_2;
    }
    private static final int __MAC_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_3 101103
     * }
     */
    public static int __MAC_10_11_3() {
        return __MAC_10_11_3;
    }
    private static final int __MAC_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_11_4 101104
     * }
     */
    public static int __MAC_10_11_4() {
        return __MAC_10_11_4;
    }
    private static final int __MAC_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12 101200
     * }
     */
    public static int __MAC_10_12() {
        return __MAC_10_12;
    }
    private static final int __MAC_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_1 101201
     * }
     */
    public static int __MAC_10_12_1() {
        return __MAC_10_12_1;
    }
    private static final int __MAC_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_2 101202
     * }
     */
    public static int __MAC_10_12_2() {
        return __MAC_10_12_2;
    }
    private static final int __MAC_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_12_4 101204
     * }
     */
    public static int __MAC_10_12_4() {
        return __MAC_10_12_4;
    }
    private static final int __MAC_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13 101300
     * }
     */
    public static int __MAC_10_13() {
        return __MAC_10_13;
    }
    private static final int __MAC_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_1 101301
     * }
     */
    public static int __MAC_10_13_1() {
        return __MAC_10_13_1;
    }
    private static final int __MAC_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_2 101302
     * }
     */
    public static int __MAC_10_13_2() {
        return __MAC_10_13_2;
    }
    private static final int __MAC_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_13_4 101304
     * }
     */
    public static int __MAC_10_13_4() {
        return __MAC_10_13_4;
    }
    private static final int __MAC_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14 101400
     * }
     */
    public static int __MAC_10_14() {
        return __MAC_10_14;
    }
    private static final int __MAC_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_1 101401
     * }
     */
    public static int __MAC_10_14_1() {
        return __MAC_10_14_1;
    }
    private static final int __MAC_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_4 101404
     * }
     */
    public static int __MAC_10_14_4() {
        return __MAC_10_14_4;
    }
    private static final int __MAC_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_5 101405
     * }
     */
    public static int __MAC_10_14_5() {
        return __MAC_10_14_5;
    }
    private static final int __MAC_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_14_6 101406
     * }
     */
    public static int __MAC_10_14_6() {
        return __MAC_10_14_6;
    }
    private static final int __MAC_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15 101500
     * }
     */
    public static int __MAC_10_15() {
        return __MAC_10_15;
    }
    private static final int __MAC_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15_1 101501
     * }
     */
    public static int __MAC_10_15_1() {
        return __MAC_10_15_1;
    }
    private static final int __MAC_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_15_4 101504
     * }
     */
    public static int __MAC_10_15_4() {
        return __MAC_10_15_4;
    }
    private static final int __MAC_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_10_16 101600
     * }
     */
    public static int __MAC_10_16() {
        return __MAC_10_16;
    }
    private static final int __MAC_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_0 110000
     * }
     */
    public static int __MAC_11_0() {
        return __MAC_11_0;
    }
    private static final int __MAC_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_1 110100
     * }
     */
    public static int __MAC_11_1() {
        return __MAC_11_1;
    }
    private static final int __MAC_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_3 110300
     * }
     */
    public static int __MAC_11_3() {
        return __MAC_11_3;
    }
    private static final int __MAC_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_4 110400
     * }
     */
    public static int __MAC_11_4() {
        return __MAC_11_4;
    }
    private static final int __MAC_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_5 110500
     * }
     */
    public static int __MAC_11_5() {
        return __MAC_11_5;
    }
    private static final int __MAC_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_11_6 110600
     * }
     */
    public static int __MAC_11_6() {
        return __MAC_11_6;
    }
    private static final int __MAC_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_0 120000
     * }
     */
    public static int __MAC_12_0() {
        return __MAC_12_0;
    }
    private static final int __MAC_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_1 120100
     * }
     */
    public static int __MAC_12_1() {
        return __MAC_12_1;
    }
    private static final int __MAC_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_2 120200
     * }
     */
    public static int __MAC_12_2() {
        return __MAC_12_2;
    }
    private static final int __MAC_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_3 120300
     * }
     */
    public static int __MAC_12_3() {
        return __MAC_12_3;
    }
    private static final int __MAC_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_4 120400
     * }
     */
    public static int __MAC_12_4() {
        return __MAC_12_4;
    }
    private static final int __MAC_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_5 120500
     * }
     */
    public static int __MAC_12_5() {
        return __MAC_12_5;
    }
    private static final int __MAC_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_6 120600
     * }
     */
    public static int __MAC_12_6() {
        return __MAC_12_6;
    }
    private static final int __MAC_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define __MAC_12_7 120700
     * }
     */
    public static int __MAC_12_7() {
        return __MAC_12_7;
    }
    private static final int __MAC_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_0 130000
     * }
     */
    public static int __MAC_13_0() {
        return __MAC_13_0;
    }
    private static final int __MAC_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_1 130100
     * }
     */
    public static int __MAC_13_1() {
        return __MAC_13_1;
    }
    private static final int __MAC_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_2 130200
     * }
     */
    public static int __MAC_13_2() {
        return __MAC_13_2;
    }
    private static final int __MAC_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_3 130300
     * }
     */
    public static int __MAC_13_3() {
        return __MAC_13_3;
    }
    private static final int __MAC_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_4 130400
     * }
     */
    public static int __MAC_13_4() {
        return __MAC_13_4;
    }
    private static final int __MAC_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_5 130500
     * }
     */
    public static int __MAC_13_5() {
        return __MAC_13_5;
    }
    private static final int __MAC_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define __MAC_13_6 130600
     * }
     */
    public static int __MAC_13_6() {
        return __MAC_13_6;
    }
    private static final int __MAC_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_0 140000
     * }
     */
    public static int __MAC_14_0() {
        return __MAC_14_0;
    }
    private static final int __MAC_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_1 140100
     * }
     */
    public static int __MAC_14_1() {
        return __MAC_14_1;
    }
    private static final int __MAC_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_2 140200
     * }
     */
    public static int __MAC_14_2() {
        return __MAC_14_2;
    }
    private static final int __MAC_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_3 140300
     * }
     */
    public static int __MAC_14_3() {
        return __MAC_14_3;
    }
    private static final int __MAC_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define __MAC_14_4 140400
     * }
     */
    public static int __MAC_14_4() {
        return __MAC_14_4;
    }
    private static final int __IPHONE_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_0 20000
     * }
     */
    public static int __IPHONE_2_0() {
        return __IPHONE_2_0;
    }
    private static final int __IPHONE_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_1 20100
     * }
     */
    public static int __IPHONE_2_1() {
        return __IPHONE_2_1;
    }
    private static final int __IPHONE_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_2_2 20200
     * }
     */
    public static int __IPHONE_2_2() {
        return __IPHONE_2_2;
    }
    private static final int __IPHONE_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_0 30000
     * }
     */
    public static int __IPHONE_3_0() {
        return __IPHONE_3_0;
    }
    private static final int __IPHONE_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_1 30100
     * }
     */
    public static int __IPHONE_3_1() {
        return __IPHONE_3_1;
    }
    private static final int __IPHONE_3_2 = (int)30200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_3_2 30200
     * }
     */
    public static int __IPHONE_3_2() {
        return __IPHONE_3_2;
    }
    private static final int __IPHONE_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_0 40000
     * }
     */
    public static int __IPHONE_4_0() {
        return __IPHONE_4_0;
    }
    private static final int __IPHONE_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_1 40100
     * }
     */
    public static int __IPHONE_4_1() {
        return __IPHONE_4_1;
    }
    private static final int __IPHONE_4_2 = (int)40200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_2 40200
     * }
     */
    public static int __IPHONE_4_2() {
        return __IPHONE_4_2;
    }
    private static final int __IPHONE_4_3 = (int)40300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_4_3 40300
     * }
     */
    public static int __IPHONE_4_3() {
        return __IPHONE_4_3;
    }
    private static final int __IPHONE_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_5_0 50000
     * }
     */
    public static int __IPHONE_5_0() {
        return __IPHONE_5_0;
    }
    private static final int __IPHONE_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_5_1 50100
     * }
     */
    public static int __IPHONE_5_1() {
        return __IPHONE_5_1;
    }
    private static final int __IPHONE_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_6_0 60000
     * }
     */
    public static int __IPHONE_6_0() {
        return __IPHONE_6_0;
    }
    private static final int __IPHONE_6_1 = (int)60100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_6_1 60100
     * }
     */
    public static int __IPHONE_6_1() {
        return __IPHONE_6_1;
    }
    private static final int __IPHONE_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_7_0 70000
     * }
     */
    public static int __IPHONE_7_0() {
        return __IPHONE_7_0;
    }
    private static final int __IPHONE_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_7_1 70100
     * }
     */
    public static int __IPHONE_7_1() {
        return __IPHONE_7_1;
    }
    private static final int __IPHONE_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_0 80000
     * }
     */
    public static int __IPHONE_8_0() {
        return __IPHONE_8_0;
    }
    private static final int __IPHONE_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_1 80100
     * }
     */
    public static int __IPHONE_8_1() {
        return __IPHONE_8_1;
    }
    private static final int __IPHONE_8_2 = (int)80200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_2 80200
     * }
     */
    public static int __IPHONE_8_2() {
        return __IPHONE_8_2;
    }
    private static final int __IPHONE_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_3 80300
     * }
     */
    public static int __IPHONE_8_3() {
        return __IPHONE_8_3;
    }
    private static final int __IPHONE_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_8_4 80400
     * }
     */
    public static int __IPHONE_8_4() {
        return __IPHONE_8_4;
    }
    private static final int __IPHONE_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_0 90000
     * }
     */
    public static int __IPHONE_9_0() {
        return __IPHONE_9_0;
    }
    private static final int __IPHONE_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_1 90100
     * }
     */
    public static int __IPHONE_9_1() {
        return __IPHONE_9_1;
    }
    private static final int __IPHONE_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_2 90200
     * }
     */
    public static int __IPHONE_9_2() {
        return __IPHONE_9_2;
    }
    private static final int __IPHONE_9_3 = (int)90300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_9_3 90300
     * }
     */
    public static int __IPHONE_9_3() {
        return __IPHONE_9_3;
    }
    private static final int __IPHONE_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_0 100000
     * }
     */
    public static int __IPHONE_10_0() {
        return __IPHONE_10_0;
    }
    private static final int __IPHONE_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_1 100100
     * }
     */
    public static int __IPHONE_10_1() {
        return __IPHONE_10_1;
    }
    private static final int __IPHONE_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_2 100200
     * }
     */
    public static int __IPHONE_10_2() {
        return __IPHONE_10_2;
    }
    private static final int __IPHONE_10_3 = (int)100300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_10_3 100300
     * }
     */
    public static int __IPHONE_10_3() {
        return __IPHONE_10_3;
    }
    private static final int __IPHONE_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_0 110000
     * }
     */
    public static int __IPHONE_11_0() {
        return __IPHONE_11_0;
    }
    private static final int __IPHONE_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_1 110100
     * }
     */
    public static int __IPHONE_11_1() {
        return __IPHONE_11_1;
    }
    private static final int __IPHONE_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_2 110200
     * }
     */
    public static int __IPHONE_11_2() {
        return __IPHONE_11_2;
    }
    private static final int __IPHONE_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_3 110300
     * }
     */
    public static int __IPHONE_11_3() {
        return __IPHONE_11_3;
    }
    private static final int __IPHONE_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_11_4 110400
     * }
     */
    public static int __IPHONE_11_4() {
        return __IPHONE_11_4;
    }
    private static final int __IPHONE_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_0 120000
     * }
     */
    public static int __IPHONE_12_0() {
        return __IPHONE_12_0;
    }
    private static final int __IPHONE_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_1 120100
     * }
     */
    public static int __IPHONE_12_1() {
        return __IPHONE_12_1;
    }
    private static final int __IPHONE_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_2 120200
     * }
     */
    public static int __IPHONE_12_2() {
        return __IPHONE_12_2;
    }
    private static final int __IPHONE_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_3 120300
     * }
     */
    public static int __IPHONE_12_3() {
        return __IPHONE_12_3;
    }
    private static final int __IPHONE_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_12_4 120400
     * }
     */
    public static int __IPHONE_12_4() {
        return __IPHONE_12_4;
    }
    private static final int __IPHONE_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_0 130000
     * }
     */
    public static int __IPHONE_13_0() {
        return __IPHONE_13_0;
    }
    private static final int __IPHONE_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_1 130100
     * }
     */
    public static int __IPHONE_13_1() {
        return __IPHONE_13_1;
    }
    private static final int __IPHONE_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_2 130200
     * }
     */
    public static int __IPHONE_13_2() {
        return __IPHONE_13_2;
    }
    private static final int __IPHONE_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_3 130300
     * }
     */
    public static int __IPHONE_13_3() {
        return __IPHONE_13_3;
    }
    private static final int __IPHONE_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_4 130400
     * }
     */
    public static int __IPHONE_13_4() {
        return __IPHONE_13_4;
    }
    private static final int __IPHONE_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_5 130500
     * }
     */
    public static int __IPHONE_13_5() {
        return __IPHONE_13_5;
    }
    private static final int __IPHONE_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_6 130600
     * }
     */
    public static int __IPHONE_13_6() {
        return __IPHONE_13_6;
    }
    private static final int __IPHONE_13_7 = (int)130700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_13_7 130700
     * }
     */
    public static int __IPHONE_13_7() {
        return __IPHONE_13_7;
    }
    private static final int __IPHONE_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_0 140000
     * }
     */
    public static int __IPHONE_14_0() {
        return __IPHONE_14_0;
    }
    private static final int __IPHONE_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_1 140100
     * }
     */
    public static int __IPHONE_14_1() {
        return __IPHONE_14_1;
    }
    private static final int __IPHONE_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_2 140200
     * }
     */
    public static int __IPHONE_14_2() {
        return __IPHONE_14_2;
    }
    private static final int __IPHONE_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_3 140300
     * }
     */
    public static int __IPHONE_14_3() {
        return __IPHONE_14_3;
    }
    private static final int __IPHONE_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_5 140500
     * }
     */
    public static int __IPHONE_14_5() {
        return __IPHONE_14_5;
    }
    private static final int __IPHONE_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_4 140400
     * }
     */
    public static int __IPHONE_14_4() {
        return __IPHONE_14_4;
    }
    private static final int __IPHONE_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_6 140600
     * }
     */
    public static int __IPHONE_14_6() {
        return __IPHONE_14_6;
    }
    private static final int __IPHONE_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_7 140700
     * }
     */
    public static int __IPHONE_14_7() {
        return __IPHONE_14_7;
    }
    private static final int __IPHONE_14_8 = (int)140800L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_14_8 140800
     * }
     */
    public static int __IPHONE_14_8() {
        return __IPHONE_14_8;
    }
    private static final int __IPHONE_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_0 150000
     * }
     */
    public static int __IPHONE_15_0() {
        return __IPHONE_15_0;
    }
    private static final int __IPHONE_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_1 150100
     * }
     */
    public static int __IPHONE_15_1() {
        return __IPHONE_15_1;
    }
    private static final int __IPHONE_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_2 150200
     * }
     */
    public static int __IPHONE_15_2() {
        return __IPHONE_15_2;
    }
    private static final int __IPHONE_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_3 150300
     * }
     */
    public static int __IPHONE_15_3() {
        return __IPHONE_15_3;
    }
    private static final int __IPHONE_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_4 150400
     * }
     */
    public static int __IPHONE_15_4() {
        return __IPHONE_15_4;
    }
    private static final int __IPHONE_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_5 150500
     * }
     */
    public static int __IPHONE_15_5() {
        return __IPHONE_15_5;
    }
    private static final int __IPHONE_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_6 150600
     * }
     */
    public static int __IPHONE_15_6() {
        return __IPHONE_15_6;
    }
    private static final int __IPHONE_15_7 = (int)150700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_7 150700
     * }
     */
    public static int __IPHONE_15_7() {
        return __IPHONE_15_7;
    }
    private static final int __IPHONE_15_8 = (int)150800L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_15_8 150800
     * }
     */
    public static int __IPHONE_15_8() {
        return __IPHONE_15_8;
    }
    private static final int __IPHONE_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_0 160000
     * }
     */
    public static int __IPHONE_16_0() {
        return __IPHONE_16_0;
    }
    private static final int __IPHONE_16_1 = (int)160100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_1 160100
     * }
     */
    public static int __IPHONE_16_1() {
        return __IPHONE_16_1;
    }
    private static final int __IPHONE_16_2 = (int)160200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_2 160200
     * }
     */
    public static int __IPHONE_16_2() {
        return __IPHONE_16_2;
    }
    private static final int __IPHONE_16_3 = (int)160300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_3 160300
     * }
     */
    public static int __IPHONE_16_3() {
        return __IPHONE_16_3;
    }
    private static final int __IPHONE_16_4 = (int)160400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_4 160400
     * }
     */
    public static int __IPHONE_16_4() {
        return __IPHONE_16_4;
    }
    private static final int __IPHONE_16_5 = (int)160500L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_5 160500
     * }
     */
    public static int __IPHONE_16_5() {
        return __IPHONE_16_5;
    }
    private static final int __IPHONE_16_6 = (int)160600L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_6 160600
     * }
     */
    public static int __IPHONE_16_6() {
        return __IPHONE_16_6;
    }
    private static final int __IPHONE_16_7 = (int)160700L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_16_7 160700
     * }
     */
    public static int __IPHONE_16_7() {
        return __IPHONE_16_7;
    }
    private static final int __IPHONE_17_0 = (int)170000L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_0 170000
     * }
     */
    public static int __IPHONE_17_0() {
        return __IPHONE_17_0;
    }
    private static final int __IPHONE_17_1 = (int)170100L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_1 170100
     * }
     */
    public static int __IPHONE_17_1() {
        return __IPHONE_17_1;
    }
    private static final int __IPHONE_17_2 = (int)170200L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_2 170200
     * }
     */
    public static int __IPHONE_17_2() {
        return __IPHONE_17_2;
    }
    private static final int __IPHONE_17_3 = (int)170300L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_3 170300
     * }
     */
    public static int __IPHONE_17_3() {
        return __IPHONE_17_3;
    }
    private static final int __IPHONE_17_4 = (int)170400L;
    /**
     * {@snippet lang=c :
     * #define __IPHONE_17_4 170400
     * }
     */
    public static int __IPHONE_17_4() {
        return __IPHONE_17_4;
    }
    private static final int __WATCHOS_1_0 = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_1_0 10000
     * }
     */
    public static int __WATCHOS_1_0() {
        return __WATCHOS_1_0;
    }
    private static final int __WATCHOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_0 20000
     * }
     */
    public static int __WATCHOS_2_0() {
        return __WATCHOS_2_0;
    }
    private static final int __WATCHOS_2_1 = (int)20100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_1 20100
     * }
     */
    public static int __WATCHOS_2_1() {
        return __WATCHOS_2_1;
    }
    private static final int __WATCHOS_2_2 = (int)20200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_2_2 20200
     * }
     */
    public static int __WATCHOS_2_2() {
        return __WATCHOS_2_2;
    }
    private static final int __WATCHOS_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_0 30000
     * }
     */
    public static int __WATCHOS_3_0() {
        return __WATCHOS_3_0;
    }
    private static final int __WATCHOS_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_1 30100
     * }
     */
    public static int __WATCHOS_3_1() {
        return __WATCHOS_3_1;
    }
    private static final int __WATCHOS_3_1_1 = (int)30101L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_1_1 30101
     * }
     */
    public static int __WATCHOS_3_1_1() {
        return __WATCHOS_3_1_1;
    }
    private static final int __WATCHOS_3_2 = (int)30200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_3_2 30200
     * }
     */
    public static int __WATCHOS_3_2() {
        return __WATCHOS_3_2;
    }
    private static final int __WATCHOS_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_0 40000
     * }
     */
    public static int __WATCHOS_4_0() {
        return __WATCHOS_4_0;
    }
    private static final int __WATCHOS_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_1 40100
     * }
     */
    public static int __WATCHOS_4_1() {
        return __WATCHOS_4_1;
    }
    private static final int __WATCHOS_4_2 = (int)40200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_2 40200
     * }
     */
    public static int __WATCHOS_4_2() {
        return __WATCHOS_4_2;
    }
    private static final int __WATCHOS_4_3 = (int)40300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_4_3 40300
     * }
     */
    public static int __WATCHOS_4_3() {
        return __WATCHOS_4_3;
    }
    private static final int __WATCHOS_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_0 50000
     * }
     */
    public static int __WATCHOS_5_0() {
        return __WATCHOS_5_0;
    }
    private static final int __WATCHOS_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_1 50100
     * }
     */
    public static int __WATCHOS_5_1() {
        return __WATCHOS_5_1;
    }
    private static final int __WATCHOS_5_2 = (int)50200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_2 50200
     * }
     */
    public static int __WATCHOS_5_2() {
        return __WATCHOS_5_2;
    }
    private static final int __WATCHOS_5_3 = (int)50300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_5_3 50300
     * }
     */
    public static int __WATCHOS_5_3() {
        return __WATCHOS_5_3;
    }
    private static final int __WATCHOS_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_0 60000
     * }
     */
    public static int __WATCHOS_6_0() {
        return __WATCHOS_6_0;
    }
    private static final int __WATCHOS_6_1 = (int)60100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_1 60100
     * }
     */
    public static int __WATCHOS_6_1() {
        return __WATCHOS_6_1;
    }
    private static final int __WATCHOS_6_2 = (int)60200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_6_2 60200
     * }
     */
    public static int __WATCHOS_6_2() {
        return __WATCHOS_6_2;
    }
    private static final int __WATCHOS_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_0 70000
     * }
     */
    public static int __WATCHOS_7_0() {
        return __WATCHOS_7_0;
    }
    private static final int __WATCHOS_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_1 70100
     * }
     */
    public static int __WATCHOS_7_1() {
        return __WATCHOS_7_1;
    }
    private static final int __WATCHOS_7_2 = (int)70200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_2 70200
     * }
     */
    public static int __WATCHOS_7_2() {
        return __WATCHOS_7_2;
    }
    private static final int __WATCHOS_7_3 = (int)70300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_3 70300
     * }
     */
    public static int __WATCHOS_7_3() {
        return __WATCHOS_7_3;
    }
    private static final int __WATCHOS_7_4 = (int)70400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_4 70400
     * }
     */
    public static int __WATCHOS_7_4() {
        return __WATCHOS_7_4;
    }
    private static final int __WATCHOS_7_5 = (int)70500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_5 70500
     * }
     */
    public static int __WATCHOS_7_5() {
        return __WATCHOS_7_5;
    }
    private static final int __WATCHOS_7_6 = (int)70600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_7_6 70600
     * }
     */
    public static int __WATCHOS_7_6() {
        return __WATCHOS_7_6;
    }
    private static final int __WATCHOS_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_0 80000
     * }
     */
    public static int __WATCHOS_8_0() {
        return __WATCHOS_8_0;
    }
    private static final int __WATCHOS_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_1 80100
     * }
     */
    public static int __WATCHOS_8_1() {
        return __WATCHOS_8_1;
    }
    private static final int __WATCHOS_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_3 80300
     * }
     */
    public static int __WATCHOS_8_3() {
        return __WATCHOS_8_3;
    }
    private static final int __WATCHOS_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_4 80400
     * }
     */
    public static int __WATCHOS_8_4() {
        return __WATCHOS_8_4;
    }
    private static final int __WATCHOS_8_5 = (int)80500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_5 80500
     * }
     */
    public static int __WATCHOS_8_5() {
        return __WATCHOS_8_5;
    }
    private static final int __WATCHOS_8_6 = (int)80600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_6 80600
     * }
     */
    public static int __WATCHOS_8_6() {
        return __WATCHOS_8_6;
    }
    private static final int __WATCHOS_8_7 = (int)80700L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_7 80700
     * }
     */
    public static int __WATCHOS_8_7() {
        return __WATCHOS_8_7;
    }
    private static final int __WATCHOS_8_8 = (int)80800L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_8_8 80800
     * }
     */
    public static int __WATCHOS_8_8() {
        return __WATCHOS_8_8;
    }
    private static final int __WATCHOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_0 90000
     * }
     */
    public static int __WATCHOS_9_0() {
        return __WATCHOS_9_0;
    }
    private static final int __WATCHOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_1 90100
     * }
     */
    public static int __WATCHOS_9_1() {
        return __WATCHOS_9_1;
    }
    private static final int __WATCHOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_2 90200
     * }
     */
    public static int __WATCHOS_9_2() {
        return __WATCHOS_9_2;
    }
    private static final int __WATCHOS_9_3 = (int)90300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_3 90300
     * }
     */
    public static int __WATCHOS_9_3() {
        return __WATCHOS_9_3;
    }
    private static final int __WATCHOS_9_4 = (int)90400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_4 90400
     * }
     */
    public static int __WATCHOS_9_4() {
        return __WATCHOS_9_4;
    }
    private static final int __WATCHOS_9_5 = (int)90500L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_5 90500
     * }
     */
    public static int __WATCHOS_9_5() {
        return __WATCHOS_9_5;
    }
    private static final int __WATCHOS_9_6 = (int)90600L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_9_6 90600
     * }
     */
    public static int __WATCHOS_9_6() {
        return __WATCHOS_9_6;
    }
    private static final int __WATCHOS_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_0 100000
     * }
     */
    public static int __WATCHOS_10_0() {
        return __WATCHOS_10_0;
    }
    private static final int __WATCHOS_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_1 100100
     * }
     */
    public static int __WATCHOS_10_1() {
        return __WATCHOS_10_1;
    }
    private static final int __WATCHOS_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_2 100200
     * }
     */
    public static int __WATCHOS_10_2() {
        return __WATCHOS_10_2;
    }
    private static final int __WATCHOS_10_3 = (int)100300L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_3 100300
     * }
     */
    public static int __WATCHOS_10_3() {
        return __WATCHOS_10_3;
    }
    private static final int __WATCHOS_10_4 = (int)100400L;
    /**
     * {@snippet lang=c :
     * #define __WATCHOS_10_4 100400
     * }
     */
    public static int __WATCHOS_10_4() {
        return __WATCHOS_10_4;
    }
    private static final int __TVOS_9_0 = (int)90000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_0 90000
     * }
     */
    public static int __TVOS_9_0() {
        return __TVOS_9_0;
    }
    private static final int __TVOS_9_1 = (int)90100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_1 90100
     * }
     */
    public static int __TVOS_9_1() {
        return __TVOS_9_1;
    }
    private static final int __TVOS_9_2 = (int)90200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_9_2 90200
     * }
     */
    public static int __TVOS_9_2() {
        return __TVOS_9_2;
    }
    private static final int __TVOS_10_0 = (int)100000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_0 100000
     * }
     */
    public static int __TVOS_10_0() {
        return __TVOS_10_0;
    }
    private static final int __TVOS_10_0_1 = (int)100001L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_0_1 100001
     * }
     */
    public static int __TVOS_10_0_1() {
        return __TVOS_10_0_1;
    }
    private static final int __TVOS_10_1 = (int)100100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_1 100100
     * }
     */
    public static int __TVOS_10_1() {
        return __TVOS_10_1;
    }
    private static final int __TVOS_10_2 = (int)100200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_10_2 100200
     * }
     */
    public static int __TVOS_10_2() {
        return __TVOS_10_2;
    }
    private static final int __TVOS_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_0 110000
     * }
     */
    public static int __TVOS_11_0() {
        return __TVOS_11_0;
    }
    private static final int __TVOS_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_1 110100
     * }
     */
    public static int __TVOS_11_1() {
        return __TVOS_11_1;
    }
    private static final int __TVOS_11_2 = (int)110200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_2 110200
     * }
     */
    public static int __TVOS_11_2() {
        return __TVOS_11_2;
    }
    private static final int __TVOS_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_3 110300
     * }
     */
    public static int __TVOS_11_3() {
        return __TVOS_11_3;
    }
    private static final int __TVOS_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_11_4 110400
     * }
     */
    public static int __TVOS_11_4() {
        return __TVOS_11_4;
    }
    private static final int __TVOS_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_0 120000
     * }
     */
    public static int __TVOS_12_0() {
        return __TVOS_12_0;
    }
    private static final int __TVOS_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_1 120100
     * }
     */
    public static int __TVOS_12_1() {
        return __TVOS_12_1;
    }
    private static final int __TVOS_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_2 120200
     * }
     */
    public static int __TVOS_12_2() {
        return __TVOS_12_2;
    }
    private static final int __TVOS_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_3 120300
     * }
     */
    public static int __TVOS_12_3() {
        return __TVOS_12_3;
    }
    private static final int __TVOS_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_12_4 120400
     * }
     */
    public static int __TVOS_12_4() {
        return __TVOS_12_4;
    }
    private static final int __TVOS_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_0 130000
     * }
     */
    public static int __TVOS_13_0() {
        return __TVOS_13_0;
    }
    private static final int __TVOS_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_2 130200
     * }
     */
    public static int __TVOS_13_2() {
        return __TVOS_13_2;
    }
    private static final int __TVOS_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_3 130300
     * }
     */
    public static int __TVOS_13_3() {
        return __TVOS_13_3;
    }
    private static final int __TVOS_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_13_4 130400
     * }
     */
    public static int __TVOS_13_4() {
        return __TVOS_13_4;
    }
    private static final int __TVOS_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_0 140000
     * }
     */
    public static int __TVOS_14_0() {
        return __TVOS_14_0;
    }
    private static final int __TVOS_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_1 140100
     * }
     */
    public static int __TVOS_14_1() {
        return __TVOS_14_1;
    }
    private static final int __TVOS_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_2 140200
     * }
     */
    public static int __TVOS_14_2() {
        return __TVOS_14_2;
    }
    private static final int __TVOS_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_3 140300
     * }
     */
    public static int __TVOS_14_3() {
        return __TVOS_14_3;
    }
    private static final int __TVOS_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_5 140500
     * }
     */
    public static int __TVOS_14_5() {
        return __TVOS_14_5;
    }
    private static final int __TVOS_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_6 140600
     * }
     */
    public static int __TVOS_14_6() {
        return __TVOS_14_6;
    }
    private static final int __TVOS_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_14_7 140700
     * }
     */
    public static int __TVOS_14_7() {
        return __TVOS_14_7;
    }
    private static final int __TVOS_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_0 150000
     * }
     */
    public static int __TVOS_15_0() {
        return __TVOS_15_0;
    }
    private static final int __TVOS_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_1 150100
     * }
     */
    public static int __TVOS_15_1() {
        return __TVOS_15_1;
    }
    private static final int __TVOS_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_2 150200
     * }
     */
    public static int __TVOS_15_2() {
        return __TVOS_15_2;
    }
    private static final int __TVOS_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_3 150300
     * }
     */
    public static int __TVOS_15_3() {
        return __TVOS_15_3;
    }
    private static final int __TVOS_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_4 150400
     * }
     */
    public static int __TVOS_15_4() {
        return __TVOS_15_4;
    }
    private static final int __TVOS_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_5 150500
     * }
     */
    public static int __TVOS_15_5() {
        return __TVOS_15_5;
    }
    private static final int __TVOS_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_15_6 150600
     * }
     */
    public static int __TVOS_15_6() {
        return __TVOS_15_6;
    }
    private static final int __TVOS_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_0 160000
     * }
     */
    public static int __TVOS_16_0() {
        return __TVOS_16_0;
    }
    private static final int __TVOS_16_1 = (int)160100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_1 160100
     * }
     */
    public static int __TVOS_16_1() {
        return __TVOS_16_1;
    }
    private static final int __TVOS_16_2 = (int)160200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_2 160200
     * }
     */
    public static int __TVOS_16_2() {
        return __TVOS_16_2;
    }
    private static final int __TVOS_16_3 = (int)160300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_3 160300
     * }
     */
    public static int __TVOS_16_3() {
        return __TVOS_16_3;
    }
    private static final int __TVOS_16_4 = (int)160400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_4 160400
     * }
     */
    public static int __TVOS_16_4() {
        return __TVOS_16_4;
    }
    private static final int __TVOS_16_5 = (int)160500L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_5 160500
     * }
     */
    public static int __TVOS_16_5() {
        return __TVOS_16_5;
    }
    private static final int __TVOS_16_6 = (int)160600L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_16_6 160600
     * }
     */
    public static int __TVOS_16_6() {
        return __TVOS_16_6;
    }
    private static final int __TVOS_17_0 = (int)170000L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_0 170000
     * }
     */
    public static int __TVOS_17_0() {
        return __TVOS_17_0;
    }
    private static final int __TVOS_17_1 = (int)170100L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_1 170100
     * }
     */
    public static int __TVOS_17_1() {
        return __TVOS_17_1;
    }
    private static final int __TVOS_17_2 = (int)170200L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_2 170200
     * }
     */
    public static int __TVOS_17_2() {
        return __TVOS_17_2;
    }
    private static final int __TVOS_17_3 = (int)170300L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_3 170300
     * }
     */
    public static int __TVOS_17_3() {
        return __TVOS_17_3;
    }
    private static final int __TVOS_17_4 = (int)170400L;
    /**
     * {@snippet lang=c :
     * #define __TVOS_17_4 170400
     * }
     */
    public static int __TVOS_17_4() {
        return __TVOS_17_4;
    }
    private static final int __BRIDGEOS_2_0 = (int)20000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_2_0 20000
     * }
     */
    public static int __BRIDGEOS_2_0() {
        return __BRIDGEOS_2_0;
    }
    private static final int __BRIDGEOS_3_0 = (int)30000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_0 30000
     * }
     */
    public static int __BRIDGEOS_3_0() {
        return __BRIDGEOS_3_0;
    }
    private static final int __BRIDGEOS_3_1 = (int)30100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_1 30100
     * }
     */
    public static int __BRIDGEOS_3_1() {
        return __BRIDGEOS_3_1;
    }
    private static final int __BRIDGEOS_3_4 = (int)30400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_3_4 30400
     * }
     */
    public static int __BRIDGEOS_3_4() {
        return __BRIDGEOS_3_4;
    }
    private static final int __BRIDGEOS_4_0 = (int)40000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_4_0 40000
     * }
     */
    public static int __BRIDGEOS_4_0() {
        return __BRIDGEOS_4_0;
    }
    private static final int __BRIDGEOS_4_1 = (int)40100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_4_1 40100
     * }
     */
    public static int __BRIDGEOS_4_1() {
        return __BRIDGEOS_4_1;
    }
    private static final int __BRIDGEOS_5_0 = (int)50000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_0 50000
     * }
     */
    public static int __BRIDGEOS_5_0() {
        return __BRIDGEOS_5_0;
    }
    private static final int __BRIDGEOS_5_1 = (int)50100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_1 50100
     * }
     */
    public static int __BRIDGEOS_5_1() {
        return __BRIDGEOS_5_1;
    }
    private static final int __BRIDGEOS_5_3 = (int)50300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_5_3 50300
     * }
     */
    public static int __BRIDGEOS_5_3() {
        return __BRIDGEOS_5_3;
    }
    private static final int __BRIDGEOS_6_0 = (int)60000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_0 60000
     * }
     */
    public static int __BRIDGEOS_6_0() {
        return __BRIDGEOS_6_0;
    }
    private static final int __BRIDGEOS_6_2 = (int)60200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_2 60200
     * }
     */
    public static int __BRIDGEOS_6_2() {
        return __BRIDGEOS_6_2;
    }
    private static final int __BRIDGEOS_6_4 = (int)60400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_4 60400
     * }
     */
    public static int __BRIDGEOS_6_4() {
        return __BRIDGEOS_6_4;
    }
    private static final int __BRIDGEOS_6_5 = (int)60500L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_5 60500
     * }
     */
    public static int __BRIDGEOS_6_5() {
        return __BRIDGEOS_6_5;
    }
    private static final int __BRIDGEOS_6_6 = (int)60600L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_6_6 60600
     * }
     */
    public static int __BRIDGEOS_6_6() {
        return __BRIDGEOS_6_6;
    }
    private static final int __BRIDGEOS_7_0 = (int)70000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_0 70000
     * }
     */
    public static int __BRIDGEOS_7_0() {
        return __BRIDGEOS_7_0;
    }
    private static final int __BRIDGEOS_7_1 = (int)70100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_1 70100
     * }
     */
    public static int __BRIDGEOS_7_1() {
        return __BRIDGEOS_7_1;
    }
    private static final int __BRIDGEOS_7_2 = (int)70200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_2 70200
     * }
     */
    public static int __BRIDGEOS_7_2() {
        return __BRIDGEOS_7_2;
    }
    private static final int __BRIDGEOS_7_3 = (int)70300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_3 70300
     * }
     */
    public static int __BRIDGEOS_7_3() {
        return __BRIDGEOS_7_3;
    }
    private static final int __BRIDGEOS_7_4 = (int)70400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_4 70400
     * }
     */
    public static int __BRIDGEOS_7_4() {
        return __BRIDGEOS_7_4;
    }
    private static final int __BRIDGEOS_7_6 = (int)70600L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_7_6 70600
     * }
     */
    public static int __BRIDGEOS_7_6() {
        return __BRIDGEOS_7_6;
    }
    private static final int __BRIDGEOS_8_0 = (int)80000L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_0 80000
     * }
     */
    public static int __BRIDGEOS_8_0() {
        return __BRIDGEOS_8_0;
    }
    private static final int __BRIDGEOS_8_1 = (int)80100L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_1 80100
     * }
     */
    public static int __BRIDGEOS_8_1() {
        return __BRIDGEOS_8_1;
    }
    private static final int __BRIDGEOS_8_2 = (int)80200L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_2 80200
     * }
     */
    public static int __BRIDGEOS_8_2() {
        return __BRIDGEOS_8_2;
    }
    private static final int __BRIDGEOS_8_3 = (int)80300L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_3 80300
     * }
     */
    public static int __BRIDGEOS_8_3() {
        return __BRIDGEOS_8_3;
    }
    private static final int __BRIDGEOS_8_4 = (int)80400L;
    /**
     * {@snippet lang=c :
     * #define __BRIDGEOS_8_4 80400
     * }
     */
    public static int __BRIDGEOS_8_4() {
        return __BRIDGEOS_8_4;
    }
    private static final int __DRIVERKIT_19_0 = (int)190000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_19_0 190000
     * }
     */
    public static int __DRIVERKIT_19_0() {
        return __DRIVERKIT_19_0;
    }
    private static final int __DRIVERKIT_20_0 = (int)200000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_20_0 200000
     * }
     */
    public static int __DRIVERKIT_20_0() {
        return __DRIVERKIT_20_0;
    }
    private static final int __DRIVERKIT_21_0 = (int)210000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_21_0 210000
     * }
     */
    public static int __DRIVERKIT_21_0() {
        return __DRIVERKIT_21_0;
    }
    private static final int __DRIVERKIT_22_0 = (int)220000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_0 220000
     * }
     */
    public static int __DRIVERKIT_22_0() {
        return __DRIVERKIT_22_0;
    }
    private static final int __DRIVERKIT_22_4 = (int)220400L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_4 220400
     * }
     */
    public static int __DRIVERKIT_22_4() {
        return __DRIVERKIT_22_4;
    }
    private static final int __DRIVERKIT_22_5 = (int)220500L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_5 220500
     * }
     */
    public static int __DRIVERKIT_22_5() {
        return __DRIVERKIT_22_5;
    }
    private static final int __DRIVERKIT_22_6 = (int)220600L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_22_6 220600
     * }
     */
    public static int __DRIVERKIT_22_6() {
        return __DRIVERKIT_22_6;
    }
    private static final int __DRIVERKIT_23_0 = (int)230000L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_0 230000
     * }
     */
    public static int __DRIVERKIT_23_0() {
        return __DRIVERKIT_23_0;
    }
    private static final int __DRIVERKIT_23_1 = (int)230100L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_1 230100
     * }
     */
    public static int __DRIVERKIT_23_1() {
        return __DRIVERKIT_23_1;
    }
    private static final int __DRIVERKIT_23_2 = (int)230200L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_2 230200
     * }
     */
    public static int __DRIVERKIT_23_2() {
        return __DRIVERKIT_23_2;
    }
    private static final int __DRIVERKIT_23_3 = (int)230300L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_3 230300
     * }
     */
    public static int __DRIVERKIT_23_3() {
        return __DRIVERKIT_23_3;
    }
    private static final int __DRIVERKIT_23_4 = (int)230400L;
    /**
     * {@snippet lang=c :
     * #define __DRIVERKIT_23_4 230400
     * }
     */
    public static int __DRIVERKIT_23_4() {
        return __DRIVERKIT_23_4;
    }
    private static final int __VISIONOS_1_0 = (int)10000L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_1_0 10000
     * }
     */
    public static int __VISIONOS_1_0() {
        return __VISIONOS_1_0;
    }
    private static final int __VISIONOS_1_1 = (int)10100L;
    /**
     * {@snippet lang=c :
     * #define __VISIONOS_1_1 10100
     * }
     */
    public static int __VISIONOS_1_1() {
        return __VISIONOS_1_1;
    }
    private static final int __ENABLE_LEGACY_MAC_AVAILABILITY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ENABLE_LEGACY_MAC_AVAILABILITY 1
     * }
     */
    public static int __ENABLE_LEGACY_MAC_AVAILABILITY() {
        return __ENABLE_LEGACY_MAC_AVAILABILITY;
    }
    private static final int S_IFMT = (int)61440L;
    /**
     * {@snippet lang=c :
     * #define S_IFMT 61440
     * }
     */
    public static int S_IFMT() {
        return S_IFMT;
    }
    private static final int S_IFIFO = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define S_IFIFO 4096
     * }
     */
    public static int S_IFIFO() {
        return S_IFIFO;
    }
    private static final int S_IFCHR = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define S_IFCHR 8192
     * }
     */
    public static int S_IFCHR() {
        return S_IFCHR;
    }
    private static final int S_IFDIR = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define S_IFDIR 16384
     * }
     */
    public static int S_IFDIR() {
        return S_IFDIR;
    }
    private static final int S_IFBLK = (int)24576L;
    /**
     * {@snippet lang=c :
     * #define S_IFBLK 24576
     * }
     */
    public static int S_IFBLK() {
        return S_IFBLK;
    }
    private static final int S_IFREG = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define S_IFREG 32768
     * }
     */
    public static int S_IFREG() {
        return S_IFREG;
    }
    private static final int S_IFLNK = (int)40960L;
    /**
     * {@snippet lang=c :
     * #define S_IFLNK 40960
     * }
     */
    public static int S_IFLNK() {
        return S_IFLNK;
    }
    private static final int S_IFSOCK = (int)49152L;
    /**
     * {@snippet lang=c :
     * #define S_IFSOCK 49152
     * }
     */
    public static int S_IFSOCK() {
        return S_IFSOCK;
    }
    private static final int S_IFWHT = (int)57344L;
    /**
     * {@snippet lang=c :
     * #define S_IFWHT 57344
     * }
     */
    public static int S_IFWHT() {
        return S_IFWHT;
    }
    private static final int S_IRWXU = (int)448L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXU 448
     * }
     */
    public static int S_IRWXU() {
        return S_IRWXU;
    }
    private static final int S_IRUSR = (int)256L;
    /**
     * {@snippet lang=c :
     * #define S_IRUSR 256
     * }
     */
    public static int S_IRUSR() {
        return S_IRUSR;
    }
    private static final int S_IWUSR = (int)128L;
    /**
     * {@snippet lang=c :
     * #define S_IWUSR 128
     * }
     */
    public static int S_IWUSR() {
        return S_IWUSR;
    }
    private static final int S_IXUSR = (int)64L;
    /**
     * {@snippet lang=c :
     * #define S_IXUSR 64
     * }
     */
    public static int S_IXUSR() {
        return S_IXUSR;
    }
    private static final int S_IRWXG = (int)56L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXG 56
     * }
     */
    public static int S_IRWXG() {
        return S_IRWXG;
    }
    private static final int S_IRGRP = (int)32L;
    /**
     * {@snippet lang=c :
     * #define S_IRGRP 32
     * }
     */
    public static int S_IRGRP() {
        return S_IRGRP;
    }
    private static final int S_IWGRP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define S_IWGRP 16
     * }
     */
    public static int S_IWGRP() {
        return S_IWGRP;
    }
    private static final int S_IXGRP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define S_IXGRP 8
     * }
     */
    public static int S_IXGRP() {
        return S_IXGRP;
    }
    private static final int S_IRWXO = (int)7L;
    /**
     * {@snippet lang=c :
     * #define S_IRWXO 7
     * }
     */
    public static int S_IRWXO() {
        return S_IRWXO;
    }
    private static final int S_IROTH = (int)4L;
    /**
     * {@snippet lang=c :
     * #define S_IROTH 4
     * }
     */
    public static int S_IROTH() {
        return S_IROTH;
    }
    private static final int S_IWOTH = (int)2L;
    /**
     * {@snippet lang=c :
     * #define S_IWOTH 2
     * }
     */
    public static int S_IWOTH() {
        return S_IWOTH;
    }
    private static final int S_IXOTH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define S_IXOTH 1
     * }
     */
    public static int S_IXOTH() {
        return S_IXOTH;
    }
    private static final int S_ISUID = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define S_ISUID 2048
     * }
     */
    public static int S_ISUID() {
        return S_ISUID;
    }
    private static final int S_ISGID = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define S_ISGID 1024
     * }
     */
    public static int S_ISGID() {
        return S_ISGID;
    }
    private static final int S_ISVTX = (int)512L;
    /**
     * {@snippet lang=c :
     * #define S_ISVTX 512
     * }
     */
    public static int S_ISVTX() {
        return S_ISVTX;
    }
    private static final int S_BLKSIZE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define S_BLKSIZE 512
     * }
     */
    public static int S_BLKSIZE() {
        return S_BLKSIZE;
    }
    private static final int UF_SETTABLE = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UF_SETTABLE 65535
     * }
     */
    public static int UF_SETTABLE() {
        return UF_SETTABLE;
    }
    private static final int UF_NODUMP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define UF_NODUMP 1
     * }
     */
    public static int UF_NODUMP() {
        return UF_NODUMP;
    }
    private static final int UF_IMMUTABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define UF_IMMUTABLE 2
     * }
     */
    public static int UF_IMMUTABLE() {
        return UF_IMMUTABLE;
    }
    private static final int UF_APPEND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define UF_APPEND 4
     * }
     */
    public static int UF_APPEND() {
        return UF_APPEND;
    }
    private static final int UF_OPAQUE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define UF_OPAQUE 8
     * }
     */
    public static int UF_OPAQUE() {
        return UF_OPAQUE;
    }
    private static final int UF_COMPRESSED = (int)32L;
    /**
     * {@snippet lang=c :
     * #define UF_COMPRESSED 32
     * }
     */
    public static int UF_COMPRESSED() {
        return UF_COMPRESSED;
    }
    private static final int UF_TRACKED = (int)64L;
    /**
     * {@snippet lang=c :
     * #define UF_TRACKED 64
     * }
     */
    public static int UF_TRACKED() {
        return UF_TRACKED;
    }
    private static final int UF_DATAVAULT = (int)128L;
    /**
     * {@snippet lang=c :
     * #define UF_DATAVAULT 128
     * }
     */
    public static int UF_DATAVAULT() {
        return UF_DATAVAULT;
    }
    private static final int UF_HIDDEN = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define UF_HIDDEN 32768
     * }
     */
    public static int UF_HIDDEN() {
        return UF_HIDDEN;
    }
    private static final int SF_SUPPORTED = (int)10420224L;
    /**
     * {@snippet lang=c :
     * #define SF_SUPPORTED 10420224
     * }
     */
    public static int SF_SUPPORTED() {
        return SF_SUPPORTED;
    }
    private static final int SF_SETTABLE = (int)1073676288L;
    /**
     * {@snippet lang=c :
     * #define SF_SETTABLE 1073676288
     * }
     */
    public static int SF_SETTABLE() {
        return SF_SETTABLE;
    }
    private static final int SF_ARCHIVED = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define SF_ARCHIVED 65536
     * }
     */
    public static int SF_ARCHIVED() {
        return SF_ARCHIVED;
    }
    private static final int SF_IMMUTABLE = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define SF_IMMUTABLE 131072
     * }
     */
    public static int SF_IMMUTABLE() {
        return SF_IMMUTABLE;
    }
    private static final int SF_APPEND = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define SF_APPEND 262144
     * }
     */
    public static int SF_APPEND() {
        return SF_APPEND;
    }
    private static final int SF_RESTRICTED = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define SF_RESTRICTED 524288
     * }
     */
    public static int SF_RESTRICTED() {
        return SF_RESTRICTED;
    }
    private static final int SF_NOUNLINK = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define SF_NOUNLINK 1048576
     * }
     */
    public static int SF_NOUNLINK() {
        return SF_NOUNLINK;
    }
    private static final int SF_FIRMLINK = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define SF_FIRMLINK 8388608
     * }
     */
    public static int SF_FIRMLINK() {
        return SF_FIRMLINK;
    }
    private static final int SF_DATALESS = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define SF_DATALESS 1073741824
     * }
     */
    public static int SF_DATALESS() {
        return SF_DATALESS;
    }
    private static final int EF_MAY_SHARE_BLOCKS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EF_MAY_SHARE_BLOCKS 1
     * }
     */
    public static int EF_MAY_SHARE_BLOCKS() {
        return EF_MAY_SHARE_BLOCKS;
    }
    private static final int EF_NO_XATTRS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EF_NO_XATTRS 2
     * }
     */
    public static int EF_NO_XATTRS() {
        return EF_NO_XATTRS;
    }
    private static final int EF_IS_SYNC_ROOT = (int)4L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_SYNC_ROOT 4
     * }
     */
    public static int EF_IS_SYNC_ROOT() {
        return EF_IS_SYNC_ROOT;
    }
    private static final int EF_IS_PURGEABLE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_PURGEABLE 8
     * }
     */
    public static int EF_IS_PURGEABLE() {
        return EF_IS_PURGEABLE;
    }
    private static final int EF_IS_SPARSE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_SPARSE 16
     * }
     */
    public static int EF_IS_SPARSE() {
        return EF_IS_SPARSE;
    }
    private static final int EF_IS_SYNTHETIC = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EF_IS_SYNTHETIC 32
     * }
     */
    public static int EF_IS_SYNTHETIC() {
        return EF_IS_SYNTHETIC;
    }
    private static final int EF_SHARES_ALL_BLOCKS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define EF_SHARES_ALL_BLOCKS 64
     * }
     */
    public static int EF_SHARES_ALL_BLOCKS() {
        return EF_SHARES_ALL_BLOCKS;
    }
    private static final int _FORTIFY_SOURCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _FORTIFY_SOURCE 2
     * }
     */
    public static int _FORTIFY_SOURCE() {
        return _FORTIFY_SOURCE;
    }
    private static final int RENAME_SECLUDE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define RENAME_SECLUDE 1
     * }
     */
    public static int RENAME_SECLUDE() {
        return RENAME_SECLUDE;
    }
    private static final int RENAME_SWAP = (int)2L;
    /**
     * {@snippet lang=c :
     * #define RENAME_SWAP 2
     * }
     */
    public static int RENAME_SWAP() {
        return RENAME_SWAP;
    }
    private static final int RENAME_EXCL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define RENAME_EXCL 4
     * }
     */
    public static int RENAME_EXCL() {
        return RENAME_EXCL;
    }
    private static final int RENAME_RESERVED1 = (int)8L;
    /**
     * {@snippet lang=c :
     * #define RENAME_RESERVED1 8
     * }
     */
    public static int RENAME_RESERVED1() {
        return RENAME_RESERVED1;
    }
    private static final int RENAME_NOFOLLOW_ANY = (int)16L;
    /**
     * {@snippet lang=c :
     * #define RENAME_NOFOLLOW_ANY 16
     * }
     */
    public static int RENAME_NOFOLLOW_ANY() {
        return RENAME_NOFOLLOW_ANY;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int SEEK_HOLE = (int)3L;
    /**
     * {@snippet lang=c :
     * #define SEEK_HOLE 3
     * }
     */
    public static int SEEK_HOLE() {
        return SEEK_HOLE;
    }
    private static final int SEEK_DATA = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SEEK_DATA 4
     * }
     */
    public static int SEEK_DATA() {
        return SEEK_DATA;
    }
    private static final int __SLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __SLBF 1
     * }
     */
    public static int __SLBF() {
        return __SLBF;
    }
    private static final int __SNBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __SNBF 2
     * }
     */
    public static int __SNBF() {
        return __SNBF;
    }
    private static final int __SRD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SRD 4
     * }
     */
    public static int __SRD() {
        return __SRD;
    }
    private static final int __SWR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SWR 8
     * }
     */
    public static int __SWR() {
        return __SWR;
    }
    private static final int __SRW = (int)16L;
    /**
     * {@snippet lang=c :
     * #define __SRW 16
     * }
     */
    public static int __SRW() {
        return __SRW;
    }
    private static final int __SEOF = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SEOF 32
     * }
     */
    public static int __SEOF() {
        return __SEOF;
    }
    private static final int __SERR = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SERR 64
     * }
     */
    public static int __SERR() {
        return __SERR;
    }
    private static final int __SMBF = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __SMBF 128
     * }
     */
    public static int __SMBF() {
        return __SMBF;
    }
    private static final int __SAPP = (int)256L;
    /**
     * {@snippet lang=c :
     * #define __SAPP 256
     * }
     */
    public static int __SAPP() {
        return __SAPP;
    }
    private static final int __SSTR = (int)512L;
    /**
     * {@snippet lang=c :
     * #define __SSTR 512
     * }
     */
    public static int __SSTR() {
        return __SSTR;
    }
    private static final int __SOPT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __SOPT 1024
     * }
     */
    public static int __SOPT() {
        return __SOPT;
    }
    private static final int __SNPT = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define __SNPT 2048
     * }
     */
    public static int __SNPT() {
        return __SNPT;
    }
    private static final int __SOFF = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define __SOFF 4096
     * }
     */
    public static int __SOFF() {
        return __SOFF;
    }
    private static final int __SMOD = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define __SMOD 8192
     * }
     */
    public static int __SMOD() {
        return __SMOD;
    }
    private static final int __SALC = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define __SALC 16384
     * }
     */
    public static int __SALC() {
        return __SALC;
    }
    private static final int __SIGN = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define __SIGN 32768
     * }
     */
    public static int __SIGN() {
        return __SIGN;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 1024
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int FOPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 20
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int FILENAME_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 1024
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_tmpnam = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 1024
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)308915776L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 308915776
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int L_ctermid = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 1024
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int _USE_FORTIFY_LEVEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _USE_FORTIFY_LEVEL 2
     * }
     */
    public static int _USE_FORTIFY_LEVEL() {
        return _USE_FORTIFY_LEVEL;
    }
    private static final int TIME_UTC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TIME_UTC 1
     * }
     */
    public static int TIME_UTC() {
        return TIME_UTC;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int INT8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static int INT8_MAX() {
        return INT8_MAX;
    }
    private static final int INT16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static int INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final int UINT8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static int UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final int UINT16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static int UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int _POSIX_THREAD_KEYS_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_KEYS_MAX 128
     * }
     */
    public static int _POSIX_THREAD_KEYS_MAX() {
        return _POSIX_THREAD_KEYS_MAX;
    }
    private static final int F_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define F_OK 0
     * }
     */
    public static int F_OK() {
        return F_OK;
    }
    private static final int ACCESSX_MAX_DESCRIPTORS = (int)100L;
    /**
     * {@snippet lang=c :
     * #define ACCESSX_MAX_DESCRIPTORS 100
     * }
     */
    public static int ACCESSX_MAX_DESCRIPTORS() {
        return ACCESSX_MAX_DESCRIPTORS;
    }
    private static final int _PC_LINK_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _PC_LINK_MAX 1
     * }
     */
    public static int _PC_LINK_MAX() {
        return _PC_LINK_MAX;
    }
    private static final int _PC_MAX_CANON = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _PC_MAX_CANON 2
     * }
     */
    public static int _PC_MAX_CANON() {
        return _PC_MAX_CANON;
    }
    private static final int _PC_MAX_INPUT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _PC_MAX_INPUT 3
     * }
     */
    public static int _PC_MAX_INPUT() {
        return _PC_MAX_INPUT;
    }
    private static final int _PC_NAME_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _PC_NAME_MAX 4
     * }
     */
    public static int _PC_NAME_MAX() {
        return _PC_NAME_MAX;
    }
    private static final int _PC_PATH_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _PC_PATH_MAX 5
     * }
     */
    public static int _PC_PATH_MAX() {
        return _PC_PATH_MAX;
    }
    private static final int _PC_PIPE_BUF = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _PC_PIPE_BUF 6
     * }
     */
    public static int _PC_PIPE_BUF() {
        return _PC_PIPE_BUF;
    }
    private static final int _PC_CHOWN_RESTRICTED = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _PC_CHOWN_RESTRICTED 7
     * }
     */
    public static int _PC_CHOWN_RESTRICTED() {
        return _PC_CHOWN_RESTRICTED;
    }
    private static final int _PC_NO_TRUNC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _PC_NO_TRUNC 8
     * }
     */
    public static int _PC_NO_TRUNC() {
        return _PC_NO_TRUNC;
    }
    private static final int _PC_VDISABLE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _PC_VDISABLE 9
     * }
     */
    public static int _PC_VDISABLE() {
        return _PC_VDISABLE;
    }
    private static final int _PC_NAME_CHARS_MAX = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _PC_NAME_CHARS_MAX 10
     * }
     */
    public static int _PC_NAME_CHARS_MAX() {
        return _PC_NAME_CHARS_MAX;
    }
    private static final int _PC_CASE_SENSITIVE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _PC_CASE_SENSITIVE 11
     * }
     */
    public static int _PC_CASE_SENSITIVE() {
        return _PC_CASE_SENSITIVE;
    }
    private static final int _PC_CASE_PRESERVING = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _PC_CASE_PRESERVING 12
     * }
     */
    public static int _PC_CASE_PRESERVING() {
        return _PC_CASE_PRESERVING;
    }
    private static final int _PC_EXTENDED_SECURITY_NP = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _PC_EXTENDED_SECURITY_NP 13
     * }
     */
    public static int _PC_EXTENDED_SECURITY_NP() {
        return _PC_EXTENDED_SECURITY_NP;
    }
    private static final int _PC_AUTH_OPAQUE_NP = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _PC_AUTH_OPAQUE_NP 14
     * }
     */
    public static int _PC_AUTH_OPAQUE_NP() {
        return _PC_AUTH_OPAQUE_NP;
    }
    private static final int _PC_2_SYMLINKS = (int)15L;
    /**
     * {@snippet lang=c :
     * #define _PC_2_SYMLINKS 15
     * }
     */
    public static int _PC_2_SYMLINKS() {
        return _PC_2_SYMLINKS;
    }
    private static final int _PC_ALLOC_SIZE_MIN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _PC_ALLOC_SIZE_MIN 16
     * }
     */
    public static int _PC_ALLOC_SIZE_MIN() {
        return _PC_ALLOC_SIZE_MIN;
    }
    private static final int _PC_ASYNC_IO = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _PC_ASYNC_IO 17
     * }
     */
    public static int _PC_ASYNC_IO() {
        return _PC_ASYNC_IO;
    }
    private static final int _PC_FILESIZEBITS = (int)18L;
    /**
     * {@snippet lang=c :
     * #define _PC_FILESIZEBITS 18
     * }
     */
    public static int _PC_FILESIZEBITS() {
        return _PC_FILESIZEBITS;
    }
    private static final int _PC_PRIO_IO = (int)19L;
    /**
     * {@snippet lang=c :
     * #define _PC_PRIO_IO 19
     * }
     */
    public static int _PC_PRIO_IO() {
        return _PC_PRIO_IO;
    }
    private static final int _PC_REC_INCR_XFER_SIZE = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_INCR_XFER_SIZE 20
     * }
     */
    public static int _PC_REC_INCR_XFER_SIZE() {
        return _PC_REC_INCR_XFER_SIZE;
    }
    private static final int _PC_REC_MAX_XFER_SIZE = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_MAX_XFER_SIZE 21
     * }
     */
    public static int _PC_REC_MAX_XFER_SIZE() {
        return _PC_REC_MAX_XFER_SIZE;
    }
    private static final int _PC_REC_MIN_XFER_SIZE = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_MIN_XFER_SIZE 22
     * }
     */
    public static int _PC_REC_MIN_XFER_SIZE() {
        return _PC_REC_MIN_XFER_SIZE;
    }
    private static final int _PC_REC_XFER_ALIGN = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _PC_REC_XFER_ALIGN 23
     * }
     */
    public static int _PC_REC_XFER_ALIGN() {
        return _PC_REC_XFER_ALIGN;
    }
    private static final int _PC_SYMLINK_MAX = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _PC_SYMLINK_MAX 24
     * }
     */
    public static int _PC_SYMLINK_MAX() {
        return _PC_SYMLINK_MAX;
    }
    private static final int _PC_SYNC_IO = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _PC_SYNC_IO 25
     * }
     */
    public static int _PC_SYNC_IO() {
        return _PC_SYNC_IO;
    }
    private static final int _PC_XATTR_SIZE_BITS = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _PC_XATTR_SIZE_BITS 26
     * }
     */
    public static int _PC_XATTR_SIZE_BITS() {
        return _PC_XATTR_SIZE_BITS;
    }
    private static final int _PC_MIN_HOLE_SIZE = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _PC_MIN_HOLE_SIZE 27
     * }
     */
    public static int _PC_MIN_HOLE_SIZE() {
        return _PC_MIN_HOLE_SIZE;
    }
    private static final int _CS_PATH = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _CS_PATH 1
     * }
     */
    public static int _CS_PATH() {
        return _CS_PATH;
    }
    private static final int STDIN_FILENO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define STDIN_FILENO 0
     * }
     */
    public static int STDIN_FILENO() {
        return STDIN_FILENO;
    }
    private static final int STDOUT_FILENO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define STDOUT_FILENO 1
     * }
     */
    public static int STDOUT_FILENO() {
        return STDOUT_FILENO;
    }
    private static final int STDERR_FILENO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define STDERR_FILENO 2
     * }
     */
    public static int STDERR_FILENO() {
        return STDERR_FILENO;
    }
    private static final int _XOPEN_VERSION = (int)600L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_VERSION 600
     * }
     */
    public static int _XOPEN_VERSION() {
        return _XOPEN_VERSION;
    }
    private static final int _XOPEN_XCU_VERSION = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _XOPEN_XCU_VERSION 4
     * }
     */
    public static int _XOPEN_XCU_VERSION() {
        return _XOPEN_XCU_VERSION;
    }
    private static final int _SC_ARG_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SC_ARG_MAX 1
     * }
     */
    public static int _SC_ARG_MAX() {
        return _SC_ARG_MAX;
    }
    private static final int _SC_CHILD_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _SC_CHILD_MAX 2
     * }
     */
    public static int _SC_CHILD_MAX() {
        return _SC_CHILD_MAX;
    }
    private static final int _SC_CLK_TCK = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _SC_CLK_TCK 3
     * }
     */
    public static int _SC_CLK_TCK() {
        return _SC_CLK_TCK;
    }
    private static final int _SC_NGROUPS_MAX = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _SC_NGROUPS_MAX 4
     * }
     */
    public static int _SC_NGROUPS_MAX() {
        return _SC_NGROUPS_MAX;
    }
    private static final int _SC_OPEN_MAX = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _SC_OPEN_MAX 5
     * }
     */
    public static int _SC_OPEN_MAX() {
        return _SC_OPEN_MAX;
    }
    private static final int _SC_JOB_CONTROL = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _SC_JOB_CONTROL 6
     * }
     */
    public static int _SC_JOB_CONTROL() {
        return _SC_JOB_CONTROL;
    }
    private static final int _SC_SAVED_IDS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _SC_SAVED_IDS 7
     * }
     */
    public static int _SC_SAVED_IDS() {
        return _SC_SAVED_IDS;
    }
    private static final int _SC_VERSION = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _SC_VERSION 8
     * }
     */
    public static int _SC_VERSION() {
        return _SC_VERSION;
    }
    private static final int _SC_BC_BASE_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_BASE_MAX 9
     * }
     */
    public static int _SC_BC_BASE_MAX() {
        return _SC_BC_BASE_MAX;
    }
    private static final int _SC_BC_DIM_MAX = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_DIM_MAX 10
     * }
     */
    public static int _SC_BC_DIM_MAX() {
        return _SC_BC_DIM_MAX;
    }
    private static final int _SC_BC_SCALE_MAX = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_SCALE_MAX 11
     * }
     */
    public static int _SC_BC_SCALE_MAX() {
        return _SC_BC_SCALE_MAX;
    }
    private static final int _SC_BC_STRING_MAX = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _SC_BC_STRING_MAX 12
     * }
     */
    public static int _SC_BC_STRING_MAX() {
        return _SC_BC_STRING_MAX;
    }
    private static final int _SC_COLL_WEIGHTS_MAX = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _SC_COLL_WEIGHTS_MAX 13
     * }
     */
    public static int _SC_COLL_WEIGHTS_MAX() {
        return _SC_COLL_WEIGHTS_MAX;
    }
    private static final int _SC_EXPR_NEST_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _SC_EXPR_NEST_MAX 14
     * }
     */
    public static int _SC_EXPR_NEST_MAX() {
        return _SC_EXPR_NEST_MAX;
    }
    private static final int _SC_LINE_MAX = (int)15L;
    /**
     * {@snippet lang=c :
     * #define _SC_LINE_MAX 15
     * }
     */
    public static int _SC_LINE_MAX() {
        return _SC_LINE_MAX;
    }
    private static final int _SC_RE_DUP_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _SC_RE_DUP_MAX 16
     * }
     */
    public static int _SC_RE_DUP_MAX() {
        return _SC_RE_DUP_MAX;
    }
    private static final int _SC_2_VERSION = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_VERSION 17
     * }
     */
    public static int _SC_2_VERSION() {
        return _SC_2_VERSION;
    }
    private static final int _SC_2_C_BIND = (int)18L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_C_BIND 18
     * }
     */
    public static int _SC_2_C_BIND() {
        return _SC_2_C_BIND;
    }
    private static final int _SC_2_C_DEV = (int)19L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_C_DEV 19
     * }
     */
    public static int _SC_2_C_DEV() {
        return _SC_2_C_DEV;
    }
    private static final int _SC_2_CHAR_TERM = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_CHAR_TERM 20
     * }
     */
    public static int _SC_2_CHAR_TERM() {
        return _SC_2_CHAR_TERM;
    }
    private static final int _SC_2_FORT_DEV = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_FORT_DEV 21
     * }
     */
    public static int _SC_2_FORT_DEV() {
        return _SC_2_FORT_DEV;
    }
    private static final int _SC_2_FORT_RUN = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_FORT_RUN 22
     * }
     */
    public static int _SC_2_FORT_RUN() {
        return _SC_2_FORT_RUN;
    }
    private static final int _SC_2_LOCALEDEF = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_LOCALEDEF 23
     * }
     */
    public static int _SC_2_LOCALEDEF() {
        return _SC_2_LOCALEDEF;
    }
    private static final int _SC_2_SW_DEV = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_SW_DEV 24
     * }
     */
    public static int _SC_2_SW_DEV() {
        return _SC_2_SW_DEV;
    }
    private static final int _SC_2_UPE = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_UPE 25
     * }
     */
    public static int _SC_2_UPE() {
        return _SC_2_UPE;
    }
    private static final int _SC_STREAM_MAX = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _SC_STREAM_MAX 26
     * }
     */
    public static int _SC_STREAM_MAX() {
        return _SC_STREAM_MAX;
    }
    private static final int _SC_TZNAME_MAX = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _SC_TZNAME_MAX 27
     * }
     */
    public static int _SC_TZNAME_MAX() {
        return _SC_TZNAME_MAX;
    }
    private static final int _SC_ASYNCHRONOUS_IO = (int)28L;
    /**
     * {@snippet lang=c :
     * #define _SC_ASYNCHRONOUS_IO 28
     * }
     */
    public static int _SC_ASYNCHRONOUS_IO() {
        return _SC_ASYNCHRONOUS_IO;
    }
    private static final int _SC_PAGESIZE = (int)29L;
    /**
     * {@snippet lang=c :
     * #define _SC_PAGESIZE 29
     * }
     */
    public static int _SC_PAGESIZE() {
        return _SC_PAGESIZE;
    }
    private static final int _SC_MEMLOCK = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMLOCK 30
     * }
     */
    public static int _SC_MEMLOCK() {
        return _SC_MEMLOCK;
    }
    private static final int _SC_MEMLOCK_RANGE = (int)31L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMLOCK_RANGE 31
     * }
     */
    public static int _SC_MEMLOCK_RANGE() {
        return _SC_MEMLOCK_RANGE;
    }
    private static final int _SC_MEMORY_PROTECTION = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _SC_MEMORY_PROTECTION 32
     * }
     */
    public static int _SC_MEMORY_PROTECTION() {
        return _SC_MEMORY_PROTECTION;
    }
    private static final int _SC_MESSAGE_PASSING = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _SC_MESSAGE_PASSING 33
     * }
     */
    public static int _SC_MESSAGE_PASSING() {
        return _SC_MESSAGE_PASSING;
    }
    private static final int _SC_PRIORITIZED_IO = (int)34L;
    /**
     * {@snippet lang=c :
     * #define _SC_PRIORITIZED_IO 34
     * }
     */
    public static int _SC_PRIORITIZED_IO() {
        return _SC_PRIORITIZED_IO;
    }
    private static final int _SC_PRIORITY_SCHEDULING = (int)35L;
    /**
     * {@snippet lang=c :
     * #define _SC_PRIORITY_SCHEDULING 35
     * }
     */
    public static int _SC_PRIORITY_SCHEDULING() {
        return _SC_PRIORITY_SCHEDULING;
    }
    private static final int _SC_REALTIME_SIGNALS = (int)36L;
    /**
     * {@snippet lang=c :
     * #define _SC_REALTIME_SIGNALS 36
     * }
     */
    public static int _SC_REALTIME_SIGNALS() {
        return _SC_REALTIME_SIGNALS;
    }
    private static final int _SC_SEMAPHORES = (int)37L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEMAPHORES 37
     * }
     */
    public static int _SC_SEMAPHORES() {
        return _SC_SEMAPHORES;
    }
    private static final int _SC_FSYNC = (int)38L;
    /**
     * {@snippet lang=c :
     * #define _SC_FSYNC 38
     * }
     */
    public static int _SC_FSYNC() {
        return _SC_FSYNC;
    }
    private static final int _SC_SHARED_MEMORY_OBJECTS = (int)39L;
    /**
     * {@snippet lang=c :
     * #define _SC_SHARED_MEMORY_OBJECTS 39
     * }
     */
    public static int _SC_SHARED_MEMORY_OBJECTS() {
        return _SC_SHARED_MEMORY_OBJECTS;
    }
    private static final int _SC_SYNCHRONIZED_IO = (int)40L;
    /**
     * {@snippet lang=c :
     * #define _SC_SYNCHRONIZED_IO 40
     * }
     */
    public static int _SC_SYNCHRONIZED_IO() {
        return _SC_SYNCHRONIZED_IO;
    }
    private static final int _SC_TIMERS = (int)41L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMERS 41
     * }
     */
    public static int _SC_TIMERS() {
        return _SC_TIMERS;
    }
    private static final int _SC_AIO_LISTIO_MAX = (int)42L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_LISTIO_MAX 42
     * }
     */
    public static int _SC_AIO_LISTIO_MAX() {
        return _SC_AIO_LISTIO_MAX;
    }
    private static final int _SC_AIO_MAX = (int)43L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_MAX 43
     * }
     */
    public static int _SC_AIO_MAX() {
        return _SC_AIO_MAX;
    }
    private static final int _SC_AIO_PRIO_DELTA_MAX = (int)44L;
    /**
     * {@snippet lang=c :
     * #define _SC_AIO_PRIO_DELTA_MAX 44
     * }
     */
    public static int _SC_AIO_PRIO_DELTA_MAX() {
        return _SC_AIO_PRIO_DELTA_MAX;
    }
    private static final int _SC_DELAYTIMER_MAX = (int)45L;
    /**
     * {@snippet lang=c :
     * #define _SC_DELAYTIMER_MAX 45
     * }
     */
    public static int _SC_DELAYTIMER_MAX() {
        return _SC_DELAYTIMER_MAX;
    }
    private static final int _SC_MQ_OPEN_MAX = (int)46L;
    /**
     * {@snippet lang=c :
     * #define _SC_MQ_OPEN_MAX 46
     * }
     */
    public static int _SC_MQ_OPEN_MAX() {
        return _SC_MQ_OPEN_MAX;
    }
    private static final int _SC_MAPPED_FILES = (int)47L;
    /**
     * {@snippet lang=c :
     * #define _SC_MAPPED_FILES 47
     * }
     */
    public static int _SC_MAPPED_FILES() {
        return _SC_MAPPED_FILES;
    }
    private static final int _SC_RTSIG_MAX = (int)48L;
    /**
     * {@snippet lang=c :
     * #define _SC_RTSIG_MAX 48
     * }
     */
    public static int _SC_RTSIG_MAX() {
        return _SC_RTSIG_MAX;
    }
    private static final int _SC_SEM_NSEMS_MAX = (int)49L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEM_NSEMS_MAX 49
     * }
     */
    public static int _SC_SEM_NSEMS_MAX() {
        return _SC_SEM_NSEMS_MAX;
    }
    private static final int _SC_SEM_VALUE_MAX = (int)50L;
    /**
     * {@snippet lang=c :
     * #define _SC_SEM_VALUE_MAX 50
     * }
     */
    public static int _SC_SEM_VALUE_MAX() {
        return _SC_SEM_VALUE_MAX;
    }
    private static final int _SC_SIGQUEUE_MAX = (int)51L;
    /**
     * {@snippet lang=c :
     * #define _SC_SIGQUEUE_MAX 51
     * }
     */
    public static int _SC_SIGQUEUE_MAX() {
        return _SC_SIGQUEUE_MAX;
    }
    private static final int _SC_TIMER_MAX = (int)52L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMER_MAX 52
     * }
     */
    public static int _SC_TIMER_MAX() {
        return _SC_TIMER_MAX;
    }
    private static final int _SC_NPROCESSORS_CONF = (int)57L;
    /**
     * {@snippet lang=c :
     * #define _SC_NPROCESSORS_CONF 57
     * }
     */
    public static int _SC_NPROCESSORS_CONF() {
        return _SC_NPROCESSORS_CONF;
    }
    private static final int _SC_NPROCESSORS_ONLN = (int)58L;
    /**
     * {@snippet lang=c :
     * #define _SC_NPROCESSORS_ONLN 58
     * }
     */
    public static int _SC_NPROCESSORS_ONLN() {
        return _SC_NPROCESSORS_ONLN;
    }
    private static final int _SC_2_PBS = (int)59L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS 59
     * }
     */
    public static int _SC_2_PBS() {
        return _SC_2_PBS;
    }
    private static final int _SC_2_PBS_ACCOUNTING = (int)60L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_ACCOUNTING 60
     * }
     */
    public static int _SC_2_PBS_ACCOUNTING() {
        return _SC_2_PBS_ACCOUNTING;
    }
    private static final int _SC_2_PBS_CHECKPOINT = (int)61L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_CHECKPOINT 61
     * }
     */
    public static int _SC_2_PBS_CHECKPOINT() {
        return _SC_2_PBS_CHECKPOINT;
    }
    private static final int _SC_2_PBS_LOCATE = (int)62L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_LOCATE 62
     * }
     */
    public static int _SC_2_PBS_LOCATE() {
        return _SC_2_PBS_LOCATE;
    }
    private static final int _SC_2_PBS_MESSAGE = (int)63L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_MESSAGE 63
     * }
     */
    public static int _SC_2_PBS_MESSAGE() {
        return _SC_2_PBS_MESSAGE;
    }
    private static final int _SC_2_PBS_TRACK = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _SC_2_PBS_TRACK 64
     * }
     */
    public static int _SC_2_PBS_TRACK() {
        return _SC_2_PBS_TRACK;
    }
    private static final int _SC_ADVISORY_INFO = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _SC_ADVISORY_INFO 65
     * }
     */
    public static int _SC_ADVISORY_INFO() {
        return _SC_ADVISORY_INFO;
    }
    private static final int _SC_BARRIERS = (int)66L;
    /**
     * {@snippet lang=c :
     * #define _SC_BARRIERS 66
     * }
     */
    public static int _SC_BARRIERS() {
        return _SC_BARRIERS;
    }
    private static final int _SC_CLOCK_SELECTION = (int)67L;
    /**
     * {@snippet lang=c :
     * #define _SC_CLOCK_SELECTION 67
     * }
     */
    public static int _SC_CLOCK_SELECTION() {
        return _SC_CLOCK_SELECTION;
    }
    private static final int _SC_CPUTIME = (int)68L;
    /**
     * {@snippet lang=c :
     * #define _SC_CPUTIME 68
     * }
     */
    public static int _SC_CPUTIME() {
        return _SC_CPUTIME;
    }
    private static final int _SC_FILE_LOCKING = (int)69L;
    /**
     * {@snippet lang=c :
     * #define _SC_FILE_LOCKING 69
     * }
     */
    public static int _SC_FILE_LOCKING() {
        return _SC_FILE_LOCKING;
    }
    private static final int _SC_GETGR_R_SIZE_MAX = (int)70L;
    /**
     * {@snippet lang=c :
     * #define _SC_GETGR_R_SIZE_MAX 70
     * }
     */
    public static int _SC_GETGR_R_SIZE_MAX() {
        return _SC_GETGR_R_SIZE_MAX;
    }
    private static final int _SC_GETPW_R_SIZE_MAX = (int)71L;
    /**
     * {@snippet lang=c :
     * #define _SC_GETPW_R_SIZE_MAX 71
     * }
     */
    public static int _SC_GETPW_R_SIZE_MAX() {
        return _SC_GETPW_R_SIZE_MAX;
    }
    private static final int _SC_HOST_NAME_MAX = (int)72L;
    /**
     * {@snippet lang=c :
     * #define _SC_HOST_NAME_MAX 72
     * }
     */
    public static int _SC_HOST_NAME_MAX() {
        return _SC_HOST_NAME_MAX;
    }
    private static final int _SC_LOGIN_NAME_MAX = (int)73L;
    /**
     * {@snippet lang=c :
     * #define _SC_LOGIN_NAME_MAX 73
     * }
     */
    public static int _SC_LOGIN_NAME_MAX() {
        return _SC_LOGIN_NAME_MAX;
    }
    private static final int _SC_MONOTONIC_CLOCK = (int)74L;
    /**
     * {@snippet lang=c :
     * #define _SC_MONOTONIC_CLOCK 74
     * }
     */
    public static int _SC_MONOTONIC_CLOCK() {
        return _SC_MONOTONIC_CLOCK;
    }
    private static final int _SC_MQ_PRIO_MAX = (int)75L;
    /**
     * {@snippet lang=c :
     * #define _SC_MQ_PRIO_MAX 75
     * }
     */
    public static int _SC_MQ_PRIO_MAX() {
        return _SC_MQ_PRIO_MAX;
    }
    private static final int _SC_READER_WRITER_LOCKS = (int)76L;
    /**
     * {@snippet lang=c :
     * #define _SC_READER_WRITER_LOCKS 76
     * }
     */
    public static int _SC_READER_WRITER_LOCKS() {
        return _SC_READER_WRITER_LOCKS;
    }
    private static final int _SC_REGEXP = (int)77L;
    /**
     * {@snippet lang=c :
     * #define _SC_REGEXP 77
     * }
     */
    public static int _SC_REGEXP() {
        return _SC_REGEXP;
    }
    private static final int _SC_SHELL = (int)78L;
    /**
     * {@snippet lang=c :
     * #define _SC_SHELL 78
     * }
     */
    public static int _SC_SHELL() {
        return _SC_SHELL;
    }
    private static final int _SC_SPAWN = (int)79L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPAWN 79
     * }
     */
    public static int _SC_SPAWN() {
        return _SC_SPAWN;
    }
    private static final int _SC_SPIN_LOCKS = (int)80L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPIN_LOCKS 80
     * }
     */
    public static int _SC_SPIN_LOCKS() {
        return _SC_SPIN_LOCKS;
    }
    private static final int _SC_SPORADIC_SERVER = (int)81L;
    /**
     * {@snippet lang=c :
     * #define _SC_SPORADIC_SERVER 81
     * }
     */
    public static int _SC_SPORADIC_SERVER() {
        return _SC_SPORADIC_SERVER;
    }
    private static final int _SC_THREAD_ATTR_STACKADDR = (int)82L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_ATTR_STACKADDR 82
     * }
     */
    public static int _SC_THREAD_ATTR_STACKADDR() {
        return _SC_THREAD_ATTR_STACKADDR;
    }
    private static final int _SC_THREAD_ATTR_STACKSIZE = (int)83L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_ATTR_STACKSIZE 83
     * }
     */
    public static int _SC_THREAD_ATTR_STACKSIZE() {
        return _SC_THREAD_ATTR_STACKSIZE;
    }
    private static final int _SC_THREAD_CPUTIME = (int)84L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_CPUTIME 84
     * }
     */
    public static int _SC_THREAD_CPUTIME() {
        return _SC_THREAD_CPUTIME;
    }
    private static final int _SC_THREAD_DESTRUCTOR_ITERATIONS = (int)85L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_DESTRUCTOR_ITERATIONS 85
     * }
     */
    public static int _SC_THREAD_DESTRUCTOR_ITERATIONS() {
        return _SC_THREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int _SC_THREAD_KEYS_MAX = (int)86L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_KEYS_MAX 86
     * }
     */
    public static int _SC_THREAD_KEYS_MAX() {
        return _SC_THREAD_KEYS_MAX;
    }
    private static final int _SC_THREAD_PRIO_INHERIT = (int)87L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIO_INHERIT 87
     * }
     */
    public static int _SC_THREAD_PRIO_INHERIT() {
        return _SC_THREAD_PRIO_INHERIT;
    }
    private static final int _SC_THREAD_PRIO_PROTECT = (int)88L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIO_PROTECT 88
     * }
     */
    public static int _SC_THREAD_PRIO_PROTECT() {
        return _SC_THREAD_PRIO_PROTECT;
    }
    private static final int _SC_THREAD_PRIORITY_SCHEDULING = (int)89L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PRIORITY_SCHEDULING 89
     * }
     */
    public static int _SC_THREAD_PRIORITY_SCHEDULING() {
        return _SC_THREAD_PRIORITY_SCHEDULING;
    }
    private static final int _SC_THREAD_PROCESS_SHARED = (int)90L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_PROCESS_SHARED 90
     * }
     */
    public static int _SC_THREAD_PROCESS_SHARED() {
        return _SC_THREAD_PROCESS_SHARED;
    }
    private static final int _SC_THREAD_SAFE_FUNCTIONS = (int)91L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_SAFE_FUNCTIONS 91
     * }
     */
    public static int _SC_THREAD_SAFE_FUNCTIONS() {
        return _SC_THREAD_SAFE_FUNCTIONS;
    }
    private static final int _SC_THREAD_SPORADIC_SERVER = (int)92L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_SPORADIC_SERVER 92
     * }
     */
    public static int _SC_THREAD_SPORADIC_SERVER() {
        return _SC_THREAD_SPORADIC_SERVER;
    }
    private static final int _SC_THREAD_STACK_MIN = (int)93L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_STACK_MIN 93
     * }
     */
    public static int _SC_THREAD_STACK_MIN() {
        return _SC_THREAD_STACK_MIN;
    }
    private static final int _SC_THREAD_THREADS_MAX = (int)94L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREAD_THREADS_MAX 94
     * }
     */
    public static int _SC_THREAD_THREADS_MAX() {
        return _SC_THREAD_THREADS_MAX;
    }
    private static final int _SC_TIMEOUTS = (int)95L;
    /**
     * {@snippet lang=c :
     * #define _SC_TIMEOUTS 95
     * }
     */
    public static int _SC_TIMEOUTS() {
        return _SC_TIMEOUTS;
    }
    private static final int _SC_THREADS = (int)96L;
    /**
     * {@snippet lang=c :
     * #define _SC_THREADS 96
     * }
     */
    public static int _SC_THREADS() {
        return _SC_THREADS;
    }
    private static final int _SC_TRACE = (int)97L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE 97
     * }
     */
    public static int _SC_TRACE() {
        return _SC_TRACE;
    }
    private static final int _SC_TRACE_EVENT_FILTER = (int)98L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_EVENT_FILTER 98
     * }
     */
    public static int _SC_TRACE_EVENT_FILTER() {
        return _SC_TRACE_EVENT_FILTER;
    }
    private static final int _SC_TRACE_INHERIT = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_INHERIT 99
     * }
     */
    public static int _SC_TRACE_INHERIT() {
        return _SC_TRACE_INHERIT;
    }
    private static final int _SC_TRACE_LOG = (int)100L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_LOG 100
     * }
     */
    public static int _SC_TRACE_LOG() {
        return _SC_TRACE_LOG;
    }
    private static final int _SC_TTY_NAME_MAX = (int)101L;
    /**
     * {@snippet lang=c :
     * #define _SC_TTY_NAME_MAX 101
     * }
     */
    public static int _SC_TTY_NAME_MAX() {
        return _SC_TTY_NAME_MAX;
    }
    private static final int _SC_TYPED_MEMORY_OBJECTS = (int)102L;
    /**
     * {@snippet lang=c :
     * #define _SC_TYPED_MEMORY_OBJECTS 102
     * }
     */
    public static int _SC_TYPED_MEMORY_OBJECTS() {
        return _SC_TYPED_MEMORY_OBJECTS;
    }
    private static final int _SC_V6_ILP32_OFF32 = (int)103L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_ILP32_OFF32 103
     * }
     */
    public static int _SC_V6_ILP32_OFF32() {
        return _SC_V6_ILP32_OFF32;
    }
    private static final int _SC_V6_ILP32_OFFBIG = (int)104L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_ILP32_OFFBIG 104
     * }
     */
    public static int _SC_V6_ILP32_OFFBIG() {
        return _SC_V6_ILP32_OFFBIG;
    }
    private static final int _SC_V6_LP64_OFF64 = (int)105L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_LP64_OFF64 105
     * }
     */
    public static int _SC_V6_LP64_OFF64() {
        return _SC_V6_LP64_OFF64;
    }
    private static final int _SC_V6_LPBIG_OFFBIG = (int)106L;
    /**
     * {@snippet lang=c :
     * #define _SC_V6_LPBIG_OFFBIG 106
     * }
     */
    public static int _SC_V6_LPBIG_OFFBIG() {
        return _SC_V6_LPBIG_OFFBIG;
    }
    private static final int _SC_IPV6 = (int)118L;
    /**
     * {@snippet lang=c :
     * #define _SC_IPV6 118
     * }
     */
    public static int _SC_IPV6() {
        return _SC_IPV6;
    }
    private static final int _SC_RAW_SOCKETS = (int)119L;
    /**
     * {@snippet lang=c :
     * #define _SC_RAW_SOCKETS 119
     * }
     */
    public static int _SC_RAW_SOCKETS() {
        return _SC_RAW_SOCKETS;
    }
    private static final int _SC_SYMLOOP_MAX = (int)120L;
    /**
     * {@snippet lang=c :
     * #define _SC_SYMLOOP_MAX 120
     * }
     */
    public static int _SC_SYMLOOP_MAX() {
        return _SC_SYMLOOP_MAX;
    }
    private static final int _SC_ATEXIT_MAX = (int)107L;
    /**
     * {@snippet lang=c :
     * #define _SC_ATEXIT_MAX 107
     * }
     */
    public static int _SC_ATEXIT_MAX() {
        return _SC_ATEXIT_MAX;
    }
    private static final int _SC_IOV_MAX = (int)56L;
    /**
     * {@snippet lang=c :
     * #define _SC_IOV_MAX 56
     * }
     */
    public static int _SC_IOV_MAX() {
        return _SC_IOV_MAX;
    }
    private static final int _SC_XOPEN_CRYPT = (int)108L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_CRYPT 108
     * }
     */
    public static int _SC_XOPEN_CRYPT() {
        return _SC_XOPEN_CRYPT;
    }
    private static final int _SC_XOPEN_ENH_I18N = (int)109L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_ENH_I18N 109
     * }
     */
    public static int _SC_XOPEN_ENH_I18N() {
        return _SC_XOPEN_ENH_I18N;
    }
    private static final int _SC_XOPEN_LEGACY = (int)110L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_LEGACY 110
     * }
     */
    public static int _SC_XOPEN_LEGACY() {
        return _SC_XOPEN_LEGACY;
    }
    private static final int _SC_XOPEN_REALTIME = (int)111L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_REALTIME 111
     * }
     */
    public static int _SC_XOPEN_REALTIME() {
        return _SC_XOPEN_REALTIME;
    }
    private static final int _SC_XOPEN_REALTIME_THREADS = (int)112L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_REALTIME_THREADS 112
     * }
     */
    public static int _SC_XOPEN_REALTIME_THREADS() {
        return _SC_XOPEN_REALTIME_THREADS;
    }
    private static final int _SC_XOPEN_SHM = (int)113L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_SHM 113
     * }
     */
    public static int _SC_XOPEN_SHM() {
        return _SC_XOPEN_SHM;
    }
    private static final int _SC_XOPEN_STREAMS = (int)114L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_STREAMS 114
     * }
     */
    public static int _SC_XOPEN_STREAMS() {
        return _SC_XOPEN_STREAMS;
    }
    private static final int _SC_XOPEN_UNIX = (int)115L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_UNIX 115
     * }
     */
    public static int _SC_XOPEN_UNIX() {
        return _SC_XOPEN_UNIX;
    }
    private static final int _SC_XOPEN_VERSION = (int)116L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_VERSION 116
     * }
     */
    public static int _SC_XOPEN_VERSION() {
        return _SC_XOPEN_VERSION;
    }
    private static final int _SC_XOPEN_XCU_VERSION = (int)121L;
    /**
     * {@snippet lang=c :
     * #define _SC_XOPEN_XCU_VERSION 121
     * }
     */
    public static int _SC_XOPEN_XCU_VERSION() {
        return _SC_XOPEN_XCU_VERSION;
    }
    private static final int _SC_XBS5_ILP32_OFF32 = (int)122L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_ILP32_OFF32 122
     * }
     */
    public static int _SC_XBS5_ILP32_OFF32() {
        return _SC_XBS5_ILP32_OFF32;
    }
    private static final int _SC_XBS5_ILP32_OFFBIG = (int)123L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_ILP32_OFFBIG 123
     * }
     */
    public static int _SC_XBS5_ILP32_OFFBIG() {
        return _SC_XBS5_ILP32_OFFBIG;
    }
    private static final int _SC_XBS5_LP64_OFF64 = (int)124L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_LP64_OFF64 124
     * }
     */
    public static int _SC_XBS5_LP64_OFF64() {
        return _SC_XBS5_LP64_OFF64;
    }
    private static final int _SC_XBS5_LPBIG_OFFBIG = (int)125L;
    /**
     * {@snippet lang=c :
     * #define _SC_XBS5_LPBIG_OFFBIG 125
     * }
     */
    public static int _SC_XBS5_LPBIG_OFFBIG() {
        return _SC_XBS5_LPBIG_OFFBIG;
    }
    private static final int _SC_SS_REPL_MAX = (int)126L;
    /**
     * {@snippet lang=c :
     * #define _SC_SS_REPL_MAX 126
     * }
     */
    public static int _SC_SS_REPL_MAX() {
        return _SC_SS_REPL_MAX;
    }
    private static final int _SC_TRACE_EVENT_NAME_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_EVENT_NAME_MAX 127
     * }
     */
    public static int _SC_TRACE_EVENT_NAME_MAX() {
        return _SC_TRACE_EVENT_NAME_MAX;
    }
    private static final int _SC_TRACE_NAME_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_NAME_MAX 128
     * }
     */
    public static int _SC_TRACE_NAME_MAX() {
        return _SC_TRACE_NAME_MAX;
    }
    private static final int _SC_TRACE_SYS_MAX = (int)129L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_SYS_MAX 129
     * }
     */
    public static int _SC_TRACE_SYS_MAX() {
        return _SC_TRACE_SYS_MAX;
    }
    private static final int _SC_TRACE_USER_EVENT_MAX = (int)130L;
    /**
     * {@snippet lang=c :
     * #define _SC_TRACE_USER_EVENT_MAX 130
     * }
     */
    public static int _SC_TRACE_USER_EVENT_MAX() {
        return _SC_TRACE_USER_EVENT_MAX;
    }
    private static final int _SC_PASS_MAX = (int)131L;
    /**
     * {@snippet lang=c :
     * #define _SC_PASS_MAX 131
     * }
     */
    public static int _SC_PASS_MAX() {
        return _SC_PASS_MAX;
    }
    private static final int _SC_PHYS_PAGES = (int)200L;
    /**
     * {@snippet lang=c :
     * #define _SC_PHYS_PAGES 200
     * }
     */
    public static int _SC_PHYS_PAGES() {
        return _SC_PHYS_PAGES;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_CFLAGS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_CFLAGS 2
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS 3
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFF32_LIBS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFF32_LIBS 4
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFF32_LIBS() {
        return _CS_POSIX_V6_ILP32_OFF32_LIBS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS 5
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS 6
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_ILP32_OFFBIG_LIBS = (int)7L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_ILP32_OFFBIG_LIBS 7
     * }
     */
    public static int _CS_POSIX_V6_ILP32_OFFBIG_LIBS() {
        return _CS_POSIX_V6_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_CFLAGS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_CFLAGS 8
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_CFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LDFLAGS = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_LDFLAGS 9
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LDFLAGS() {
        return _CS_POSIX_V6_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LP64_OFF64_LIBS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LP64_OFF64_LIBS 10
     * }
     */
    public static int _CS_POSIX_V6_LP64_OFF64_LIBS() {
        return _CS_POSIX_V6_LP64_OFF64_LIBS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS 11
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS 12
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS = (int)13L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS 13
     * }
     */
    public static int _CS_POSIX_V6_LPBIG_OFFBIG_LIBS() {
        return _CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS 14
     * }
     */
    public static int _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS() {
        return _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_CFLAGS = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_CFLAGS 20
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_CFLAGS() {
        return _CS_XBS5_ILP32_OFF32_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LDFLAGS = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LDFLAGS 21
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LDFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LIBS = (int)22L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LIBS 22
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LIBS() {
        return _CS_XBS5_ILP32_OFF32_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFF32_LINTFLAGS = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFF32_LINTFLAGS 23
     * }
     */
    public static int _CS_XBS5_ILP32_OFF32_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFF32_LINTFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_CFLAGS = (int)24L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_CFLAGS 24
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_CFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LDFLAGS = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LDFLAGS 25
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LDFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LIBS = (int)26L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LIBS 26
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LIBS() {
        return _CS_XBS5_ILP32_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = (int)27L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS 27
     * }
     */
    public static int _CS_XBS5_ILP32_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_CFLAGS = (int)28L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_CFLAGS 28
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_CFLAGS() {
        return _CS_XBS5_LP64_OFF64_CFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LDFLAGS = (int)29L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LDFLAGS 29
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LDFLAGS() {
        return _CS_XBS5_LP64_OFF64_LDFLAGS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LIBS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LIBS 30
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LIBS() {
        return _CS_XBS5_LP64_OFF64_LIBS;
    }
    private static final int _CS_XBS5_LP64_OFF64_LINTFLAGS = (int)31L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LP64_OFF64_LINTFLAGS 31
     * }
     */
    public static int _CS_XBS5_LP64_OFF64_LINTFLAGS() {
        return _CS_XBS5_LP64_OFF64_LINTFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_CFLAGS = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_CFLAGS 32
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_CFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_CFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS 33
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LDFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LIBS = (int)34L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LIBS 34
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LIBS() {
        return _CS_XBS5_LPBIG_OFFBIG_LIBS;
    }
    private static final int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = (int)35L;
    /**
     * {@snippet lang=c :
     * #define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS 35
     * }
     */
    public static int _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS() {
        return _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
    }
    private static final int _CS_DARWIN_USER_DIR = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_DIR 65536
     * }
     */
    public static int _CS_DARWIN_USER_DIR() {
        return _CS_DARWIN_USER_DIR;
    }
    private static final int _CS_DARWIN_USER_TEMP_DIR = (int)65537L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_TEMP_DIR 65537
     * }
     */
    public static int _CS_DARWIN_USER_TEMP_DIR() {
        return _CS_DARWIN_USER_TEMP_DIR;
    }
    private static final int _CS_DARWIN_USER_CACHE_DIR = (int)65538L;
    /**
     * {@snippet lang=c :
     * #define _CS_DARWIN_USER_CACHE_DIR 65538
     * }
     */
    public static int _CS_DARWIN_USER_CACHE_DIR() {
        return _CS_DARWIN_USER_CACHE_DIR;
    }
    private static final int F_ULOCK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define F_ULOCK 0
     * }
     */
    public static int F_ULOCK() {
        return F_ULOCK;
    }
    private static final int F_LOCK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define F_LOCK 1
     * }
     */
    public static int F_LOCK() {
        return F_LOCK;
    }
    private static final int F_TLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define F_TLOCK 2
     * }
     */
    public static int F_TLOCK() {
        return F_TLOCK;
    }
    private static final int F_TEST = (int)3L;
    /**
     * {@snippet lang=c :
     * #define F_TEST 3
     * }
     */
    public static int F_TEST() {
        return F_TEST;
    }
    private static final int __DARWIN_FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_FD_SETSIZE 1024
     * }
     */
    public static int __DARWIN_FD_SETSIZE() {
        return __DARWIN_FD_SETSIZE;
    }
    private static final int __DARWIN_NBBY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NBBY 8
     * }
     */
    public static int __DARWIN_NBBY() {
        return __DARWIN_NBBY;
    }
    private static final int SYNC_VOLUME_FULLSYNC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SYNC_VOLUME_FULLSYNC 1
     * }
     */
    public static int SYNC_VOLUME_FULLSYNC() {
        return SYNC_VOLUME_FULLSYNC;
    }
    private static final int SYNC_VOLUME_WAIT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SYNC_VOLUME_WAIT 2
     * }
     */
    public static int SYNC_VOLUME_WAIT() {
        return SYNC_VOLUME_WAIT;
    }
    private static final int ARCHIVE_EOF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_EOF 1
     * }
     */
    public static int ARCHIVE_EOF() {
        return ARCHIVE_EOF;
    }
    private static final int ARCHIVE_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_OK 0
     * }
     */
    public static int ARCHIVE_OK() {
        return ARCHIVE_OK;
    }
    private static final int ARCHIVE_FILTER_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_NONE 0
     * }
     */
    public static int ARCHIVE_FILTER_NONE() {
        return ARCHIVE_FILTER_NONE;
    }
    private static final int ARCHIVE_FILTER_GZIP = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_GZIP 1
     * }
     */
    public static int ARCHIVE_FILTER_GZIP() {
        return ARCHIVE_FILTER_GZIP;
    }
    private static final int ARCHIVE_FILTER_BZIP2 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_BZIP2 2
     * }
     */
    public static int ARCHIVE_FILTER_BZIP2() {
        return ARCHIVE_FILTER_BZIP2;
    }
    private static final int ARCHIVE_FILTER_COMPRESS = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_COMPRESS 3
     * }
     */
    public static int ARCHIVE_FILTER_COMPRESS() {
        return ARCHIVE_FILTER_COMPRESS;
    }
    private static final int ARCHIVE_FILTER_PROGRAM = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_PROGRAM 4
     * }
     */
    public static int ARCHIVE_FILTER_PROGRAM() {
        return ARCHIVE_FILTER_PROGRAM;
    }
    private static final int ARCHIVE_FILTER_LZMA = (int)5L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_LZMA 5
     * }
     */
    public static int ARCHIVE_FILTER_LZMA() {
        return ARCHIVE_FILTER_LZMA;
    }
    private static final int ARCHIVE_FILTER_XZ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_XZ 6
     * }
     */
    public static int ARCHIVE_FILTER_XZ() {
        return ARCHIVE_FILTER_XZ;
    }
    private static final int ARCHIVE_FILTER_UU = (int)7L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_UU 7
     * }
     */
    public static int ARCHIVE_FILTER_UU() {
        return ARCHIVE_FILTER_UU;
    }
    private static final int ARCHIVE_FILTER_RPM = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_RPM 8
     * }
     */
    public static int ARCHIVE_FILTER_RPM() {
        return ARCHIVE_FILTER_RPM;
    }
    private static final int ARCHIVE_FILTER_LZIP = (int)9L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_LZIP 9
     * }
     */
    public static int ARCHIVE_FILTER_LZIP() {
        return ARCHIVE_FILTER_LZIP;
    }
    private static final int ARCHIVE_FILTER_LRZIP = (int)10L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_LRZIP 10
     * }
     */
    public static int ARCHIVE_FILTER_LRZIP() {
        return ARCHIVE_FILTER_LRZIP;
    }
    private static final int ARCHIVE_FILTER_LZOP = (int)11L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_LZOP 11
     * }
     */
    public static int ARCHIVE_FILTER_LZOP() {
        return ARCHIVE_FILTER_LZOP;
    }
    private static final int ARCHIVE_FILTER_GRZIP = (int)12L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_GRZIP 12
     * }
     */
    public static int ARCHIVE_FILTER_GRZIP() {
        return ARCHIVE_FILTER_GRZIP;
    }
    private static final int ARCHIVE_FILTER_LZ4 = (int)13L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_LZ4 13
     * }
     */
    public static int ARCHIVE_FILTER_LZ4() {
        return ARCHIVE_FILTER_LZ4;
    }
    private static final int ARCHIVE_FILTER_ZSTD = (int)14L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FILTER_ZSTD 14
     * }
     */
    public static int ARCHIVE_FILTER_ZSTD() {
        return ARCHIVE_FILTER_ZSTD;
    }
    private static final int ARCHIVE_FORMAT_BASE_MASK = (int)16711680L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_BASE_MASK 16711680
     * }
     */
    public static int ARCHIVE_FORMAT_BASE_MASK() {
        return ARCHIVE_FORMAT_BASE_MASK;
    }
    private static final int ARCHIVE_FORMAT_CPIO = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_CPIO 65536
     * }
     */
    public static int ARCHIVE_FORMAT_CPIO() {
        return ARCHIVE_FORMAT_CPIO;
    }
    private static final int ARCHIVE_FORMAT_SHAR = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_SHAR 131072
     * }
     */
    public static int ARCHIVE_FORMAT_SHAR() {
        return ARCHIVE_FORMAT_SHAR;
    }
    private static final int ARCHIVE_FORMAT_TAR = (int)196608L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_TAR 196608
     * }
     */
    public static int ARCHIVE_FORMAT_TAR() {
        return ARCHIVE_FORMAT_TAR;
    }
    private static final int ARCHIVE_FORMAT_ISO9660 = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_ISO9660 262144
     * }
     */
    public static int ARCHIVE_FORMAT_ISO9660() {
        return ARCHIVE_FORMAT_ISO9660;
    }
    private static final int ARCHIVE_FORMAT_ZIP = (int)327680L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_ZIP 327680
     * }
     */
    public static int ARCHIVE_FORMAT_ZIP() {
        return ARCHIVE_FORMAT_ZIP;
    }
    private static final int ARCHIVE_FORMAT_EMPTY = (int)393216L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_EMPTY 393216
     * }
     */
    public static int ARCHIVE_FORMAT_EMPTY() {
        return ARCHIVE_FORMAT_EMPTY;
    }
    private static final int ARCHIVE_FORMAT_AR = (int)458752L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_AR 458752
     * }
     */
    public static int ARCHIVE_FORMAT_AR() {
        return ARCHIVE_FORMAT_AR;
    }
    private static final int ARCHIVE_FORMAT_MTREE = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_MTREE 524288
     * }
     */
    public static int ARCHIVE_FORMAT_MTREE() {
        return ARCHIVE_FORMAT_MTREE;
    }
    private static final int ARCHIVE_FORMAT_RAW = (int)589824L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_RAW 589824
     * }
     */
    public static int ARCHIVE_FORMAT_RAW() {
        return ARCHIVE_FORMAT_RAW;
    }
    private static final int ARCHIVE_FORMAT_XAR = (int)655360L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_XAR 655360
     * }
     */
    public static int ARCHIVE_FORMAT_XAR() {
        return ARCHIVE_FORMAT_XAR;
    }
    private static final int ARCHIVE_FORMAT_LHA = (int)720896L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_LHA 720896
     * }
     */
    public static int ARCHIVE_FORMAT_LHA() {
        return ARCHIVE_FORMAT_LHA;
    }
    private static final int ARCHIVE_FORMAT_CAB = (int)786432L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_CAB 786432
     * }
     */
    public static int ARCHIVE_FORMAT_CAB() {
        return ARCHIVE_FORMAT_CAB;
    }
    private static final int ARCHIVE_FORMAT_RAR = (int)851968L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_RAR 851968
     * }
     */
    public static int ARCHIVE_FORMAT_RAR() {
        return ARCHIVE_FORMAT_RAR;
    }
    private static final int ARCHIVE_FORMAT_7ZIP = (int)917504L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_7ZIP 917504
     * }
     */
    public static int ARCHIVE_FORMAT_7ZIP() {
        return ARCHIVE_FORMAT_7ZIP;
    }
    private static final int ARCHIVE_FORMAT_WARC = (int)983040L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_WARC 983040
     * }
     */
    public static int ARCHIVE_FORMAT_WARC() {
        return ARCHIVE_FORMAT_WARC;
    }
    private static final int ARCHIVE_FORMAT_RAR_V5 = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_FORMAT_RAR_V5 1048576
     * }
     */
    public static int ARCHIVE_FORMAT_RAR_V5() {
        return ARCHIVE_FORMAT_RAR_V5;
    }
    private static final int _QUAD_HIGHWORD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _QUAD_HIGHWORD 1
     * }
     */
    public static int _QUAD_HIGHWORD() {
        return _QUAD_HIGHWORD;
    }
    private static final int _QUAD_LOWWORD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _QUAD_LOWWORD 0
     * }
     */
    public static int _QUAD_LOWWORD() {
        return _QUAD_LOWWORD;
    }
    private static final int __DARWIN_LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_LITTLE_ENDIAN 1234
     * }
     */
    public static int __DARWIN_LITTLE_ENDIAN() {
        return __DARWIN_LITTLE_ENDIAN;
    }
    private static final int __DARWIN_BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BIG_ENDIAN 4321
     * }
     */
    public static int __DARWIN_BIG_ENDIAN() {
        return __DARWIN_BIG_ENDIAN;
    }
    private static final int __DARWIN_PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_PDP_ENDIAN 3412
     * }
     */
    public static int __DARWIN_PDP_ENDIAN() {
        return __DARWIN_PDP_ENDIAN;
    }
    private static final int AE_SYMLINK_TYPE_UNDEFINED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AE_SYMLINK_TYPE_UNDEFINED 0
     * }
     */
    public static int AE_SYMLINK_TYPE_UNDEFINED() {
        return AE_SYMLINK_TYPE_UNDEFINED;
    }
    private static final int AE_SYMLINK_TYPE_FILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AE_SYMLINK_TYPE_FILE 1
     * }
     */
    public static int AE_SYMLINK_TYPE_FILE() {
        return AE_SYMLINK_TYPE_FILE;
    }
    private static final int AE_SYMLINK_TYPE_DIRECTORY = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AE_SYMLINK_TYPE_DIRECTORY 2
     * }
     */
    public static int AE_SYMLINK_TYPE_DIRECTORY() {
        return AE_SYMLINK_TYPE_DIRECTORY;
    }
    private static final int ARCHIVE_ENTRY_DIGEST_MD5 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_DIGEST_MD5 1
     * }
     */
    public static int ARCHIVE_ENTRY_DIGEST_MD5() {
        return ARCHIVE_ENTRY_DIGEST_MD5;
    }
    private static final int ARCHIVE_ENTRY_DIGEST_RMD160 = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_DIGEST_RMD160 2
     * }
     */
    public static int ARCHIVE_ENTRY_DIGEST_RMD160() {
        return ARCHIVE_ENTRY_DIGEST_RMD160;
    }
    private static final int ARCHIVE_ENTRY_DIGEST_SHA1 = (int)3L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_DIGEST_SHA1 3
     * }
     */
    public static int ARCHIVE_ENTRY_DIGEST_SHA1() {
        return ARCHIVE_ENTRY_DIGEST_SHA1;
    }
    private static final int ARCHIVE_ENTRY_DIGEST_SHA256 = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_DIGEST_SHA256 4
     * }
     */
    public static int ARCHIVE_ENTRY_DIGEST_SHA256() {
        return ARCHIVE_ENTRY_DIGEST_SHA256;
    }
    private static final int ARCHIVE_ENTRY_DIGEST_SHA384 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_DIGEST_SHA384 5
     * }
     */
    public static int ARCHIVE_ENTRY_DIGEST_SHA384() {
        return ARCHIVE_ENTRY_DIGEST_SHA384;
    }
    private static final int ARCHIVE_ENTRY_DIGEST_SHA512 = (int)6L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_DIGEST_SHA512 6
     * }
     */
    public static int ARCHIVE_ENTRY_DIGEST_SHA512() {
        return ARCHIVE_ENTRY_DIGEST_SHA512;
    }
    private static final int ARCHIVE_ENTRY_ACL_EXECUTE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_EXECUTE 1
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_EXECUTE() {
        return ARCHIVE_ENTRY_ACL_EXECUTE;
    }
    private static final int ARCHIVE_ENTRY_ACL_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_WRITE 2
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_WRITE() {
        return ARCHIVE_ENTRY_ACL_WRITE;
    }
    private static final int ARCHIVE_ENTRY_ACL_READ = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_READ 4
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_READ() {
        return ARCHIVE_ENTRY_ACL_READ;
    }
    private static final int ARCHIVE_ENTRY_ACL_READ_DATA = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_READ_DATA 8
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_READ_DATA() {
        return ARCHIVE_ENTRY_ACL_READ_DATA;
    }
    private static final int ARCHIVE_ENTRY_ACL_LIST_DIRECTORY = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_LIST_DIRECTORY 8
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_LIST_DIRECTORY() {
        return ARCHIVE_ENTRY_ACL_LIST_DIRECTORY;
    }
    private static final int ARCHIVE_ENTRY_ACL_WRITE_DATA = (int)16L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_WRITE_DATA 16
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_WRITE_DATA() {
        return ARCHIVE_ENTRY_ACL_WRITE_DATA;
    }
    private static final int ARCHIVE_ENTRY_ACL_ADD_FILE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_ADD_FILE 16
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_ADD_FILE() {
        return ARCHIVE_ENTRY_ACL_ADD_FILE;
    }
    private static final int ARCHIVE_ENTRY_ACL_APPEND_DATA = (int)32L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_APPEND_DATA 32
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_APPEND_DATA() {
        return ARCHIVE_ENTRY_ACL_APPEND_DATA;
    }
    private static final int ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY = (int)32L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY 32
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY() {
        return ARCHIVE_ENTRY_ACL_ADD_SUBDIRECTORY;
    }
    private static final int ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS 64
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS() {
        return ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS;
    }
    private static final int ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS = (int)128L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS 128
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS() {
        return ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS;
    }
    private static final int ARCHIVE_ENTRY_ACL_DELETE_CHILD = (int)256L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_DELETE_CHILD 256
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_DELETE_CHILD() {
        return ARCHIVE_ENTRY_ACL_DELETE_CHILD;
    }
    private static final int ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES = (int)512L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES 512
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES() {
        return ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES;
    }
    private static final int ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES 1024
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES() {
        return ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES;
    }
    private static final int ARCHIVE_ENTRY_ACL_DELETE = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_DELETE 2048
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_DELETE() {
        return ARCHIVE_ENTRY_ACL_DELETE;
    }
    private static final int ARCHIVE_ENTRY_ACL_READ_ACL = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_READ_ACL 4096
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_READ_ACL() {
        return ARCHIVE_ENTRY_ACL_READ_ACL;
    }
    private static final int ARCHIVE_ENTRY_ACL_WRITE_ACL = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_WRITE_ACL 8192
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_WRITE_ACL() {
        return ARCHIVE_ENTRY_ACL_WRITE_ACL;
    }
    private static final int ARCHIVE_ENTRY_ACL_WRITE_OWNER = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_WRITE_OWNER 16384
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_WRITE_OWNER() {
        return ARCHIVE_ENTRY_ACL_WRITE_OWNER;
    }
    private static final int ARCHIVE_ENTRY_ACL_SYNCHRONIZE = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_SYNCHRONIZE 32768
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_SYNCHRONIZE() {
        return ARCHIVE_ENTRY_ACL_SYNCHRONIZE;
    }
    private static final int ARCHIVE_ENTRY_ACL_ENTRY_INHERITED = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_ENTRY_INHERITED 16777216
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_ENTRY_INHERITED() {
        return ARCHIVE_ENTRY_ACL_ENTRY_INHERITED;
    }
    private static final int ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT = (int)33554432L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT 33554432
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT() {
        return ARCHIVE_ENTRY_ACL_ENTRY_FILE_INHERIT;
    }
    private static final int ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT = (int)67108864L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT 67108864
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT() {
        return ARCHIVE_ENTRY_ACL_ENTRY_DIRECTORY_INHERIT;
    }
    private static final int ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT = (int)134217728L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT 134217728
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT() {
        return ARCHIVE_ENTRY_ACL_ENTRY_NO_PROPAGATE_INHERIT;
    }
    private static final int ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY = (int)268435456L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY 268435456
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY() {
        return ARCHIVE_ENTRY_ACL_ENTRY_INHERIT_ONLY;
    }
    private static final int ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS 536870912
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS() {
        return ARCHIVE_ENTRY_ACL_ENTRY_SUCCESSFUL_ACCESS;
    }
    private static final int ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS 1073741824
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS() {
        return ARCHIVE_ENTRY_ACL_ENTRY_FAILED_ACCESS;
    }
    private static final int ARCHIVE_ENTRY_ACL_TYPE_ACCESS = (int)256L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_TYPE_ACCESS 256
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_TYPE_ACCESS() {
        return ARCHIVE_ENTRY_ACL_TYPE_ACCESS;
    }
    private static final int ARCHIVE_ENTRY_ACL_TYPE_DEFAULT = (int)512L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_TYPE_DEFAULT 512
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_TYPE_DEFAULT() {
        return ARCHIVE_ENTRY_ACL_TYPE_DEFAULT;
    }
    private static final int ARCHIVE_ENTRY_ACL_TYPE_ALLOW = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_TYPE_ALLOW 1024
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_TYPE_ALLOW() {
        return ARCHIVE_ENTRY_ACL_TYPE_ALLOW;
    }
    private static final int ARCHIVE_ENTRY_ACL_TYPE_DENY = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_TYPE_DENY 2048
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_TYPE_DENY() {
        return ARCHIVE_ENTRY_ACL_TYPE_DENY;
    }
    private static final int ARCHIVE_ENTRY_ACL_TYPE_AUDIT = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_TYPE_AUDIT 4096
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_TYPE_AUDIT() {
        return ARCHIVE_ENTRY_ACL_TYPE_AUDIT;
    }
    private static final int ARCHIVE_ENTRY_ACL_TYPE_ALARM = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_TYPE_ALARM 8192
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_TYPE_ALARM() {
        return ARCHIVE_ENTRY_ACL_TYPE_ALARM;
    }
    private static final int ARCHIVE_ENTRY_ACL_USER = (int)10001L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_USER 10001
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_USER() {
        return ARCHIVE_ENTRY_ACL_USER;
    }
    private static final int ARCHIVE_ENTRY_ACL_USER_OBJ = (int)10002L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_USER_OBJ 10002
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_USER_OBJ() {
        return ARCHIVE_ENTRY_ACL_USER_OBJ;
    }
    private static final int ARCHIVE_ENTRY_ACL_GROUP = (int)10003L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_GROUP 10003
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_GROUP() {
        return ARCHIVE_ENTRY_ACL_GROUP;
    }
    private static final int ARCHIVE_ENTRY_ACL_GROUP_OBJ = (int)10004L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_GROUP_OBJ 10004
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_GROUP_OBJ() {
        return ARCHIVE_ENTRY_ACL_GROUP_OBJ;
    }
    private static final int ARCHIVE_ENTRY_ACL_MASK = (int)10005L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_MASK 10005
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_MASK() {
        return ARCHIVE_ENTRY_ACL_MASK;
    }
    private static final int ARCHIVE_ENTRY_ACL_OTHER = (int)10006L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_OTHER 10006
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_OTHER() {
        return ARCHIVE_ENTRY_ACL_OTHER;
    }
    private static final int ARCHIVE_ENTRY_ACL_EVERYONE = (int)10107L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_EVERYONE 10107
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_EVERYONE() {
        return ARCHIVE_ENTRY_ACL_EVERYONE;
    }
    private static final int ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID 1
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID() {
        return ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID;
    }
    private static final int ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT 2
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT() {
        return ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT;
    }
    private static final int ARCHIVE_ENTRY_ACL_STYLE_SOLARIS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_STYLE_SOLARIS 4
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_STYLE_SOLARIS() {
        return ARCHIVE_ENTRY_ACL_STYLE_SOLARIS;
    }
    private static final int ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA = (int)8L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA 8
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA() {
        return ARCHIVE_ENTRY_ACL_STYLE_SEPARATOR_COMMA;
    }
    private static final int ARCHIVE_ENTRY_ACL_STYLE_COMPACT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define ARCHIVE_ENTRY_ACL_STYLE_COMPACT 16
     * }
     */
    public static int ARCHIVE_ENTRY_ACL_STYLE_COMPACT() {
        return ARCHIVE_ENTRY_ACL_STYLE_COMPACT;
    }
    private static final int OLD_ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define OLD_ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID 1024
     * }
     */
    public static int OLD_ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID() {
        return OLD_ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID;
    }
    private static final int OLD_ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define OLD_ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT 2048
     * }
     */
    public static int OLD_ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT() {
        return OLD_ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT;
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = archive_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = archive_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = archive_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = archive_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = archive_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = archive_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_blksize_t blksize_t
     * }
     */
    public static final OfInt blksize_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino_t ino_t
     * }
     */
    public static final OfLong ino_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t ino64_t
     * }
     */
    public static final OfLong ino64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t nlink_t
     * }
     */
    public static final OfShort nlink_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_gid_t gid_t
     * }
     */
    public static final OfInt gid_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_time_t time_t
     * }
     */
    public static final OfLong time_t = archive_h.C_LONG;

    private static class chmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("chmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor chmod$descriptor() {
        return chmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static MethodHandle chmod$handle() {
        return chmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static MemorySegment chmod$address() {
        return chmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chmod(const char *, mode_t)
     * }
     */
    public static int chmod(MemorySegment x0, short x1) {
        var mh$ = chmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chmod", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static FunctionDescriptor fchmod$descriptor() {
        return fchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static MethodHandle fchmod$handle() {
        return fchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static MemorySegment fchmod$address() {
        return fchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmod(int, mode_t)
     * }
     */
    public static int fchmod(int x0, short x1) {
        var mh$ = fchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmod", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static FunctionDescriptor fstat$descriptor() {
        return fstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static MethodHandle fstat$handle() {
        return fstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static MemorySegment fstat$address() {
        return fstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstat(int, struct stat *)
     * }
     */
    public static int fstat(int x0, MemorySegment x1) {
        var mh$ = fstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstat", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("lstat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static FunctionDescriptor lstat$descriptor() {
        return lstat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static MethodHandle lstat$handle() {
        return lstat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static MemorySegment lstat$address() {
        return lstat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstat(const char *, struct stat *)
     * }
     */
    public static int lstat(MemorySegment x0, MemorySegment x1) {
        var mh$ = lstat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstat", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkdir$descriptor() {
        return mkdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static MethodHandle mkdir$handle() {
        return mkdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static MemorySegment mkdir$address() {
        return mkdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdir(const char *, mode_t)
     * }
     */
    public static int mkdir(MemorySegment x0, short x1) {
        var mh$ = mkdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdir", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkfifo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkfifo$descriptor() {
        return mkfifo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static MethodHandle mkfifo$handle() {
        return mkfifo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static MemorySegment mkfifo$address() {
        return mkfifo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifo(const char *, mode_t)
     * }
     */
    public static int mkfifo(MemorySegment x0, short x1) {
        var mh$ = mkfifo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifo", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("stat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static FunctionDescriptor stat$descriptor() {
        return stat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static MethodHandle stat$handle() {
        return stat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static MemorySegment stat$address() {
        return stat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int stat(const char *, struct stat *)
     * }
     */
    public static int stat(MemorySegment x0, MemorySegment x1) {
        var mh$ = stat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stat", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_SHORT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mknod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static FunctionDescriptor mknod$descriptor() {
        return mknod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MethodHandle mknod$handle() {
        return mknod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknod$address() {
        return mknod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mknod(const char *, mode_t, dev_t)
     * }
     */
    public static int mknod(MemorySegment x0, short x1, int x2) {
        var mh$ = mknod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknod", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_SHORT,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("umask");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static FunctionDescriptor umask$descriptor() {
        return umask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static MethodHandle umask$handle() {
        return umask.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static MemorySegment umask$address() {
        return umask.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mode_t umask(mode_t)
     * }
     */
    public static short umask(short x0) {
        var mh$ = umask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umask", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_SHORT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fchmodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static FunctionDescriptor fchmodat$descriptor() {
        return fchmodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static MethodHandle fchmodat$handle() {
        return fchmodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static MemorySegment fchmodat$address() {
        return fchmodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmodat(int, const char *, mode_t, int)
     * }
     */
    public static int fchmodat(int x0, MemorySegment x1, short x2, int x3) {
        var mh$ = fchmodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmodat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fstatat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static FunctionDescriptor fstatat$descriptor() {
        return fstatat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static MethodHandle fstatat$handle() {
        return fstatat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static MemorySegment fstatat$address() {
        return fstatat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstatat(int, const char *, struct stat *, int)
     * }
     */
    public static int fstatat(int x0, MemorySegment x1, MemorySegment x2, int x3) {
        var mh$ = fstatat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdirat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkdirat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkdirat$descriptor() {
        return mkdirat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static MethodHandle mkdirat$handle() {
        return mkdirat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static MemorySegment mkdirat$address() {
        return mkdirat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdirat(int, const char *, mode_t)
     * }
     */
    public static int mkdirat(int x0, MemorySegment x1, short x2) {
        var mh$ = mkdirat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdirat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifoat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkfifoat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static FunctionDescriptor mkfifoat$descriptor() {
        return mkfifoat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static MethodHandle mkfifoat$handle() {
        return mkfifoat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static MemorySegment mkfifoat$address() {
        return mkfifoat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifoat(int, const char *, mode_t)
     * }
     */
    public static int mkfifoat(int x0, MemorySegment x1, short x2) {
        var mh$ = mkfifoat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifoat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mknodat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_SHORT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mknodat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static FunctionDescriptor mknodat$descriptor() {
        return mknodat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static MethodHandle mknodat$handle() {
        return mknodat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static MemorySegment mknodat$address() {
        return mknodat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mknodat(int, const char *, mode_t, dev_t)
     * }
     */
    public static int mknodat(int x0, MemorySegment x1, short x2, int x3) {
        var mh$ = mknodat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mknodat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class futimens {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("futimens");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static FunctionDescriptor futimens$descriptor() {
        return futimens.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MethodHandle futimens$handle() {
        return futimens.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static MemorySegment futimens$address() {
        return futimens.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int futimens(int __fd, const struct timespec __times[2])
     * }
     */
    public static int futimens(int __fd, MemorySegment __times) {
        var mh$ = futimens.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("futimens", __fd, __times);
            }
            return (int)mh$.invokeExact(__fd, __times);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class utimensat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("utimensat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static FunctionDescriptor utimensat$descriptor() {
        return utimensat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static MethodHandle utimensat$handle() {
        return utimensat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static MemorySegment utimensat$address() {
        return utimensat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int utimensat(int __fd, const char *__path, const struct timespec __times[2], int __flag)
     * }
     */
    public static int utimensat(int __fd, MemorySegment __path, MemorySegment __times, int __flag) {
        var mh$ = utimensat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("utimensat", __fd, __path, __times, __flag);
            }
            return (int)mh$.invokeExact(__fd, __path, __times, __flag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _filesec *filesec_t
     * }
     */
    public static final AddressLayout filesec_t = archive_h.C_POINTER;

    private static class chflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("chflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static FunctionDescriptor chflags$descriptor() {
        return chflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static MethodHandle chflags$handle() {
        return chflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static MemorySegment chflags$address() {
        return chflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chflags(const char *, __uint32_t)
     * }
     */
    public static int chflags(MemorySegment x0, int x1) {
        var mh$ = chflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chflags", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chmodx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("chmodx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor chmodx_np$descriptor() {
        return chmodx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle chmodx_np$handle() {
        return chmodx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment chmodx_np$address() {
        return chmodx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chmodx_np(const char *, filesec_t)
     * }
     */
    public static int chmodx_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = chmodx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chmodx_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fchflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static FunctionDescriptor fchflags$descriptor() {
        return fchflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static MethodHandle fchflags$handle() {
        return fchflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static MemorySegment fchflags$address() {
        return fchflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchflags(int, __uint32_t)
     * }
     */
    public static int fchflags(int x0, int x1) {
        var mh$ = fchflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchflags", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchmodx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fchmodx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static FunctionDescriptor fchmodx_np$descriptor() {
        return fchmodx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static MethodHandle fchmodx_np$handle() {
        return fchmodx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static MemorySegment fchmodx_np$address() {
        return fchmodx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchmodx_np(int, filesec_t)
     * }
     */
    public static int fchmodx_np(int x0, MemorySegment x1) {
        var mh$ = fchmodx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchmodx_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fstatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fstatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor fstatx_np$descriptor() {
        return fstatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle fstatx_np$handle() {
        return fstatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment fstatx_np$address() {
        return fstatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fstatx_np(int, struct stat *, filesec_t)
     * }
     */
    public static int fstatx_np(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = fstatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fstatx_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchflags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("lchflags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static FunctionDescriptor lchflags$descriptor() {
        return lchflags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static MethodHandle lchflags$handle() {
        return lchflags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static MemorySegment lchflags$address() {
        return lchflags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchflags(const char *, __uint32_t)
     * }
     */
    public static int lchflags(MemorySegment x0, int x1) {
        var mh$ = lchflags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchflags", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lchmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_SHORT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("lchmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static FunctionDescriptor lchmod$descriptor() {
        return lchmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static MethodHandle lchmod$handle() {
        return lchmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static MemorySegment lchmod$address() {
        return lchmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lchmod(const char *, mode_t)
     * }
     */
    public static int lchmod(MemorySegment x0, short x1) {
        var mh$ = lchmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lchmod", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("lstatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor lstatx_np$descriptor() {
        return lstatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle lstatx_np$handle() {
        return lstatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment lstatx_np$address() {
        return lstatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int lstatx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static int lstatx_np(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = lstatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstatx_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdirx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkdirx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor mkdirx_np$descriptor() {
        return mkdirx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle mkdirx_np$handle() {
        return mkdirx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment mkdirx_np$address() {
        return mkdirx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkdirx_np(const char *, filesec_t)
     * }
     */
    public static int mkdirx_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = mkdirx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdirx_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkfifox_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mkfifox_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static FunctionDescriptor mkfifox_np$descriptor() {
        return mkfifox_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static MethodHandle mkfifox_np$handle() {
        return mkfifox_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static MemorySegment mkfifox_np$address() {
        return mkfifox_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkfifox_np(const char *, filesec_t)
     * }
     */
    public static int mkfifox_np(MemorySegment x0, MemorySegment x1) {
        var mh$ = mkfifox_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkfifox_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class statx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("statx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static FunctionDescriptor statx_np$descriptor() {
        return statx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MethodHandle statx_np$handle() {
        return statx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static MemorySegment statx_np$address() {
        return statx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int statx_np(const char *, struct stat *, filesec_t)
     * }
     */
    public static int statx_np(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = statx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("statx_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class umaskx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("umaskx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static FunctionDescriptor umaskx_np$descriptor() {
        return umaskx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static MethodHandle umaskx_np$handle() {
        return umaskx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static MemorySegment umaskx_np$address() {
        return umaskx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int umaskx_np(filesec_t)
     * }
     */
    public static int umaskx_np(MemorySegment x0) {
        var mh$ = umaskx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("umaskx_np", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ptrdiff_t ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t wchar_t
     * }
     */
    public static final OfInt wchar_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wint_t wint_t
     * }
     */
    public static final OfInt wint_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = archive_h.C_POINTER;

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static int renameat(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renamex_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("renamex_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renamex_np$descriptor() {
        return renamex_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MethodHandle renamex_np$handle() {
        return renamex_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment renamex_np$address() {
        return renamex_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static int renamex_np(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = renamex_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renamex_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("renameatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renameatx_np$descriptor() {
        return renameatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MethodHandle renameatx_np$handle() {
        return renameatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MemorySegment renameatx_np$address() {
        return renameatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static int renameatx_np(int x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = renameatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameatx_np", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t fpos_t
     * }
     */
    public static final OfLong fpos_t = archive_h.C_LONG_LONG;

    private static class __stdinp$constants {
        public static final AddressLayout LAYOUT = archive_h.C_POINTER;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("__stdinp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static AddressLayout __stdinp$layout() {
        return __stdinp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp$segment() {
        return __stdinp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp() {
        return __stdinp$constants.SEGMENT.get(__stdinp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static void __stdinp(MemorySegment varValue) {
        __stdinp$constants.SEGMENT.set(__stdinp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stdoutp$constants {
        public static final AddressLayout LAYOUT = archive_h.C_POINTER;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("__stdoutp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static AddressLayout __stdoutp$layout() {
        return __stdoutp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp$segment() {
        return __stdoutp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp() {
        return __stdoutp$constants.SEGMENT.get(__stdoutp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static void __stdoutp(MemorySegment varValue) {
        __stdoutp$constants.SEGMENT.set(__stdoutp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stderrp$constants {
        public static final AddressLayout LAYOUT = archive_h.C_POINTER;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("__stderrp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static AddressLayout __stderrp$layout() {
        return __stderrp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp$segment() {
        return __stderrp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp() {
        return __stderrp$constants.SEGMENT.get(__stderrp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static void __stderrp(MemorySegment varValue) {
        __stderrp$constants.SEGMENT.set(__stderrp$constants.LAYOUT, 0L, varValue);
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static void clearerr(MemorySegment x0) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static int fclose(MemorySegment x0) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static int feof(MemorySegment x0) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static int ferror(MemorySegment x0) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static int fflush(MemorySegment x0) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static int fgetc(MemorySegment x0) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static int fgetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgets(char *restrict, int, FILE *)
     * }
     */
    public static MemorySegment fgets(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __mode) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fprintf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fprintf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static int fputc(int x0, MemorySegment x1) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static int fputs(MemorySegment x0, MemorySegment x1) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment freopen(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fscanf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fscanf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static int fseek(MemorySegment x0, long x1, int x2) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static int fsetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static long ftell(MemorySegment x0) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static int getc(MemorySegment x0) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("gets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static FunctionDescriptor gets$descriptor() {
        return gets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MethodHandle gets$handle() {
        return gets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets$address() {
        return gets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets(MemorySegment x0) {
        var mh$ = gets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gets", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static void perror(MemorySegment x0) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int printf(const char *restrict, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int printf(const char *restrict, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", x0, x1);
                }
                return (int)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static int putc(int x0, MemorySegment x1) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static int putchar(int x0) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static int puts(MemorySegment x0) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static int remove(MemorySegment x0) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static void rewind(MemorySegment x0) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int scanf(const char *restrict, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int scanf(const char *restrict, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", x0, x1);
                }
                return (int)spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static void setbuf(MemorySegment x0, MemorySegment x1) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t)
     * }
     */
    public static int setvbuf(MemorySegment x0, MemorySegment x1, int x2, long x3) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sprintf(char *restrict, const char *restrict, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sprintf(char *restrict, const char *restrict, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sscanf(const char *restrict, const char *restrict, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sscanf(const char *restrict, const char *restrict, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static int ungetc(int x0, MemorySegment x1) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static int vfprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static int vprintf(MemorySegment x0, MemorySegment x1) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static int vsprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid(MemorySegment x0) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MemorySegment fdopen(int x0, MemorySegment x1) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static int fileno(MemorySegment x0) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static int pclose(MemorySegment x0) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MemorySegment popen(MemorySegment x0, MemorySegment x1) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __srget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("__srget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static FunctionDescriptor __srget$descriptor() {
        return __srget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MethodHandle __srget$handle() {
        return __srget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MemorySegment __srget$address() {
        return __srget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static int __srget(MemorySegment x0) {
        var mh$ = __srget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__srget", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __svfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("__svfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static FunctionDescriptor __svfscanf$descriptor() {
        return __svfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MethodHandle __svfscanf$handle() {
        return __svfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MemorySegment __svfscanf$address() {
        return __svfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static int __svfscanf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __svfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__svfscanf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __swbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("__swbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static FunctionDescriptor __swbuf$descriptor() {
        return __swbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MethodHandle __swbuf$handle() {
        return __swbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MemorySegment __swbuf$address() {
        return __swbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static int __swbuf(int x0, MemorySegment x1) {
        var mh$ = __swbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__swbuf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static void flockfile(MemorySegment x0) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static int ftrylockfile(MemorySegment x0) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static void funlockfile(MemorySegment x0) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static int getc_unlocked(MemorySegment x0) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static int putc_unlocked(int x0, MemorySegment x1) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static int putchar_unlocked(int x0) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static int getw(MemorySegment x0) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static int putw(int x0, MemorySegment x1) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __prefix) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __prefix);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __prefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __offset, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __offset, __whence);
            }
            return (int)mh$.invokeExact(__stream, __offset, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER,
                archive_h.C_LONG,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __str, long __size, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __str, __size, __format, x3);
                }
                return (int)spreader.invokeExact(__str, __size, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static int vfscanf(MemorySegment __stream, MemorySegment __format, MemorySegment x2) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __stream, __format, x2);
            }
            return (int)mh$.invokeExact(__stream, __format, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment x1) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, x1);
            }
            return (int)mh$.invokeExact(__format, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static int vsnprintf(MemorySegment __str, long __size, MemorySegment __format, MemorySegment x3) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __str, __size, __format, x3);
            }
            return (int)mh$.invokeExact(__str, __size, __format, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static int vsscanf(MemorySegment __str, MemorySegment __format, MemorySegment x2) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __str, __format, x2);
            }
            return (int)mh$.invokeExact(__str, __format, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = archive_h.C_LONG;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int dprintf(int, const char *restrict, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_INT,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int dprintf(int, const char *restrict, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static int vdprintf(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __linep, MemorySegment __linecapp, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __linep, __linecapp, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __linep, MemorySegment __linecapp, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __linep, __linecapp, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __buf, long __size, MemorySegment __mode) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __buf, __size, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__buf, __size, __mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufp, MemorySegment __sizep) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufp, __sizep);
            }
            return (MemorySegment)mh$.invokeExact(__bufp, __sizep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sys_nerr$constants {
        public static final OfInt LAYOUT = archive_h.C_INT;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("sys_nerr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static OfInt sys_nerr$layout() {
        return sys_nerr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static MemorySegment sys_nerr$segment() {
        return sys_nerr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static int sys_nerr() {
        return sys_nerr$constants.SEGMENT.get(sys_nerr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static void sys_nerr(int varValue) {
        sys_nerr$constants.SEGMENT.set(sys_nerr$constants.LAYOUT, 0L, varValue);
    }

    private static class sys_errlist$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, archive_h.C_POINTER);
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("sys_errlist").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static SequenceLayout sys_errlist$layout() {
        return sys_errlist$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static long[] sys_errlist$dimensions() {
        return sys_errlist$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static MemorySegment sys_errlist() {
        return sys_errlist$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static void sys_errlist(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, sys_errlist$constants.SEGMENT, 0L, sys_errlist$constants.LAYOUT.byteSize());
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int asprintf(char **restrict, const char *restrict, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int asprintf(char **restrict, const char *restrict, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ctermid_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ctermid_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static FunctionDescriptor ctermid_r$descriptor() {
        return ctermid_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MethodHandle ctermid_r$handle() {
        return ctermid_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r$address() {
        return ctermid_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r(MemorySegment x0) {
        var mh$ = ctermid_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid_r", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fgetln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static FunctionDescriptor fgetln$descriptor() {
        return fgetln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MethodHandle fgetln$handle() {
        return fgetln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MemorySegment fgetln$address() {
        return fgetln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *)
     * }
     */
    public static MemorySegment fgetln(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetln", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmtcheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fmtcheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static FunctionDescriptor fmtcheck$descriptor() {
        return fmtcheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MethodHandle fmtcheck$handle() {
        return fmtcheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck$address() {
        return fmtcheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck(MemorySegment x0, MemorySegment x1) {
        var mh$ = fmtcheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmtcheck", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpurge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fpurge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static FunctionDescriptor fpurge$descriptor() {
        return fpurge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MethodHandle fpurge$handle() {
        return fpurge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MemorySegment fpurge$address() {
        return fpurge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static int fpurge(MemorySegment x0) {
        var mh$ = fpurge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpurge", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int)
     * }
     */
    public static void setbuffer(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static int setlinebuf(MemorySegment x0) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static int vasprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("funopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static FunctionDescriptor funopen$descriptor() {
        return funopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MethodHandle funopen$handle() {
        return funopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen$address() {
        return funopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = funopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funopen", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __sprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER,
                archive_h.C_INT,
                archive_h.C_LONG,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("__sprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __sprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
         * }
         */
        public static __sprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __sprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, int x1, long x2, MemorySegment x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__sprintf_chk", x0, x1, x2, x3, x4);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __snprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __snprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER,
                archive_h.C_LONG,
                archive_h.C_INT,
                archive_h.C_LONG,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("__snprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __snprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __snprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, ...)
         * }
         */
        public static __snprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __snprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, long x1, int x2, long x3, MemorySegment x4, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__snprintf_chk", x0, x1, x2, x3, x4, x5);
                }
                return (int)spreader.invokeExact(x0, x1, x2, x3, x4, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __vsprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("__vsprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsprintf_chk$descriptor() {
        return __vsprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsprintf_chk$handle() {
        return __vsprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsprintf_chk$address() {
        return __vsprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsprintf_chk(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = __vsprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsprintf_chk", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __vsnprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_INT,
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("__vsnprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsnprintf_chk$descriptor() {
        return __vsnprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsnprintf_chk$handle() {
        return __vsnprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsnprintf_chk$address() {
        return __vsnprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsnprintf_chk(MemorySegment x0, long x1, int x2, long x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = __vsnprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsnprintf_chk", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_clock_t clock_t
     * }
     */
    public static final OfLong clock_t = archive_h.C_LONG;

    private static class tzname$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, archive_h.C_POINTER);
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("tzname").reinterpret(LAYOUT.byteSize());
        public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static SequenceLayout tzname$layout() {
        return tzname$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static long[] tzname$dimensions() {
        return tzname$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static MemorySegment tzname() {
        return tzname$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *tzname[]
     * }
     */
    public static void tzname(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, tzname$constants.SEGMENT, 0L, tzname$constants.LAYOUT.byteSize());
    }

    private static class getdate_err$constants {
        public static final OfInt LAYOUT = archive_h.C_INT;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("getdate_err").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static OfInt getdate_err$layout() {
        return getdate_err$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static MemorySegment getdate_err$segment() {
        return getdate_err$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static int getdate_err() {
        return getdate_err$constants.SEGMENT.get(getdate_err$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int getdate_err
     * }
     */
    public static void getdate_err(int varValue) {
        getdate_err$constants.SEGMENT.set(getdate_err$constants.LAYOUT, 0L, varValue);
    }

    private static class timezone$constants {
        public static final OfLong LAYOUT = archive_h.C_LONG;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("timezone").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static OfLong timezone$layout() {
        return timezone$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static MemorySegment timezone$segment() {
        return timezone$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static long timezone() {
        return timezone$constants.SEGMENT.get(timezone$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern long timezone
     * }
     */
    public static void timezone(long varValue) {
        timezone$constants.SEGMENT.set(timezone$constants.LAYOUT, 0L, varValue);
    }

    private static class daylight$constants {
        public static final OfInt LAYOUT = archive_h.C_INT;
        public static final MemorySegment SEGMENT = archive_h.findOrThrow("daylight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static OfInt daylight$layout() {
        return daylight$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static MemorySegment daylight$segment() {
        return daylight$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static int daylight() {
        return daylight$constants.SEGMENT.get(daylight$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int daylight
     * }
     */
    public static void daylight(int varValue) {
        daylight$constants.SEGMENT.set(daylight$constants.LAYOUT, 0L, varValue);
    }

    private static class asctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("asctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static FunctionDescriptor asctime$descriptor() {
        return asctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MethodHandle asctime$handle() {
        return asctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime$address() {
        return asctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime(const struct tm *)
     * }
     */
    public static MemorySegment asctime(MemorySegment x0) {
        var mh$ = asctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("clock");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static FunctionDescriptor clock$descriptor() {
        return clock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MethodHandle clock$handle() {
        return clock.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static MemorySegment clock$address() {
        return clock.ADDR;
    }

    /**
     * {@snippet lang=c :
     * clock_t clock()
     * }
     */
    public static long clock() {
        var mh$ = clock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ctime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static FunctionDescriptor ctime$descriptor() {
        return ctime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MethodHandle ctime$handle() {
        return ctime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime$address() {
        return ctime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime(const time_t *)
     * }
     */
    public static MemorySegment ctime(MemorySegment x0) {
        var mh$ = ctime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class difftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_DOUBLE,
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("difftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static FunctionDescriptor difftime$descriptor() {
        return difftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MethodHandle difftime$handle() {
        return difftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static MemorySegment difftime$address() {
        return difftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double difftime(time_t, time_t)
     * }
     */
    public static double difftime(long x0, long x1) {
        var mh$ = difftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("difftime", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getdate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static FunctionDescriptor getdate$descriptor() {
        return getdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MethodHandle getdate$handle() {
        return getdate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate$address() {
        return getdate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *getdate(const char *)
     * }
     */
    public static MemorySegment getdate(MemorySegment x0) {
        var mh$ = getdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("gmtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static FunctionDescriptor gmtime$descriptor() {
        return gmtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MethodHandle gmtime$handle() {
        return gmtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime$address() {
        return gmtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime(const time_t *)
     * }
     */
    public static MemorySegment gmtime(MemorySegment x0) {
        var mh$ = gmtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("localtime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static FunctionDescriptor localtime$descriptor() {
        return localtime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MethodHandle localtime$handle() {
        return localtime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime$address() {
        return localtime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime(const time_t *)
     * }
     */
    public static MemorySegment localtime(MemorySegment x0) {
        var mh$ = localtime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("mktime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static FunctionDescriptor mktime$descriptor() {
        return mktime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MethodHandle mktime$handle() {
        return mktime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static MemorySegment mktime$address() {
        return mktime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t mktime(struct tm *)
     * }
     */
    public static long mktime(MemorySegment x0) {
        var mh$ = mktime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktime", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strftime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("strftime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strftime$descriptor() {
        return strftime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MethodHandle strftime$handle() {
        return strftime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static MemorySegment strftime$address() {
        return strftime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strftime(char *restrict, size_t, const char *restrict, const struct tm *restrict)
     * }
     */
    public static long strftime(MemorySegment x0, long x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = strftime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strftime", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strptime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("strptime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor strptime$descriptor() {
        return strptime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle strptime$handle() {
        return strptime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime$address() {
        return strptime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strptime(const char *restrict, const char *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment strptime(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = strptime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strptime", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static FunctionDescriptor time$descriptor() {
        return time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MethodHandle time$handle() {
        return time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static MemorySegment time$address() {
        return time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time(time_t *)
     * }
     */
    public static long time(MemorySegment x0) {
        var mh$ = time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("tzset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static FunctionDescriptor tzset$descriptor() {
        return tzset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MethodHandle tzset$handle() {
        return tzset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static MemorySegment tzset$address() {
        return tzset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzset()
     * }
     */
    public static void tzset() {
        var mh$ = tzset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzset");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("asctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor asctime_r$descriptor() {
        return asctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MethodHandle asctime_r$handle() {
        return asctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r$address() {
        return asctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asctime_r(const struct tm *restrict, char *restrict)
     * }
     */
    public static MemorySegment asctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = asctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asctime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("ctime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static FunctionDescriptor ctime_r$descriptor() {
        return ctime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MethodHandle ctime_r$handle() {
        return ctime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r$address() {
        return ctime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctime_r(const time_t *, char *)
     * }
     */
    public static MemorySegment ctime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = ctime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gmtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("gmtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor gmtime_r$descriptor() {
        return gmtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle gmtime_r$handle() {
        return gmtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r$address() {
        return gmtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *gmtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment gmtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = gmtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gmtime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class localtime_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("localtime_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static FunctionDescriptor localtime_r$descriptor() {
        return localtime_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MethodHandle localtime_r$handle() {
        return localtime_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r$address() {
        return localtime_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct tm *localtime_r(const time_t *restrict, struct tm *restrict)
     * }
     */
    public static MemorySegment localtime_r(MemorySegment x0, MemorySegment x1) {
        var mh$ = localtime_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("localtime_r", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix2time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("posix2time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static FunctionDescriptor posix2time$descriptor() {
        return posix2time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MethodHandle posix2time$handle() {
        return posix2time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static MemorySegment posix2time$address() {
        return posix2time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t posix2time(time_t)
     * }
     */
    public static long posix2time(long x0) {
        var mh$ = posix2time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix2time", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tzsetwall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("tzsetwall");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static FunctionDescriptor tzsetwall$descriptor() {
        return tzsetwall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MethodHandle tzsetwall$handle() {
        return tzsetwall.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static MemorySegment tzsetwall$address() {
        return tzsetwall.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void tzsetwall()
     * }
     */
    public static void tzsetwall() {
        var mh$ = tzsetwall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tzsetwall");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class time2posix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("time2posix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static FunctionDescriptor time2posix$descriptor() {
        return time2posix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MethodHandle time2posix$handle() {
        return time2posix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static MemorySegment time2posix$address() {
        return time2posix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t time2posix(time_t)
     * }
     */
    public static long time2posix(long x0) {
        var mh$ = time2posix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("time2posix", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timelocal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("timelocal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static FunctionDescriptor timelocal$descriptor() {
        return timelocal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MethodHandle timelocal$handle() {
        return timelocal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static MemorySegment timelocal$address() {
        return timelocal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timelocal(struct tm *const)
     * }
     */
    public static long timelocal(MemorySegment x0) {
        var mh$ = timelocal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timelocal", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timegm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("timegm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static FunctionDescriptor timegm$descriptor() {
        return timegm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MethodHandle timegm$handle() {
        return timegm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static MemorySegment timegm$address() {
        return timegm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * time_t timegm(struct tm *const)
     * }
     */
    public static long timegm(MemorySegment x0) {
        var mh$ = timegm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timegm", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanosleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("nanosleep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static FunctionDescriptor nanosleep$descriptor() {
        return nanosleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MethodHandle nanosleep$handle() {
        return nanosleep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static MemorySegment nanosleep$address() {
        return nanosleep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp)
     * }
     */
    public static int nanosleep(MemorySegment __rqtp, MemorySegment __rmtp) {
        var mh$ = nanosleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanosleep", __rqtp, __rmtp);
            }
            return (int)mh$.invokeExact(__rqtp, __rmtp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int _CLOCK_REALTIME = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_REALTIME = 0
     * }
     */
    public static int _CLOCK_REALTIME() {
        return _CLOCK_REALTIME;
    }
    private static final int _CLOCK_MONOTONIC = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC = 6
     * }
     */
    public static int _CLOCK_MONOTONIC() {
        return _CLOCK_MONOTONIC;
    }
    private static final int _CLOCK_MONOTONIC_RAW = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW = 4
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW() {
        return _CLOCK_MONOTONIC_RAW;
    }
    private static final int _CLOCK_MONOTONIC_RAW_APPROX = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_MONOTONIC_RAW_APPROX = 5
     * }
     */
    public static int _CLOCK_MONOTONIC_RAW_APPROX() {
        return _CLOCK_MONOTONIC_RAW_APPROX;
    }
    private static final int _CLOCK_UPTIME_RAW = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW = 8
     * }
     */
    public static int _CLOCK_UPTIME_RAW() {
        return _CLOCK_UPTIME_RAW;
    }
    private static final int _CLOCK_UPTIME_RAW_APPROX = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_UPTIME_RAW_APPROX = 9
     * }
     */
    public static int _CLOCK_UPTIME_RAW_APPROX() {
        return _CLOCK_UPTIME_RAW_APPROX;
    }
    private static final int _CLOCK_PROCESS_CPUTIME_ID = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_PROCESS_CPUTIME_ID = 12
     * }
     */
    public static int _CLOCK_PROCESS_CPUTIME_ID() {
        return _CLOCK_PROCESS_CPUTIME_ID;
    }
    private static final int _CLOCK_THREAD_CPUTIME_ID = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>._CLOCK_THREAD_CPUTIME_ID = 16
     * }
     */
    public static int _CLOCK_THREAD_CPUTIME_ID() {
        return _CLOCK_THREAD_CPUTIME_ID;
    }

    private static class clock_getres {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("clock_getres");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static FunctionDescriptor clock_getres$descriptor() {
        return clock_getres.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MethodHandle clock_getres$handle() {
        return clock_getres.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static MemorySegment clock_getres$address() {
        return clock_getres.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_getres(clockid_t __clock_id, struct timespec *__res)
     * }
     */
    public static int clock_getres(int __clock_id, MemorySegment __res) {
        var mh$ = clock_getres.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_getres", __clock_id, __res);
            }
            return (int)mh$.invokeExact(__clock_id, __res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("clock_gettime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_gettime$descriptor() {
        return clock_gettime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_gettime$handle() {
        return clock_gettime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_gettime$address() {
        return clock_gettime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_gettime(clockid_t __clock_id, struct timespec *__tp)
     * }
     */
    public static int clock_gettime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_gettime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_gettime_nsec_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("clock_gettime_nsec_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static FunctionDescriptor clock_gettime_nsec_np$descriptor() {
        return clock_gettime_nsec_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MethodHandle clock_gettime_nsec_np$handle() {
        return clock_gettime_nsec_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static MemorySegment clock_gettime_nsec_np$address() {
        return clock_gettime_nsec_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * __uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
     * }
     */
    public static long clock_gettime_nsec_np(int __clock_id) {
        var mh$ = clock_gettime_nsec_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_gettime_nsec_np", __clock_id);
            }
            return (long)mh$.invokeExact(__clock_id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clock_settime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("clock_settime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static FunctionDescriptor clock_settime$descriptor() {
        return clock_settime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MethodHandle clock_settime$handle() {
        return clock_settime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static MemorySegment clock_settime$address() {
        return clock_settime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int clock_settime(clockid_t __clock_id, const struct timespec *__tp)
     * }
     */
    public static int clock_settime(int __clock_id, MemorySegment __tp) {
        var mh$ = clock_settime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clock_settime", __clock_id, __tp);
            }
            return (int)mh$.invokeExact(__clock_id, __tp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timespec_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("timespec_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static FunctionDescriptor timespec_get$descriptor() {
        return timespec_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MethodHandle timespec_get$handle() {
        return timespec_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static MemorySegment timespec_get$address() {
        return timespec_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timespec_get(struct timespec *ts, int base)
     * }
     */
    public static int timespec_get(MemorySegment ts, int base) {
        var mh$ = timespec_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timespec_get", ts, base);
            }
            return (int)mh$.invokeExact(ts, base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = archive_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = archive_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = archive_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = archive_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = archive_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = archive_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = archive_h.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = archive_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = archive_h.C_LONG;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static long imaxabs(long j) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", j);
            }
            return (long)mh$.invokeExact(j);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlistbulk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getattrlistbulk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static FunctionDescriptor getattrlistbulk$descriptor() {
        return getattrlistbulk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static MethodHandle getattrlistbulk$handle() {
        return getattrlistbulk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static MemorySegment getattrlistbulk$address() {
        return getattrlistbulk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlistbulk(int, void *, void *, size_t, uint64_t)
     * }
     */
    public static int getattrlistbulk(int x0, MemorySegment x1, MemorySegment x2, long x3, long x4) {
        var mh$ = getattrlistbulk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlistbulk", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getattrlistat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getattrlistat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static FunctionDescriptor getattrlistat$descriptor() {
        return getattrlistat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static MethodHandle getattrlistat$handle() {
        return getattrlistat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static MemorySegment getattrlistat$address() {
        return getattrlistat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getattrlistat(int, const char *, void *, void *, size_t, unsigned long)
     * }
     */
    public static int getattrlistat(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, long x5) {
        var mh$ = getattrlistat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getattrlistat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setattrlistat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("setattrlistat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static FunctionDescriptor setattrlistat$descriptor() {
        return setattrlistat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static MethodHandle setattrlistat$handle() {
        return setattrlistat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static MemorySegment setattrlistat$address() {
        return setattrlistat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setattrlistat(int, const char *, void *, void *, size_t, uint32_t)
     * }
     */
    public static int setattrlistat(int x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = setattrlistat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setattrlistat", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freadlink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("freadlink");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static FunctionDescriptor freadlink$descriptor() {
        return freadlink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static MethodHandle freadlink$handle() {
        return freadlink.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static MemorySegment freadlink$address() {
        return freadlink.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t freadlink(int, char *restrict, size_t)
     * }
     */
    public static long freadlink(int x0, MemorySegment x1, long x2) {
        var mh$ = freadlink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freadlink", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class faccessat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("faccessat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static FunctionDescriptor faccessat$descriptor() {
        return faccessat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static MethodHandle faccessat$handle() {
        return faccessat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static MemorySegment faccessat$address() {
        return faccessat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int faccessat(int, const char *, int, int)
     * }
     */
    public static int faccessat(int x0, MemorySegment x1, int x2, int x3) {
        var mh$ = faccessat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("faccessat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fchownat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fchownat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static FunctionDescriptor fchownat$descriptor() {
        return fchownat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static MethodHandle fchownat$handle() {
        return fchownat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static MemorySegment fchownat$address() {
        return fchownat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fchownat(int, const char *, uid_t, gid_t, int)
     * }
     */
    public static int fchownat(int x0, MemorySegment x1, int x2, int x3, int x4) {
        var mh$ = fchownat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fchownat", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class linkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("linkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static FunctionDescriptor linkat$descriptor() {
        return linkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static MethodHandle linkat$handle() {
        return linkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static MemorySegment linkat$address() {
        return linkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int linkat(int, const char *, int, const char *, int)
     * }
     */
    public static int linkat(int x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = linkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("linkat", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class readlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("readlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static FunctionDescriptor readlinkat$descriptor() {
        return readlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static MethodHandle readlinkat$handle() {
        return readlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static MemorySegment readlinkat$address() {
        return readlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t readlinkat(int, const char *, char *, size_t)
     * }
     */
    public static long readlinkat(int x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = readlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("readlinkat", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class symlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("symlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor symlinkat$descriptor() {
        return symlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static MethodHandle symlinkat$handle() {
        return symlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static MemorySegment symlinkat$address() {
        return symlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int symlinkat(const char *, int, const char *)
     * }
     */
    public static int symlinkat(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = symlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("symlinkat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlinkat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("unlinkat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static FunctionDescriptor unlinkat$descriptor() {
        return unlinkat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static MethodHandle unlinkat$handle() {
        return unlinkat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static MemorySegment unlinkat$address() {
        return unlinkat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlinkat(int, const char *, int)
     * }
     */
    public static int unlinkat(int x0, MemorySegment x1, int x2) {
        var mh$ = unlinkat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlinkat", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = archive_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_useconds_t useconds_t
     * }
     */
    public static final OfInt useconds_t = archive_h.C_INT;

    private static class _exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static FunctionDescriptor _exit$descriptor() {
        return _exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static MethodHandle _exit$handle() {
        return _exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static MemorySegment _exit$address() {
        return _exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _exit(int)
     * }
     */
    public static void _exit(int x0) {
        var mh$ = _exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class access {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("access");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static FunctionDescriptor access$descriptor() {
        return access.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static MethodHandle access$handle() {
        return access.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static MemorySegment access$address() {
        return access.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int access(const char *, int)
     * }
     */
    public static int access(MemorySegment x0, int x1) {
        var mh$ = access.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("access", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alarm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("alarm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static FunctionDescriptor alarm$descriptor() {
        return alarm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static MethodHandle alarm$handle() {
        return alarm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static MemorySegment alarm$address() {
        return alarm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int alarm(unsigned int)
     * }
     */
    public static int alarm(int x0) {
        var mh$ = alarm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alarm", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chdir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("chdir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static FunctionDescriptor chdir$descriptor() {
        return chdir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static MethodHandle chdir$handle() {
        return chdir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static MemorySegment chdir$address() {
        return chdir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chdir(const char *)
     * }
     */
    public static int chdir(MemorySegment x0) {
        var mh$ = chdir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chdir", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class chown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("chown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static FunctionDescriptor chown$descriptor() {
        return chown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static MethodHandle chown$handle() {
        return chown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static MemorySegment chown$address() {
        return chown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int chown(const char *, uid_t, gid_t)
     * }
     */
    public static int chown(MemorySegment x0, int x1, int x2) {
        var mh$ = chown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("chown", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static FunctionDescriptor close$descriptor() {
        return close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static MethodHandle close$handle() {
        return close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static MemorySegment close$address() {
        return close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int close(int)
     * }
     */
    public static int close(int x0) {
        var mh$ = close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("close", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("dup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static FunctionDescriptor dup$descriptor() {
        return dup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static MethodHandle dup$handle() {
        return dup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static MemorySegment dup$address() {
        return dup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup(int)
     * }
     */
    public static int dup(int x0) {
        var mh$ = dup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class dup2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("dup2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static FunctionDescriptor dup2$descriptor() {
        return dup2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static MethodHandle dup2$handle() {
        return dup2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static MemorySegment dup2$address() {
        return dup2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int dup2(int, int)
     * }
     */
    public static int dup2(int x0, int x1) {
        var mh$ = dup2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("dup2", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execl(const char *__path, const char *__arg0, ...)
     * }
     */
    public static class execl {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("execl");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execl(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execl(const char *__path, const char *__arg0, ...)
         * }
         */
        public static execl makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execl(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execl", __path, __arg0, x2);
                }
                return (int)spreader.invokeExact(__path, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execle(const char *__path, const char *__arg0, ...)
     * }
     */
    public static class execle {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("execle");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execle(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execle(const char *__path, const char *__arg0, ...)
         * }
         */
        public static execle makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execle(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __path, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execle", __path, __arg0, x2);
                }
                return (int)spreader.invokeExact(__path, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int execlp(const char *__file, const char *__arg0, ...)
     * }
     */
    public static class execlp {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                archive_h.C_INT,
                archive_h.C_POINTER,
                archive_h.C_POINTER
            );
        private static final MemorySegment ADDR = archive_h.findOrThrow("execlp");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private execlp(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int execlp(const char *__file, const char *__arg0, ...)
         * }
         */
        public static execlp makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new execlp(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __file, MemorySegment __arg0, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("execlp", __file, __arg0, x2);
                }
                return (int)spreader.invokeExact(__file, __arg0, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class execv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("execv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execv$descriptor() {
        return execv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static MethodHandle execv$handle() {
        return execv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static MemorySegment execv$address() {
        return execv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execv(const char *__path, char *const *__argv)
     * }
     */
    public static int execv(MemorySegment __path, MemorySegment __argv) {
        var mh$ = execv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execv", __path, __argv);
            }
            return (int)mh$.invokeExact(__path, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execve {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("execve");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static FunctionDescriptor execve$descriptor() {
        return execve.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static MethodHandle execve$handle() {
        return execve.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static MemorySegment execve$address() {
        return execve.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execve(const char *__file, char *const *__argv, char *const *__envp)
     * }
     */
    public static int execve(MemorySegment __file, MemorySegment __argv, MemorySegment __envp) {
        var mh$ = execve.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execve", __file, __argv, __envp);
            }
            return (int)mh$.invokeExact(__file, __argv, __envp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class execvp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT,
            archive_h.C_POINTER,
            archive_h.C_POINTER
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("execvp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static FunctionDescriptor execvp$descriptor() {
        return execvp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static MethodHandle execvp$handle() {
        return execvp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static MemorySegment execvp$address() {
        return execvp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int execvp(const char *__file, char *const *__argv)
     * }
     */
    public static int execvp(MemorySegment __file, MemorySegment __argv) {
        var mh$ = execvp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("execvp", __file, __argv);
            }
            return (int)mh$.invokeExact(__file, __argv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fork");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static FunctionDescriptor fork$descriptor() {
        return fork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static MethodHandle fork$handle() {
        return fork.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static MemorySegment fork$address() {
        return fork.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t fork()
     * }
     */
    public static int fork() {
        var mh$ = fork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fork");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpathconf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_LONG,
            archive_h.C_INT,
            archive_h.C_INT
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("fpathconf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static FunctionDescriptor fpathconf$descriptor() {
        return fpathconf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static MethodHandle fpathconf$handle() {
        return fpathconf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static MemorySegment fpathconf$address() {
        return fpathconf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long fpathconf(int, int)
     * }
     */
    public static long fpathconf(int x0, int x1) {
        var mh$ = fpathconf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpathconf", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getcwd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_POINTER,
            archive_h.C_POINTER,
            archive_h.C_LONG
        );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getcwd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static FunctionDescriptor getcwd$descriptor() {
        return getcwd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MethodHandle getcwd$handle() {
        return getcwd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MemorySegment getcwd$address() {
        return getcwd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getcwd(char *, size_t)
     * }
     */
    public static MemorySegment getcwd(MemorySegment x0, long x1) {
        var mh$ = getcwd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getcwd", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getegid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("getegid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static FunctionDescriptor getegid$descriptor() {
        return getegid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static MethodHandle getegid$handle() {
        return getegid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static MemorySegment getegid$address() {
        return getegid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * gid_t getegid()
     * }
     */
    public static int getegid() {
        var mh$ = getegid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getegid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class geteuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            archive_h.C_INT    );

        public static final MemorySegment ADDR = archive_h.findOrThrow("geteuid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static FunctionDescriptor geteuid$descriptor() {
        return geteuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static MethodHandle geteuid$handle() {
        return geteuid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static MemorySegment geteuid$address() {
        return geteuid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uid_t geteuid()
     * }
     */
    public static int geteuid() {
        var mh$ = geteuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("geteuid");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

